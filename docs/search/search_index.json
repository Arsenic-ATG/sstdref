{"config":{"lang":["en","ja"],"min_search_length":3,"prebuild_index":false,"separator":"[\\s\\-]+"},"docs":[{"location":"","text":".img_overlay { /* parent div */ position: relative; } .img_overlay p { position: absolute; font-size: 40px; font-weight: normal; color: white; /* string color */ top: 0; left: 0; margin:0; padding:0; margin-top:-5px; } .img_overlay img { width: 100%; } SubStandardLibrary What is SSTD ? SubStandardLibrary (SSTD) is a convenient functions set for C++, works on GCC (g++). Installation Downloading source code from github.com/admiswalker/SubStandardLibrary . Copying all of under ./sstd/*. Compilling the sstd. $ cd ./sstd $ make Adding flags in your makefile. CFLAGS += -I./sstd/include -L./sstd/lib -lsstd CFLAGS += -std=gnu++0x Including a header #include <sstd/sstd.hpp> in your code. License MIT licence or Public domain. (This software is dual license, so you can choose whichever you want). Repository github.com/admiswalker/SubStandardLibrary","title":"What is SSTD ?"},{"location":"#what-is-sstd","text":"SubStandardLibrary (SSTD) is a convenient functions set for C++, works on GCC (g++).","title":"What is SSTD ?"},{"location":"#installation","text":"Downloading source code from github.com/admiswalker/SubStandardLibrary . Copying all of under ./sstd/*. Compilling the sstd. $ cd ./sstd $ make Adding flags in your makefile. CFLAGS += -I./sstd/include -L./sstd/lib -lsstd CFLAGS += -std=gnu++0x Including a header #include <sstd/sstd.hpp> in your code.","title":"Installation"},{"location":"#license","text":"MIT licence or Public domain. (This software is dual license, so you can choose whichever you want).","title":"License"},{"location":"#repository","text":"github.com/admiswalker/SubStandardLibrary","title":"Repository"},{"location":"src/glob/","text":"glob Abstract glob \u306f\uff0c\u6b63\u898f\u8868\u73fe * \u306b\u3088\u308a\uff0c\u30c7\u30a3\u30ec\u30af\u30c8\u30ea\u3092\u63a2\u7d22\u3057\u307e\u3059\uff0e \u203b\u305d\u306e\u4ed6\u306e\u6b63\u898f\u8868\u73fe\u306b\u3064\u3044\u3066\u306f\uff0c\u73fe\u72b6\u672a\u5b9f\u88c5\u3067\u3059\uff0e Header file namespace sstd { std :: vector < std :: string > glob ( const char * path ); std :: vector < std :: string > glob ( const std :: string & path ); } Usage input #include <sstd/sstd.hpp> int main (){ sstd :: mkdir ( \"./tmp\" ); sstd :: system ( \"touch ./tmp/a.txt\" ); sstd :: system ( \"touch ./tmp/b.csv\" ); sstd :: system ( \"touch ./tmp/c.txt\" ); std :: vector < std :: string > vStr = sstd :: glob ( \"./tmp/*.txt\" ); sstd :: printn ( vStr ); sstd :: rm ( \"./tmp\" ); } output vStr = [\"./tmp/a.txt\" \"./tmp/c.txt\"] Implementation Source: sstd/src/glob.cpp Header: sstd/src/glob.hpp Test: test/glob.hpp","title":"glob"},{"location":"src/glob/#glob","text":"","title":"glob"},{"location":"src/glob/#abstract","text":"glob \u306f\uff0c\u6b63\u898f\u8868\u73fe * \u306b\u3088\u308a\uff0c\u30c7\u30a3\u30ec\u30af\u30c8\u30ea\u3092\u63a2\u7d22\u3057\u307e\u3059\uff0e \u203b\u305d\u306e\u4ed6\u306e\u6b63\u898f\u8868\u73fe\u306b\u3064\u3044\u3066\u306f\uff0c\u73fe\u72b6\u672a\u5b9f\u88c5\u3067\u3059\uff0e","title":"Abstract"},{"location":"src/glob/#header-file","text":"namespace sstd { std :: vector < std :: string > glob ( const char * path ); std :: vector < std :: string > glob ( const std :: string & path ); }","title":"Header file"},{"location":"src/glob/#usage","text":"input #include <sstd/sstd.hpp> int main (){ sstd :: mkdir ( \"./tmp\" ); sstd :: system ( \"touch ./tmp/a.txt\" ); sstd :: system ( \"touch ./tmp/b.csv\" ); sstd :: system ( \"touch ./tmp/c.txt\" ); std :: vector < std :: string > vStr = sstd :: glob ( \"./tmp/*.txt\" ); sstd :: printn ( vStr ); sstd :: rm ( \"./tmp\" ); } output vStr = [\"./tmp/a.txt\" \"./tmp/c.txt\"]","title":"Usage"},{"location":"src/glob/#implementation","text":"Source: sstd/src/glob.cpp Header: sstd/src/glob.hpp Test: test/glob.hpp","title":"Implementation"},{"location":"src/itr/","text":"itr Abstract sstd::begin() and sstd::end() are the definitions for SSTD iterator. sstd::begin() \u3068 sstd::end() \u306f SSTD \u306e\u30a4\u30c6\u30ec\u30fc\u30bf\u306b\u5229\u7528\u3059\u308b\u305f\u3081\u306e\u5b9a\u7fa9\u3067\u3059\uff0e Header file namespace sstd { class begin ; class end ; } Usage input #include <sstd/sstd.hpp> int main (){ std :: vector < int > v = { 1 , 2 , 3 , 4 , 5 }; std :: vector < int > v_sliced = v && sstd :: slice ( sstd :: begin (), sstd :: end ()); sstd :: printn ( v ); sstd :: printn ( v_sliced ); } output v = [1 2 3 4 5] v_sliced = [1 2 3 4 5] Implementation Header: sstd/src/itr.hpp","title":"itr"},{"location":"src/itr/#itr","text":"","title":"itr"},{"location":"src/itr/#abstract","text":"sstd::begin() and sstd::end() are the definitions for SSTD iterator. sstd::begin() \u3068 sstd::end() \u306f SSTD \u306e\u30a4\u30c6\u30ec\u30fc\u30bf\u306b\u5229\u7528\u3059\u308b\u305f\u3081\u306e\u5b9a\u7fa9\u3067\u3059\uff0e","title":"Abstract"},{"location":"src/itr/#header-file","text":"namespace sstd { class begin ; class end ; }","title":"Header file"},{"location":"src/itr/#usage","text":"input #include <sstd/sstd.hpp> int main (){ std :: vector < int > v = { 1 , 2 , 3 , 4 , 5 }; std :: vector < int > v_sliced = v && sstd :: slice ( sstd :: begin (), sstd :: end ()); sstd :: printn ( v ); sstd :: printn ( v_sliced ); } output v = [1 2 3 4 5] v_sliced = [1 2 3 4 5]","title":"Usage"},{"location":"src/itr/#implementation","text":"Header: sstd/src/itr.hpp","title":"Implementation"},{"location":"src/measureTime/","text":"measureTime Abstract measureTime measures the execution time. measureTime \u306f\u5b9f\u884c\u6642\u9593\u3092\u8a08\u6e2c\u3057\u307e\u3059\uff0e Header file namespace sstd { void measureTime_start ( time_m & startTime ); double measureTime_stop_s ( const time_m & startTime ); // sec double measureTime_stop_ms ( const time_m & startTime ); // milli sec double measureTime_stop_us ( const time_m & startTime ); // micro sec double measureTime_stop_ns ( const time_m & startTime ); // nano sec std :: string measureTime_ms2str ( uint64 tmp ); std :: string measureTime_stop_str ( const time_m & startTime ); void measureTime_stop_print ( const time_m & startTime ); } Usage Measurement of execution time. (\u5b9f\u884c\u6642\u9593\u306e\u8a08\u6e2c) input #include <sstd/sstd.hpp> int main (){ printf ( \" \\n \" ); printf ( \"+---------------------------------------------------+ \\n \" ); printf ( \"| | \\n \" ); printf ( \"| Welcome to Sub Standard Library (SSTD) ! | \\n \" ); printf ( \"| | \\n \" ); printf ( \"+---------------------------------------------------+ \\n \" ); printf ( \" \\n \" ); printf ( \"\u25a0 measureTime_start--------------- \\n\\n \" ); time_m timem ; sstd :: measureTime_start ( timem ); sstd :: sleep_s ( 1 ); sstd :: sleep_ms ( 100 ); sstd :: sleep_us ( 11 * 1000 ); printf ( \" \\n \" ); printf ( \"\u25a0 measureTime_stop---------------- \\n \" ); sstd :: measureTime_stop_print ( timem ); sstd :: pauseIfWin32 (); return 0 ; } output +---------------------------------------------------+ | | | Welcome to Sub Standard Library (SSTD) ! | | | +---------------------------------------------------+ \u25a0 measureTime_start--------------- \u25a0 measureTime_stop---------------- -------------------------------- Execution time: 1. 118 sec -------------------------------- Lap time measurement. (\u30e9\u30c3\u30d7\u30bf\u30a4\u30e0\u306e\u6e2c\u5b9a) input #include <sstd/sstd.hpp> int main (){ std :: vector < double > vLT_ms ; time_m timem ; sstd :: measureTime_start ( timem ); vLT_ms . push_back ( sstd :: measureTime_stop_ms ( timem ) ); for ( uint i = 0 ; i < 5 ; ++ i ){ sstd :: sleep_ms ( 10 ); vLT_ms . push_back ( sstd :: measureTime_stop_ms ( timem ) ); } sstd :: printn ( vLT_ms ); return 0 ; } output vLT_ms = [0. 10.885 21.131 31.22 41.383 51.451] Implementation Source: sstd/src/measureTime.cpp Header: sstd/src/measureTime.hpp Test: test/measureTime.hpp","title":"measureTime"},{"location":"src/measureTime/#measuretime","text":"","title":"measureTime"},{"location":"src/measureTime/#abstract","text":"measureTime measures the execution time. measureTime \u306f\u5b9f\u884c\u6642\u9593\u3092\u8a08\u6e2c\u3057\u307e\u3059\uff0e","title":"Abstract"},{"location":"src/measureTime/#header-file","text":"namespace sstd { void measureTime_start ( time_m & startTime ); double measureTime_stop_s ( const time_m & startTime ); // sec double measureTime_stop_ms ( const time_m & startTime ); // milli sec double measureTime_stop_us ( const time_m & startTime ); // micro sec double measureTime_stop_ns ( const time_m & startTime ); // nano sec std :: string measureTime_ms2str ( uint64 tmp ); std :: string measureTime_stop_str ( const time_m & startTime ); void measureTime_stop_print ( const time_m & startTime ); }","title":"Header file"},{"location":"src/measureTime/#usage","text":"","title":"Usage"},{"location":"src/measureTime/#measurement-of-execution-time","text":"input #include <sstd/sstd.hpp> int main (){ printf ( \" \\n \" ); printf ( \"+---------------------------------------------------+ \\n \" ); printf ( \"| | \\n \" ); printf ( \"| Welcome to Sub Standard Library (SSTD) ! | \\n \" ); printf ( \"| | \\n \" ); printf ( \"+---------------------------------------------------+ \\n \" ); printf ( \" \\n \" ); printf ( \"\u25a0 measureTime_start--------------- \\n\\n \" ); time_m timem ; sstd :: measureTime_start ( timem ); sstd :: sleep_s ( 1 ); sstd :: sleep_ms ( 100 ); sstd :: sleep_us ( 11 * 1000 ); printf ( \" \\n \" ); printf ( \"\u25a0 measureTime_stop---------------- \\n \" ); sstd :: measureTime_stop_print ( timem ); sstd :: pauseIfWin32 (); return 0 ; } output +---------------------------------------------------+ | | | Welcome to Sub Standard Library (SSTD) ! | | | +---------------------------------------------------+ \u25a0 measureTime_start--------------- \u25a0 measureTime_stop---------------- -------------------------------- Execution time: 1. 118 sec --------------------------------","title":"Measurement of execution time. (\u5b9f\u884c\u6642\u9593\u306e\u8a08\u6e2c)"},{"location":"src/measureTime/#lap-time-measurement","text":"input #include <sstd/sstd.hpp> int main (){ std :: vector < double > vLT_ms ; time_m timem ; sstd :: measureTime_start ( timem ); vLT_ms . push_back ( sstd :: measureTime_stop_ms ( timem ) ); for ( uint i = 0 ; i < 5 ; ++ i ){ sstd :: sleep_ms ( 10 ); vLT_ms . push_back ( sstd :: measureTime_stop_ms ( timem ) ); } sstd :: printn ( vLT_ms ); return 0 ; } output vLT_ms = [0. 10.885 21.131 31.22 41.383 51.451]","title":"Lap time measurement. (\u30e9\u30c3\u30d7\u30bf\u30a4\u30e0\u306e\u6e2c\u5b9a)"},{"location":"src/measureTime/#implementation","text":"Source: sstd/src/measureTime.cpp Header: sstd/src/measureTime.hpp Test: test/measureTime.hpp","title":"Implementation"},{"location":"src/mkdir/","text":"mkdir Abstract mkdir creates directories recursively. mkdir \u306f\u30c7\u30a3\u30ec\u30af\u30c8\u30ea\u3092\u518d\u5e30\u7684\u306b\u4f5c\u6210\u3057\u307e\u3059\uff0e Header file namespace sstd { void mkdir ( const char * pPath ); void mkdir ( const std :: string & path ); } Usage input #include <sstd/sstd.hpp> int main (){ sstd :: mkdir ( \"./tmp/a/b/c/\" ); sstd :: system ( \"tree ./tmp\" ); sstd :: rm ( \"./tmp\" ); } output ./tmp \u2514\u2500\u2500 a \u2514\u2500\u2500 b \u2514\u2500\u2500 c 3 directories, 0 files Implementation Source: sstd/src/mkdir.cpp Header: sstd/src/mkdir.hpp Test: test/mkdir.hpp (Not implemented yet)","title":"mkdir"},{"location":"src/mkdir/#mkdir","text":"","title":"mkdir"},{"location":"src/mkdir/#abstract","text":"mkdir creates directories recursively. mkdir \u306f\u30c7\u30a3\u30ec\u30af\u30c8\u30ea\u3092\u518d\u5e30\u7684\u306b\u4f5c\u6210\u3057\u307e\u3059\uff0e","title":"Abstract"},{"location":"src/mkdir/#header-file","text":"namespace sstd { void mkdir ( const char * pPath ); void mkdir ( const std :: string & path ); }","title":"Header file"},{"location":"src/mkdir/#usage","text":"input #include <sstd/sstd.hpp> int main (){ sstd :: mkdir ( \"./tmp/a/b/c/\" ); sstd :: system ( \"tree ./tmp\" ); sstd :: rm ( \"./tmp\" ); } output ./tmp \u2514\u2500\u2500 a \u2514\u2500\u2500 b \u2514\u2500\u2500 c 3 directories, 0 files","title":"Usage"},{"location":"src/mkdir/#implementation","text":"Source: sstd/src/mkdir.cpp Header: sstd/src/mkdir.hpp Test: test/mkdir.hpp (Not implemented yet)","title":"Implementation"},{"location":"src/path/","text":"path Abstract path.hpp contains functions for path editing. path.hpp \u306f\u30d1\u30b9\u7de8\u96c6\u7528\u306e\u95a2\u6570\u3092\u53ce\u9332\u3057\u307e\u3059\uff0e Header file namespace sstd { std :: string getPath ( const char * pPath ); char * getFileName ( const char * pPath ); std :: string getFileName_withoutExtension ( const char * pPath ); char * getExtension ( const char * pPath ); std :: vector < std :: string > parsePath ( const char * pPath ); std :: vector < std :: string > parsePath_withBase ( const char * pPath ); bool isFile ( const char * pPath ); bool isFile ( const std :: string & path ); bool isDir ( const char * pPath ); bool isDir ( const std :: string & path ); bool fileExist ( const char * pPath ); bool fileExist ( const std :: string & path ); bool dirExist ( const char * pPath ); bool dirExist ( const std :: string & path ); bool pathExist ( const char * pPath ); bool pathExist ( const std :: string & path ); } Usage input #include <sstd/sstd.hpp> int main (){ std :: string path = \"./abc/DEF/example.txt\" ; sstd :: printn ( sstd :: getPath ( path . c_str ()) ); sstd :: printn ( sstd :: getFileName ( path . c_str ()) ); sstd :: printn ( sstd :: getFileName_withoutExtension ( path . c_str ()) ); sstd :: printn ( sstd :: getExtension ( path . c_str ()) ); printf ( \" \\n \" ); sstd :: printn ( sstd :: parsePath ( path . c_str ()) ); sstd :: printn ( sstd :: parsePath_withBase ( path . c_str ()) ); printf ( \" \\n \" ); std :: string path_dir = \"./tmp\" ; std :: string path_file = \"./tmp/example.txt\" ; sstd :: system ( sstd :: ssprintf ( \"mkdir %s\" , path_dir . c_str ())); sstd :: system ( sstd :: ssprintf ( \"touch %s\" , path_file . c_str ())); sstd :: printn ( sstd :: isFile ( path_dir . c_str ()) ); sstd :: printn ( sstd :: isFile ( path_file . c_str ()) ); printf ( \" \\n \" ); sstd :: printn ( sstd :: isDir ( path_dir . c_str ()) ); sstd :: printn ( sstd :: isDir ( path_file . c_str ()) ); printf ( \" \\n \" ); sstd :: printn ( sstd :: fileExist ( path_file . c_str ()) ); sstd :: printn ( sstd :: dirExist ( path_dir . c_str ()) ); printf ( \" \\n \" ); sstd :: rm ( path_dir ); sstd :: printn ( sstd :: fileExist ( path_file . c_str ()) ); sstd :: printn ( sstd :: dirExist ( path_dir . c_str ()) ); } output sstd::getPath(path.c_str()) = \"./abc/DEF/\" sstd::getFileName(path.c_str()) = \"example.txt\" sstd::getFileName_withoutExtension(path.c_str()) = \"example\" sstd::getExtension(path.c_str()) = \"txt\" sstd::parsePath(path.c_str()) = [\".\" \"abc\" \"DEF\" \"example.txt\"] sstd::parsePath_withBase(path.c_str()) = [\".\" \"./abc\" \"./abc/DEF\" \"./abc/DEF/example.txt\"] sstd::isFile(path_dir.c_str()) = false sstd::isFile(path_file.c_str()) = true sstd::isDir(path_dir.c_str()) = true sstd::isDir(path_file.c_str()) = false sstd::fileExist(path_file.c_str()) = true sstd::dirExist(path_dir.c_str()) = true sstd::fileExist(path_file.c_str()) = false sstd::dirExist(path_dir.c_str()) = false Implementation Source: sstd/src/path.cpp Header: sstd/src/path.hpp Test: test/path.hpp (Not implemented yet)","title":"path"},{"location":"src/path/#path","text":"","title":"path"},{"location":"src/path/#abstract","text":"path.hpp contains functions for path editing. path.hpp \u306f\u30d1\u30b9\u7de8\u96c6\u7528\u306e\u95a2\u6570\u3092\u53ce\u9332\u3057\u307e\u3059\uff0e","title":"Abstract"},{"location":"src/path/#header-file","text":"namespace sstd { std :: string getPath ( const char * pPath ); char * getFileName ( const char * pPath ); std :: string getFileName_withoutExtension ( const char * pPath ); char * getExtension ( const char * pPath ); std :: vector < std :: string > parsePath ( const char * pPath ); std :: vector < std :: string > parsePath_withBase ( const char * pPath ); bool isFile ( const char * pPath ); bool isFile ( const std :: string & path ); bool isDir ( const char * pPath ); bool isDir ( const std :: string & path ); bool fileExist ( const char * pPath ); bool fileExist ( const std :: string & path ); bool dirExist ( const char * pPath ); bool dirExist ( const std :: string & path ); bool pathExist ( const char * pPath ); bool pathExist ( const std :: string & path ); }","title":"Header file"},{"location":"src/path/#usage","text":"input #include <sstd/sstd.hpp> int main (){ std :: string path = \"./abc/DEF/example.txt\" ; sstd :: printn ( sstd :: getPath ( path . c_str ()) ); sstd :: printn ( sstd :: getFileName ( path . c_str ()) ); sstd :: printn ( sstd :: getFileName_withoutExtension ( path . c_str ()) ); sstd :: printn ( sstd :: getExtension ( path . c_str ()) ); printf ( \" \\n \" ); sstd :: printn ( sstd :: parsePath ( path . c_str ()) ); sstd :: printn ( sstd :: parsePath_withBase ( path . c_str ()) ); printf ( \" \\n \" ); std :: string path_dir = \"./tmp\" ; std :: string path_file = \"./tmp/example.txt\" ; sstd :: system ( sstd :: ssprintf ( \"mkdir %s\" , path_dir . c_str ())); sstd :: system ( sstd :: ssprintf ( \"touch %s\" , path_file . c_str ())); sstd :: printn ( sstd :: isFile ( path_dir . c_str ()) ); sstd :: printn ( sstd :: isFile ( path_file . c_str ()) ); printf ( \" \\n \" ); sstd :: printn ( sstd :: isDir ( path_dir . c_str ()) ); sstd :: printn ( sstd :: isDir ( path_file . c_str ()) ); printf ( \" \\n \" ); sstd :: printn ( sstd :: fileExist ( path_file . c_str ()) ); sstd :: printn ( sstd :: dirExist ( path_dir . c_str ()) ); printf ( \" \\n \" ); sstd :: rm ( path_dir ); sstd :: printn ( sstd :: fileExist ( path_file . c_str ()) ); sstd :: printn ( sstd :: dirExist ( path_dir . c_str ()) ); } output sstd::getPath(path.c_str()) = \"./abc/DEF/\" sstd::getFileName(path.c_str()) = \"example.txt\" sstd::getFileName_withoutExtension(path.c_str()) = \"example\" sstd::getExtension(path.c_str()) = \"txt\" sstd::parsePath(path.c_str()) = [\".\" \"abc\" \"DEF\" \"example.txt\"] sstd::parsePath_withBase(path.c_str()) = [\".\" \"./abc\" \"./abc/DEF\" \"./abc/DEF/example.txt\"] sstd::isFile(path_dir.c_str()) = false sstd::isFile(path_file.c_str()) = true sstd::isDir(path_dir.c_str()) = true sstd::isDir(path_file.c_str()) = false sstd::fileExist(path_file.c_str()) = true sstd::dirExist(path_dir.c_str()) = true sstd::fileExist(path_file.c_str()) = false sstd::dirExist(path_dir.c_str()) = false","title":"Usage"},{"location":"src/path/#implementation","text":"Source: sstd/src/path.cpp Header: sstd/src/path.hpp Test: test/path.hpp (Not implemented yet)","title":"Implementation"},{"location":"src/pdbg/","text":"pdbg Abstract pdbg prints debug information. pdbg \u306f\u30c7\u30d0\u30c3\u30b0\u60c5\u5831\u3092\u51fa\u529b\u3057\u307e\u3059\uff0e Header file namespace sstd { inline void pdbg (...){} inline void pdbg_if (...){} inline void pdbg_if_exit (...){} inline void pdbg_if_stop_exit (...){} inline void dbg (...){} inline void ndbg (...){} } Usage input #include <sstd/sstd.hpp> int main (){ sstd :: pdbg ( \"ERROR: printing error reasons. \\n \" ); printf ( \" \\n \" ); printf ( \"True: \" ); sstd :: pdbg_if ( true , \"ERROR: printing error reasons. \\n \" ); printf ( \"False: \" ); sstd :: pdbg_if ( false , \"ERROR: printing error reasons. \\n \" ); printf ( \" \\n \" ); return 0 ; } output .././tmp/.._._docs_src_docs_src_pdbg.md_32.cpp: main(4): ERROR: printing error reasons. True: .././tmp/.._._docs_src_docs_src_pdbg.md_32.cpp: main(7): ERROR: printing error reasons. False: Implementation Source: sstd/src/XXXXXX.cpp Header: sstd/src/XXXXXX.hpp Test: test/XXXXXX.hpp (Not implemented yet)","title":"pdbg"},{"location":"src/pdbg/#pdbg","text":"","title":"pdbg"},{"location":"src/pdbg/#abstract","text":"pdbg prints debug information. pdbg \u306f\u30c7\u30d0\u30c3\u30b0\u60c5\u5831\u3092\u51fa\u529b\u3057\u307e\u3059\uff0e","title":"Abstract"},{"location":"src/pdbg/#header-file","text":"namespace sstd { inline void pdbg (...){} inline void pdbg_if (...){} inline void pdbg_if_exit (...){} inline void pdbg_if_stop_exit (...){} inline void dbg (...){} inline void ndbg (...){} }","title":"Header file"},{"location":"src/pdbg/#usage","text":"input #include <sstd/sstd.hpp> int main (){ sstd :: pdbg ( \"ERROR: printing error reasons. \\n \" ); printf ( \" \\n \" ); printf ( \"True: \" ); sstd :: pdbg_if ( true , \"ERROR: printing error reasons. \\n \" ); printf ( \"False: \" ); sstd :: pdbg_if ( false , \"ERROR: printing error reasons. \\n \" ); printf ( \" \\n \" ); return 0 ; } output .././tmp/.._._docs_src_docs_src_pdbg.md_32.cpp: main(4): ERROR: printing error reasons. True: .././tmp/.._._docs_src_docs_src_pdbg.md_32.cpp: main(7): ERROR: printing error reasons. False:","title":"Usage"},{"location":"src/pdbg/#implementation","text":"Source: sstd/src/XXXXXX.cpp Header: sstd/src/XXXXXX.hpp Test: test/XXXXXX.hpp (Not implemented yet)","title":"Implementation"},{"location":"src/pid/","text":"pid Abstract getpid returns the PID of its own process. getpid \u306f\u81ea\u30d7\u30ed\u30bb\u30b9\u306e PID \u3092\u8fd4\u3057\u307e\u3059\uff0e Header file namespace sstd { int32 getpid (); } Usage input #include <sstd/sstd.hpp> int main (){ sstd :: printn ( sstd :: getpid () ); } output sstd::getpid() = 22843 Implementation Source: sstd/src/pid.cpp Header: sstd/src/pid.hpp Test: test/pid.hpp (Not implemented yet)","title":"pid"},{"location":"src/pid/#pid","text":"","title":"pid"},{"location":"src/pid/#abstract","text":"getpid returns the PID of its own process. getpid \u306f\u81ea\u30d7\u30ed\u30bb\u30b9\u306e PID \u3092\u8fd4\u3057\u307e\u3059\uff0e","title":"Abstract"},{"location":"src/pid/#header-file","text":"namespace sstd { int32 getpid (); }","title":"Header file"},{"location":"src/pid/#usage","text":"input #include <sstd/sstd.hpp> int main (){ sstd :: printn ( sstd :: getpid () ); } output sstd::getpid() = 22843","title":"Usage"},{"location":"src/pid/#implementation","text":"Source: sstd/src/pid.cpp Header: sstd/src/pid.hpp Test: test/pid.hpp (Not implemented yet)","title":"Implementation"},{"location":"src/rm/","text":"rm Abstract rm.cpp / rm.hpp contains the processing related to deletion. rm.cpp / rm.hpp \u306b\u306f\u30c7\u30a3\u30ec\u30af\u30c8\u30ea\u524a\u9664\u306b\u95a2\u3059\u308b\u51e6\u7406\u3092\u53ce\u9332\u3057\u307e\u3059\uff0e Header file namespace sstd { struct pathAndType { std :: string path ; char type ; // 'f': file, 'd': directory }; bool unlink ( const char * pPath ); // delete file bool unlink ( const std :: string & path ); // delete file bool rmdir ( const char * pPath ); // delete empty directory bool rmdir ( const std :: string & path ); // delete empty directory bool getAllPath ( std :: vector < struct sstd :: pathAndType >& ret , const char * pPath ); // get all path in the directory bool getAllPath ( std :: vector < std :: string >& ret , const char * pPath ); // get all path in the directory bool getAllFile ( std :: vector < std :: string >& ret , const char * pPath ); // get all file path in the directory bool getAllDir ( std :: vector < std :: string >& ret , const char * pPath ); // get all directory path in the directory bool rm ( const char * pPath ); // delete all under the pPath bool rm ( const std :: string & path ); // delete all under the path } Usage Removing directories recursively (\u30c7\u30a3\u30ec\u30af\u30c8\u30ea\u306e\u518d\u5e30\u7684\u306a\u524a\u9664) input #include <sstd/sstd.hpp> int main (){ printf ( \"--- mkdir --- \\n \" ); fflush ( stdout ); sstd :: mkdir ( \"./tmp/a/b/c\" ); sstd :: system ( \"tree ./tmp\" ); printf ( \" \\n\\n \" ); printf ( \"--- rm --- \\n \" ); fflush ( stdout ); sstd :: rm ( \"./tmp\" ); sstd :: system ( \"tree ./tmp\" ); } output --- mkdir --- ./tmp \u2514\u2500\u2500 a \u2514\u2500\u2500 b \u2514\u2500\u2500 c 3 directories, 0 files --- rm --- ./tmp [error opening dir] 0 directories, 0 files Implementation Source: sstd/src/rm.cpp Header: sstd/src/rm.hpp Test: test/rm.hpp (Not implemented yet)","title":"rm"},{"location":"src/rm/#rm","text":"","title":"rm"},{"location":"src/rm/#abstract","text":"rm.cpp / rm.hpp contains the processing related to deletion. rm.cpp / rm.hpp \u306b\u306f\u30c7\u30a3\u30ec\u30af\u30c8\u30ea\u524a\u9664\u306b\u95a2\u3059\u308b\u51e6\u7406\u3092\u53ce\u9332\u3057\u307e\u3059\uff0e","title":"Abstract"},{"location":"src/rm/#header-file","text":"namespace sstd { struct pathAndType { std :: string path ; char type ; // 'f': file, 'd': directory }; bool unlink ( const char * pPath ); // delete file bool unlink ( const std :: string & path ); // delete file bool rmdir ( const char * pPath ); // delete empty directory bool rmdir ( const std :: string & path ); // delete empty directory bool getAllPath ( std :: vector < struct sstd :: pathAndType >& ret , const char * pPath ); // get all path in the directory bool getAllPath ( std :: vector < std :: string >& ret , const char * pPath ); // get all path in the directory bool getAllFile ( std :: vector < std :: string >& ret , const char * pPath ); // get all file path in the directory bool getAllDir ( std :: vector < std :: string >& ret , const char * pPath ); // get all directory path in the directory bool rm ( const char * pPath ); // delete all under the pPath bool rm ( const std :: string & path ); // delete all under the path }","title":"Header file"},{"location":"src/rm/#usage","text":"","title":"Usage"},{"location":"src/rm/#removing-directories-recursively","text":"input #include <sstd/sstd.hpp> int main (){ printf ( \"--- mkdir --- \\n \" ); fflush ( stdout ); sstd :: mkdir ( \"./tmp/a/b/c\" ); sstd :: system ( \"tree ./tmp\" ); printf ( \" \\n\\n \" ); printf ( \"--- rm --- \\n \" ); fflush ( stdout ); sstd :: rm ( \"./tmp\" ); sstd :: system ( \"tree ./tmp\" ); } output --- mkdir --- ./tmp \u2514\u2500\u2500 a \u2514\u2500\u2500 b \u2514\u2500\u2500 c 3 directories, 0 files --- rm --- ./tmp [error opening dir] 0 directories, 0 files","title":"Removing directories recursively (\u30c7\u30a3\u30ec\u30af\u30c8\u30ea\u306e\u518d\u5e30\u7684\u306a\u524a\u9664)"},{"location":"src/rm/#implementation","text":"Source: sstd/src/rm.cpp Header: sstd/src/rm.hpp Test: test/rm.hpp (Not implemented yet)","title":"Implementation"},{"location":"src/sleep/","text":"sleep Abstract sleep waits for the specified time. sleep \u306f\u6307\u5b9a\u6642\u9593\u5f85\u6a5f\u3057\u307e\u3059\uff0e Header file namespace sstd { inline void sleep_hour ( uint rhs ); inline void sleep_min ( uint rhs ); inline void sleep_s ( uint rhs ); inline void sleep_ms ( uint rhs ); inline void sleep_us ( uint rhs ); inline void sleep_ns ( uint rhs ); } Usage input #include <sstd/sstd.hpp> int main (){ time_m timem ; sstd :: measureTime_start ( timem ); sstd :: sleep_s ( 1 ); sstd :: sleep_ms ( 100 ); sstd :: sleep_us ( 11 * 1000 ); sstd :: measureTime_stop_print ( timem ); return 0 ; } output -------------------------------- Execution time: 1. 113 sec -------------------------------- Implementation Header: sstd/src/sleep.hpp Test: test/sleep.hpp (Not implemented yet)","title":"sleep"},{"location":"src/sleep/#sleep","text":"","title":"sleep"},{"location":"src/sleep/#abstract","text":"sleep waits for the specified time. sleep \u306f\u6307\u5b9a\u6642\u9593\u5f85\u6a5f\u3057\u307e\u3059\uff0e","title":"Abstract"},{"location":"src/sleep/#header-file","text":"namespace sstd { inline void sleep_hour ( uint rhs ); inline void sleep_min ( uint rhs ); inline void sleep_s ( uint rhs ); inline void sleep_ms ( uint rhs ); inline void sleep_us ( uint rhs ); inline void sleep_ns ( uint rhs ); }","title":"Header file"},{"location":"src/sleep/#usage","text":"input #include <sstd/sstd.hpp> int main (){ time_m timem ; sstd :: measureTime_start ( timem ); sstd :: sleep_s ( 1 ); sstd :: sleep_ms ( 100 ); sstd :: sleep_us ( 11 * 1000 ); sstd :: measureTime_stop_print ( timem ); return 0 ; } output -------------------------------- Execution time: 1. 113 sec --------------------------------","title":"Usage"},{"location":"src/sleep/#implementation","text":"Header: sstd/src/sleep.hpp Test: test/sleep.hpp (Not implemented yet)","title":"Implementation"},{"location":"src/ssprintf/","text":"ssprintf Abstract ssprintf() is the std::string version of sprintf() . ssprintf() \u306f\uff0c sprintf() \u306e std::string \u7248\u3067\u3059\uff0e Header file namespace sstd { std :: string ssprintf ( const char * format , ...); } Usage input #include <sstd/sstd.hpp> int main (){ std :: string s = sstd :: ssprintf ( \"%s %d%d%d %03d\" , \"ABC\" , 0 , 1 , 2 , 3 ); sstd :: printn ( s ); } output s = \"ABC 012 003\" Implementation Source: sstd/src/ssprintf.cpp Header: sstd/src/ssprintf.hpp Test: test/ssprintf.hpp (Not implemented yet)","title":"ssprintf"},{"location":"src/ssprintf/#ssprintf","text":"","title":"ssprintf"},{"location":"src/ssprintf/#abstract","text":"ssprintf() is the std::string version of sprintf() . ssprintf() \u306f\uff0c sprintf() \u306e std::string \u7248\u3067\u3059\uff0e","title":"Abstract"},{"location":"src/ssprintf/#header-file","text":"namespace sstd { std :: string ssprintf ( const char * format , ...); }","title":"Header file"},{"location":"src/ssprintf/#usage","text":"input #include <sstd/sstd.hpp> int main (){ std :: string s = sstd :: ssprintf ( \"%s %d%d%d %03d\" , \"ABC\" , 0 , 1 , 2 , 3 ); sstd :: printn ( s ); } output s = \"ABC 012 003\"","title":"Usage"},{"location":"src/ssprintf/#implementation","text":"Source: sstd/src/ssprintf.cpp Header: sstd/src/ssprintf.hpp Test: test/ssprintf.hpp (Not implemented yet)","title":"Implementation"},{"location":"src/strEdit/","text":"strEdit Abstract strEdit.hpp / strEdit.cpp \u306f\uff0c\u6587\u5b57\u5217\u3092\u7de8\u96c6\u3059\u308b\u305f\u3081\u306e\u95a2\u6570\u3092\u53ce\u9332\u3057\u3066\u3044\u308b\uff0e Header file namespace sstd { std :: vector < uint8 > readAll_bin ( const char * pReadFile ); // read all of the file as a binary std :: vector < uint8 > readAll_bin ( const std :: string & readFile ); // read all of the file as a binary bool writeAll_bin ( const char * pWritePath , std :: vector < uint8 >& rhs ); bool writeAll_bin ( const std :: string & writePath , std :: vector < uint8 >& rhs ); std :: string readAll ( const char * pReadFile ); // readAll_str() std :: string readAll ( const std :: string & readFile ); // readAll_str() std :: string readAll_withoutBOM ( const char * pReadFile ); std :: string readAll_withoutBOM ( const std :: string & readFile ); std :: vector < std :: string > splitByLine ( const std :: string & str ); std :: vector < std :: string > split ( const char * str , const char X ); std :: vector < std :: string > split ( const std :: string & str , const char X ); // remove space or tab. std :: string lstrip ( const char * str ); // removing head spaces std :: string lstrip ( const std :: string & str ); // removing head spaces void lstrip_ow ( std :: string & str ); // removing head spaces. ow: overwrite std :: string rstrip ( const char * str ); // removing tail spaces std :: string rstrip ( const std :: string & str ); // removing tail spaces void rstrip_ow ( std :: string & str ); // removing tail spaces. ow: overwrite std :: string strip ( const char * str ); // removing head and tail tab and spaces std :: string strip ( const std :: string & str ); // removing head and tail tab and spaces void strip_ow ( std :: string & str ); // removing head and tail tab and spaces. ow: overwrite std :: vector < std :: string > strip ( const std :: vector < std :: string >& vec ); // -> strip(str) // removing head and tail spaces bool strcmp ( const char * str1 , const char * str2 ); bool strcmp ( const char * str1 , const std :: string & str2 ); bool strcmp ( const std :: string & str1 , const char * str2 ); bool strcmp ( const std :: string & str1 , const std :: string & str2 ); bool strIn ( const char * lhs , const char * rhs ); // is lhs in rhs ? (is rhs include lhs ?) bool strIn ( const char * lhs , const std :: string & rhs ); bool strIn ( const std :: string & lhs , const char * rhs ); bool strIn ( const std :: string & lhs , const std :: string & rhs ); } Functions Removing spaces and tabs. \u7a7a\u767d (\u534a\u89d2\u30b9\u30da\u30fc\u30b9) \u3068\u30bf\u30d6\u6587\u5b57\u306e\u9664\u53bb\uff0e Name Description lstrip Removing head spaces and tabs. \u6587\u5b57\u5217\u306e\u5148\u982d\u306b\u3042\u308b\u534a\u89d2\u30b9\u30da\u30fc\u30b9\u3068\u30bf\u30d6\u6587\u5b57\u3092\u9664\u53bb\u3057\u307e\u3059\uff0e lstrip_ow Removing head spaces and tabs. _ow means overwrite. \u6587\u5b57\u5217\u306e\u5148\u982d\u306b\u3042\u308b\u534a\u89d2\u30b9\u30da\u30fc\u30b9\u3068\u30bf\u30d6\u6587\u5b57\u3092\u9664\u53bb\u3057\u307e\u3059\uff0e _ow \u306f overwrite \u306e\u610f\u5473\u3067\uff0c\u5f15\u6570\u306b\u7d50\u679c\u3092\u4e0a\u66f8\u304d\u3057\u307e\u3059\uff0e rstrip Removing tail spaces and tabs. \u6587\u5b57\u5217\u306e\u672b\u5c3e\u306b\u3042\u308b\u534a\u89d2\u30b9\u30da\u30fc\u30b9\u3068\u30bf\u30d6\u6587\u5b57\u3092\u9664\u53bb\u3057\u307e\u3059\uff0e rstrip_ow Removing tail spaces and tabs. _ow means overwrite. \u6587\u5b57\u5217\u306e\u672b\u5c3e\u306b\u3042\u308b\u534a\u89d2\u30b9\u30da\u30fc\u30b9\u3068\u30bf\u30d6\u6587\u5b57\u3092\u9664\u53bb\u3057\u307e\u3059\uff0e _ow \u306f overwrite \u306e\u610f\u5473\u3067\uff0c\u5f15\u6570\u306b\u7d50\u679c\u3092\u4e0a\u66f8\u304d\u3057\u307e\u3059\uff0e strip Removing head and tail spaces and tabs. \u6587\u5b57\u5217\u306e\u5148\u982d\u3068\u672b\u5c3e\u306b\u3042\u308b\u534a\u89d2\u30b9\u30da\u30fc\u30b9\u3068\u30bf\u30d6\u6587\u5b57\u3092\u9664\u53bb\u3057\u307e\u3059\uff0e strip_ow Removing head and tail spaces and tabs. _ow means overwrite. \u6587\u5b57\u5217\u306e\u5148\u982d\u3068\u672b\u5c3e\u306b\u3042\u308b\u534a\u89d2\u30b9\u30da\u30fc\u30b9\u3068\u30bf\u30d6\u6587\u5b57\u3092\u9664\u53bb\u3057\u307e\u3059\uff0e _ow \u306f overwrite \u306e\u610f\u5473\u3067\uff0c\u5f15\u6570\u306b\u7d50\u679c\u3092\u4e0a\u66f8\u304d\u3057\u307e\u3059\uff0e String comparison \u6587\u5b57\u5217\u306e\u6bd4\u8f03\uff0e\u5f15\u6570\u306e\u578b\u306e\u9055\u3044\u306b\u3088\u308a\u8907\u6570\u5b9a\u7fa9\u3055\u308c\u3066\u3044\u308b\uff0e Name Description strcmp Comparing two strings given as input arguments and returns true if they are equal, false otherwise. \u5165\u529b\u5f15\u6570\u306b\u4e0e\u3048\u3089\u308c\u308b 2 \u3064\u306e\u6587\u5b57\u5217\u3092\u6bd4\u8f03\u3057\uff0c\u7b49\u3057\u3044\u5834\u5408\u306f true \u3092\uff0c\u305d\u308c\u4ee5\u5916\u306f false \u3092\u8fd4\u3059\uff0e Usage input #include <sstd/sstd.hpp> int main (){ std :: string s = \" abc \" ; sstd :: printn ( sstd :: lstrip ( s )); sstd :: printn ( sstd :: rstrip ( s )); sstd :: printn ( sstd :: strip ( s )); sstd :: strip_ow ( s ); sstd :: printn ( s ); } output sstd::lstrip(s) = \"abc \" sstd::rstrip(s) = \" abc\" sstd::strip(s) = \"abc\" s = \"abc\" Implementation Source: sstd/src/vector/strEdit.cpp Header: sstd/src/vector/strEdit.hpp Test: test/strEdit.hpp","title":"strEdit"},{"location":"src/strEdit/#stredit","text":"","title":"strEdit"},{"location":"src/strEdit/#abstract","text":"strEdit.hpp / strEdit.cpp \u306f\uff0c\u6587\u5b57\u5217\u3092\u7de8\u96c6\u3059\u308b\u305f\u3081\u306e\u95a2\u6570\u3092\u53ce\u9332\u3057\u3066\u3044\u308b\uff0e","title":"Abstract"},{"location":"src/strEdit/#header-file","text":"namespace sstd { std :: vector < uint8 > readAll_bin ( const char * pReadFile ); // read all of the file as a binary std :: vector < uint8 > readAll_bin ( const std :: string & readFile ); // read all of the file as a binary bool writeAll_bin ( const char * pWritePath , std :: vector < uint8 >& rhs ); bool writeAll_bin ( const std :: string & writePath , std :: vector < uint8 >& rhs ); std :: string readAll ( const char * pReadFile ); // readAll_str() std :: string readAll ( const std :: string & readFile ); // readAll_str() std :: string readAll_withoutBOM ( const char * pReadFile ); std :: string readAll_withoutBOM ( const std :: string & readFile ); std :: vector < std :: string > splitByLine ( const std :: string & str ); std :: vector < std :: string > split ( const char * str , const char X ); std :: vector < std :: string > split ( const std :: string & str , const char X ); // remove space or tab. std :: string lstrip ( const char * str ); // removing head spaces std :: string lstrip ( const std :: string & str ); // removing head spaces void lstrip_ow ( std :: string & str ); // removing head spaces. ow: overwrite std :: string rstrip ( const char * str ); // removing tail spaces std :: string rstrip ( const std :: string & str ); // removing tail spaces void rstrip_ow ( std :: string & str ); // removing tail spaces. ow: overwrite std :: string strip ( const char * str ); // removing head and tail tab and spaces std :: string strip ( const std :: string & str ); // removing head and tail tab and spaces void strip_ow ( std :: string & str ); // removing head and tail tab and spaces. ow: overwrite std :: vector < std :: string > strip ( const std :: vector < std :: string >& vec ); // -> strip(str) // removing head and tail spaces bool strcmp ( const char * str1 , const char * str2 ); bool strcmp ( const char * str1 , const std :: string & str2 ); bool strcmp ( const std :: string & str1 , const char * str2 ); bool strcmp ( const std :: string & str1 , const std :: string & str2 ); bool strIn ( const char * lhs , const char * rhs ); // is lhs in rhs ? (is rhs include lhs ?) bool strIn ( const char * lhs , const std :: string & rhs ); bool strIn ( const std :: string & lhs , const char * rhs ); bool strIn ( const std :: string & lhs , const std :: string & rhs ); }","title":"Header file"},{"location":"src/strEdit/#functions","text":"Removing spaces and tabs. \u7a7a\u767d (\u534a\u89d2\u30b9\u30da\u30fc\u30b9) \u3068\u30bf\u30d6\u6587\u5b57\u306e\u9664\u53bb\uff0e Name Description lstrip Removing head spaces and tabs. \u6587\u5b57\u5217\u306e\u5148\u982d\u306b\u3042\u308b\u534a\u89d2\u30b9\u30da\u30fc\u30b9\u3068\u30bf\u30d6\u6587\u5b57\u3092\u9664\u53bb\u3057\u307e\u3059\uff0e lstrip_ow Removing head spaces and tabs. _ow means overwrite. \u6587\u5b57\u5217\u306e\u5148\u982d\u306b\u3042\u308b\u534a\u89d2\u30b9\u30da\u30fc\u30b9\u3068\u30bf\u30d6\u6587\u5b57\u3092\u9664\u53bb\u3057\u307e\u3059\uff0e _ow \u306f overwrite \u306e\u610f\u5473\u3067\uff0c\u5f15\u6570\u306b\u7d50\u679c\u3092\u4e0a\u66f8\u304d\u3057\u307e\u3059\uff0e rstrip Removing tail spaces and tabs. \u6587\u5b57\u5217\u306e\u672b\u5c3e\u306b\u3042\u308b\u534a\u89d2\u30b9\u30da\u30fc\u30b9\u3068\u30bf\u30d6\u6587\u5b57\u3092\u9664\u53bb\u3057\u307e\u3059\uff0e rstrip_ow Removing tail spaces and tabs. _ow means overwrite. \u6587\u5b57\u5217\u306e\u672b\u5c3e\u306b\u3042\u308b\u534a\u89d2\u30b9\u30da\u30fc\u30b9\u3068\u30bf\u30d6\u6587\u5b57\u3092\u9664\u53bb\u3057\u307e\u3059\uff0e _ow \u306f overwrite \u306e\u610f\u5473\u3067\uff0c\u5f15\u6570\u306b\u7d50\u679c\u3092\u4e0a\u66f8\u304d\u3057\u307e\u3059\uff0e strip Removing head and tail spaces and tabs. \u6587\u5b57\u5217\u306e\u5148\u982d\u3068\u672b\u5c3e\u306b\u3042\u308b\u534a\u89d2\u30b9\u30da\u30fc\u30b9\u3068\u30bf\u30d6\u6587\u5b57\u3092\u9664\u53bb\u3057\u307e\u3059\uff0e strip_ow Removing head and tail spaces and tabs. _ow means overwrite. \u6587\u5b57\u5217\u306e\u5148\u982d\u3068\u672b\u5c3e\u306b\u3042\u308b\u534a\u89d2\u30b9\u30da\u30fc\u30b9\u3068\u30bf\u30d6\u6587\u5b57\u3092\u9664\u53bb\u3057\u307e\u3059\uff0e _ow \u306f overwrite \u306e\u610f\u5473\u3067\uff0c\u5f15\u6570\u306b\u7d50\u679c\u3092\u4e0a\u66f8\u304d\u3057\u307e\u3059\uff0e String comparison \u6587\u5b57\u5217\u306e\u6bd4\u8f03\uff0e\u5f15\u6570\u306e\u578b\u306e\u9055\u3044\u306b\u3088\u308a\u8907\u6570\u5b9a\u7fa9\u3055\u308c\u3066\u3044\u308b\uff0e Name Description strcmp Comparing two strings given as input arguments and returns true if they are equal, false otherwise. \u5165\u529b\u5f15\u6570\u306b\u4e0e\u3048\u3089\u308c\u308b 2 \u3064\u306e\u6587\u5b57\u5217\u3092\u6bd4\u8f03\u3057\uff0c\u7b49\u3057\u3044\u5834\u5408\u306f true \u3092\uff0c\u305d\u308c\u4ee5\u5916\u306f false \u3092\u8fd4\u3059\uff0e","title":"Functions"},{"location":"src/strEdit/#usage","text":"input #include <sstd/sstd.hpp> int main (){ std :: string s = \" abc \" ; sstd :: printn ( sstd :: lstrip ( s )); sstd :: printn ( sstd :: rstrip ( s )); sstd :: printn ( sstd :: strip ( s )); sstd :: strip_ow ( s ); sstd :: printn ( s ); } output sstd::lstrip(s) = \"abc \" sstd::rstrip(s) = \" abc\" sstd::strip(s) = \"abc\" s = \"abc\"","title":"Usage"},{"location":"src/strEdit/#implementation","text":"Source: sstd/src/vector/strEdit.cpp Header: sstd/src/vector/strEdit.hpp Test: test/strEdit.hpp","title":"Implementation"},{"location":"src/strmatch/","text":"strmatch Abstract strmatch.hpp contains string comparision functions. strmatch.hpp \u306f\u6587\u5b57\u5217\u6bd4\u8f03\u95a2\u6570\u3092\u53ce\u9332\u3057\u3066\u3044\u307e\u3059\uff0e Header file namespace sstd { bool strmatch ( const char * str , const char * wildCard ); bool strmatch_getWC ( const char * str , const char * wildCard , std :: string & retWC ); bool isNum ( char rhs ); bool isAlphabet ( char rhs ); bool isAlphabet_onlyUpper ( char rhs ); bool isAlphabet_onlyLower ( char rhs ); } Usage strmatch(), strmatch_getWC() input #include <sstd/sstd.hpp> int main (){ std :: string s = \"TOKYOTO...\" ; sstd :: printn ( sstd :: strmatch ( s . c_str (), \"??KYOTO*\" ) ); // sstd::printn( sstd::strmatch(s, \"??KYOTO*\") ); // Not implimented yet std :: string ret ; sstd :: printn ( sstd :: strmatch_getWC ( s . c_str (), \"TO*...\" , ret ) ); sstd :: printn ( ret ); // It look like bug. we want \"KYOTO\" } output sstd::strmatch(s.c_str(), \"??KYOTO*\") = true sstd::strmatch_getWC(s.c_str(), \"TO*...\", ret) = true ret = \"KYOTO.\" isNum(), isAlphabet(), isAlphabet_onlyUpper(), isAlphabet_onlyLower() input #include <sstd/sstd.hpp> int main (){ sstd :: printn ( sstd :: isNum ( '0' ) ); sstd :: printn ( sstd :: isNum ( 'A' ) ); sstd :: printn ( sstd :: isNum ( 'a' ) ); printf ( \" \\n \" ); sstd :: printn ( sstd :: isAlphabet ( '0' ) ); sstd :: printn ( sstd :: isAlphabet ( 'A' ) ); sstd :: printn ( sstd :: isAlphabet ( 'a' ) ); printf ( \" \\n \" ); sstd :: printn ( sstd :: isAlphabet_onlyUpper ( '0' ) ); sstd :: printn ( sstd :: isAlphabet_onlyUpper ( 'A' ) ); sstd :: printn ( sstd :: isAlphabet_onlyUpper ( 'a' ) ); printf ( \" \\n \" ); sstd :: printn ( sstd :: isAlphabet_onlyLower ( '0' ) ); sstd :: printn ( sstd :: isAlphabet_onlyLower ( 'A' ) ); sstd :: printn ( sstd :: isAlphabet_onlyLower ( 'a' ) ); printf ( \" \\n \" ); } output sstd::isNum('0') = true sstd::isNum('A') = false sstd::isNum('a') = false sstd::isAlphabet('0') = false sstd::isAlphabet('A') = true sstd::isAlphabet('a') = true sstd::isAlphabet_onlyUpper('0') = false sstd::isAlphabet_onlyUpper('A') = true sstd::isAlphabet_onlyUpper('a') = false sstd::isAlphabet_onlyLower('0') = false sstd::isAlphabet_onlyLower('A') = false sstd::isAlphabet_onlyLower('a') = true Implementation Source: sstd/src/strmatch.cpp Header: sstd/src/strmatch.hpp Test: test/strmatch.hpp (Not implemented yet)","title":"strmatch"},{"location":"src/strmatch/#strmatch","text":"","title":"strmatch"},{"location":"src/strmatch/#abstract","text":"strmatch.hpp contains string comparision functions. strmatch.hpp \u306f\u6587\u5b57\u5217\u6bd4\u8f03\u95a2\u6570\u3092\u53ce\u9332\u3057\u3066\u3044\u307e\u3059\uff0e","title":"Abstract"},{"location":"src/strmatch/#header-file","text":"namespace sstd { bool strmatch ( const char * str , const char * wildCard ); bool strmatch_getWC ( const char * str , const char * wildCard , std :: string & retWC ); bool isNum ( char rhs ); bool isAlphabet ( char rhs ); bool isAlphabet_onlyUpper ( char rhs ); bool isAlphabet_onlyLower ( char rhs ); }","title":"Header file"},{"location":"src/strmatch/#usage","text":"","title":"Usage"},{"location":"src/strmatch/#strmatch-strmatch_getwc","text":"input #include <sstd/sstd.hpp> int main (){ std :: string s = \"TOKYOTO...\" ; sstd :: printn ( sstd :: strmatch ( s . c_str (), \"??KYOTO*\" ) ); // sstd::printn( sstd::strmatch(s, \"??KYOTO*\") ); // Not implimented yet std :: string ret ; sstd :: printn ( sstd :: strmatch_getWC ( s . c_str (), \"TO*...\" , ret ) ); sstd :: printn ( ret ); // It look like bug. we want \"KYOTO\" } output sstd::strmatch(s.c_str(), \"??KYOTO*\") = true sstd::strmatch_getWC(s.c_str(), \"TO*...\", ret) = true ret = \"KYOTO.\"","title":"strmatch(), strmatch_getWC()"},{"location":"src/strmatch/#isnum-isalphabet-isalphabet_onlyupper-isalphabet_onlylower","text":"input #include <sstd/sstd.hpp> int main (){ sstd :: printn ( sstd :: isNum ( '0' ) ); sstd :: printn ( sstd :: isNum ( 'A' ) ); sstd :: printn ( sstd :: isNum ( 'a' ) ); printf ( \" \\n \" ); sstd :: printn ( sstd :: isAlphabet ( '0' ) ); sstd :: printn ( sstd :: isAlphabet ( 'A' ) ); sstd :: printn ( sstd :: isAlphabet ( 'a' ) ); printf ( \" \\n \" ); sstd :: printn ( sstd :: isAlphabet_onlyUpper ( '0' ) ); sstd :: printn ( sstd :: isAlphabet_onlyUpper ( 'A' ) ); sstd :: printn ( sstd :: isAlphabet_onlyUpper ( 'a' ) ); printf ( \" \\n \" ); sstd :: printn ( sstd :: isAlphabet_onlyLower ( '0' ) ); sstd :: printn ( sstd :: isAlphabet_onlyLower ( 'A' ) ); sstd :: printn ( sstd :: isAlphabet_onlyLower ( 'a' ) ); printf ( \" \\n \" ); } output sstd::isNum('0') = true sstd::isNum('A') = false sstd::isNum('a') = false sstd::isAlphabet('0') = false sstd::isAlphabet('A') = true sstd::isAlphabet('a') = true sstd::isAlphabet_onlyUpper('0') = false sstd::isAlphabet_onlyUpper('A') = true sstd::isAlphabet_onlyUpper('a') = false sstd::isAlphabet_onlyLower('0') = false sstd::isAlphabet_onlyLower('A') = false sstd::isAlphabet_onlyLower('a') = true","title":"isNum(), isAlphabet(), isAlphabet_onlyUpper(), isAlphabet_onlyLower()"},{"location":"src/strmatch/#implementation","text":"Source: sstd/src/strmatch.cpp Header: sstd/src/strmatch.hpp Test: test/strmatch.hpp (Not implemented yet)","title":"Implementation"},{"location":"src/time/","text":"time Abstract struct tm \u3068 time_t (unixtime) \u304a\u3088\u3073\uff0c\u305d\u306e\u4ed6\u306e\u6642\u523b\u3092\u76f8\u4e92\u5909\u63db\u3059\u308b\uff0e Header file namespace sstd { struct tm time2tm ( time_t unixtime ); time_t tm2time ( struct tm & rhs ); struct tm timeGm2tmLocal ( time_t unixtime ); time_t tmLocal2timeGm ( struct tm & rhs ); std :: string time2str ( time_t unixtime ); std :: string tm2str ( struct tm & rhs ); double time2unixday ( time_t unixtime ); double tm2unixday ( struct tm & rhs ); time_t yday2time ( uint year , uint yday ); struct tm yday2tm ( uint year , uint yday ); struct timeval getTimeval (); double unixtime2JulianDate ( time_t unixtime ); double Julius_T ( time_t unixtime ); double JulianDate2Julius_T ( double JulianDate ); double TJuliusD ( time_t unixtime ); double JulianDate2TJuliusD ( double JulianDate ); void print ( const struct tm & rhs ); void for_printn ( const struct tm & rhs ); } Usage input #include <time.h> // for time() #include <sstd/sstd.hpp> int main (){ time_t unixtime_UTC ; time ( & unixtime_UTC ); // get current unixtime (UTC) struct tm tm_UTC = sstd :: time2tm ( unixtime_UTC ); struct tm tm_Local = sstd :: timeGm2tmLocal ( unixtime_UTC ); sstd :: printn ( unixtime_UTC ); sstd :: printn ( tm_UTC ); sstd :: printn ( tm_Local ); } output Below is the result on Japanese local time (UTC+9hour). unixtime_UTC = 1609253332 tm_UTC = 2020-12-29 14:48:52 tm_Local = 2020-12-29 23:48:52 Appendix struct tm { int tm_sec ; /* \u79d2 [0-61] \u6700\u59272\u79d2\u307e\u3067\u306e\u3046\u308b\u3046\u79d2\u3092\u8003\u616e */ int tm_min ; /* \u5206 [0-59] */ int tm_hour ; /* \u6642 [0-23] */ int tm_mday ; /* \u65e5 [1-31] */ int tm_mon ; /* \u6708 [0-11] 0\u304b\u3089\u59cb\u307e\u308b\u3053\u3068\u306b\u6ce8\u610f */ int tm_year ; /* \u5e74 [1900\u304b\u3089\u306e\u7d4c\u904e\u5e74\u6570] */ int tm_wday ; /* \u66dc\u65e5 [0:\u65e5 1:\u6708 ... 6:\u571f] */ int tm_yday ; /* \u5e74\u5185\u306e\u901a\u3057\u65e5\u6570 [0-365] 0\u304b\u3089\u59cb\u307e\u308b\u3053\u3068\u306b\u6ce8\u610f*/ int tm_isdst ; /* \u590f\u6642\u9593\u304c\u7121\u52b9\u3067\u3042\u308c\u3070 0 */ }; ref: localtime - \u521d\u5fc3\u8005\u306e\u305f\u3081\u306e\u30dd\u30a4\u30f3\u30c8\u5b66\u7fd2 C \u8a00\u8a9e Implementation Source: sstd/src/time.cpp Header: sstd/src/time.hpp Test: test/time.hpp (Not implemented yet)","title":"time"},{"location":"src/time/#time","text":"","title":"time"},{"location":"src/time/#abstract","text":"struct tm \u3068 time_t (unixtime) \u304a\u3088\u3073\uff0c\u305d\u306e\u4ed6\u306e\u6642\u523b\u3092\u76f8\u4e92\u5909\u63db\u3059\u308b\uff0e","title":"Abstract"},{"location":"src/time/#header-file","text":"namespace sstd { struct tm time2tm ( time_t unixtime ); time_t tm2time ( struct tm & rhs ); struct tm timeGm2tmLocal ( time_t unixtime ); time_t tmLocal2timeGm ( struct tm & rhs ); std :: string time2str ( time_t unixtime ); std :: string tm2str ( struct tm & rhs ); double time2unixday ( time_t unixtime ); double tm2unixday ( struct tm & rhs ); time_t yday2time ( uint year , uint yday ); struct tm yday2tm ( uint year , uint yday ); struct timeval getTimeval (); double unixtime2JulianDate ( time_t unixtime ); double Julius_T ( time_t unixtime ); double JulianDate2Julius_T ( double JulianDate ); double TJuliusD ( time_t unixtime ); double JulianDate2TJuliusD ( double JulianDate ); void print ( const struct tm & rhs ); void for_printn ( const struct tm & rhs ); }","title":"Header file"},{"location":"src/time/#usage","text":"input #include <time.h> // for time() #include <sstd/sstd.hpp> int main (){ time_t unixtime_UTC ; time ( & unixtime_UTC ); // get current unixtime (UTC) struct tm tm_UTC = sstd :: time2tm ( unixtime_UTC ); struct tm tm_Local = sstd :: timeGm2tmLocal ( unixtime_UTC ); sstd :: printn ( unixtime_UTC ); sstd :: printn ( tm_UTC ); sstd :: printn ( tm_Local ); } output Below is the result on Japanese local time (UTC+9hour). unixtime_UTC = 1609253332 tm_UTC = 2020-12-29 14:48:52 tm_Local = 2020-12-29 23:48:52","title":"Usage"},{"location":"src/time/#appendix","text":"struct tm { int tm_sec ; /* \u79d2 [0-61] \u6700\u59272\u79d2\u307e\u3067\u306e\u3046\u308b\u3046\u79d2\u3092\u8003\u616e */ int tm_min ; /* \u5206 [0-59] */ int tm_hour ; /* \u6642 [0-23] */ int tm_mday ; /* \u65e5 [1-31] */ int tm_mon ; /* \u6708 [0-11] 0\u304b\u3089\u59cb\u307e\u308b\u3053\u3068\u306b\u6ce8\u610f */ int tm_year ; /* \u5e74 [1900\u304b\u3089\u306e\u7d4c\u904e\u5e74\u6570] */ int tm_wday ; /* \u66dc\u65e5 [0:\u65e5 1:\u6708 ... 6:\u571f] */ int tm_yday ; /* \u5e74\u5185\u306e\u901a\u3057\u65e5\u6570 [0-365] 0\u304b\u3089\u59cb\u307e\u308b\u3053\u3068\u306b\u6ce8\u610f*/ int tm_isdst ; /* \u590f\u6642\u9593\u304c\u7121\u52b9\u3067\u3042\u308c\u3070 0 */ }; ref: localtime - \u521d\u5fc3\u8005\u306e\u305f\u3081\u306e\u30dd\u30a4\u30f3\u30c8\u5b66\u7fd2 C \u8a00\u8a9e","title":"Appendix"},{"location":"src/time/#implementation","text":"Source: sstd/src/time.cpp Header: sstd/src/time.hpp Test: test/time.hpp (Not implemented yet)","title":"Implementation"},{"location":"src/typeDef.h/","text":"typeDef.h Abstract Type definitions on SSTD. These definitions are read by #include <sstd/sstd.hpp> . SSTD \u306b\u304a\u3051\u308b\u578b\u306e\u5b9a\u7fa9\uff0e #include <sstd/sstd.hpp> \u306b\u3088\u308a\u5b9a\u7fa9\u304c\u8aad\u307f\u8fbc\u307e\u308c\u308b\uff0e Header file #pragma once #ifdef _WIN32 typedef unsigned char uchar ; typedef __int8 int8 ; typedef __int16 int16 ; typedef __int32 int32 ; typedef __int64 int64 ; typedef unsigned __int8 uint8 ; typedef unsigned __int16 uint16 ; typedef unsigned __int32 uint32 ; typedef unsigned __int64 uint64 ; #else #include <stdint.h> // intXX_t, uintXX_t \u304c\u5b9a\u7fa9\u3055\u308c\u3066\u3044\u308b typedef unsigned char uchar ; typedef int8_t int8 ; typedef int16_t int16 ; typedef int32_t int32 ; typedef int64_t int64 ; typedef uint8_t uint8 ; typedef uint16_t uint16 ; typedef uint32_t uint32 ; typedef uint64_t uint64 ; #endif #ifndef uint typedef unsigned int uint ; #endif Implementation Header: sstd/src/typeDef.hpp","title":"typeDef.h"},{"location":"src/typeDef.h/#typedefh","text":"","title":"typeDef.h"},{"location":"src/typeDef.h/#abstract","text":"Type definitions on SSTD. These definitions are read by #include <sstd/sstd.hpp> . SSTD \u306b\u304a\u3051\u308b\u578b\u306e\u5b9a\u7fa9\uff0e #include <sstd/sstd.hpp> \u306b\u3088\u308a\u5b9a\u7fa9\u304c\u8aad\u307f\u8fbc\u307e\u308c\u308b\uff0e","title":"Abstract"},{"location":"src/typeDef.h/#header-file","text":"#pragma once #ifdef _WIN32 typedef unsigned char uchar ; typedef __int8 int8 ; typedef __int16 int16 ; typedef __int32 int32 ; typedef __int64 int64 ; typedef unsigned __int8 uint8 ; typedef unsigned __int16 uint16 ; typedef unsigned __int32 uint32 ; typedef unsigned __int64 uint64 ; #else #include <stdint.h> // intXX_t, uintXX_t \u304c\u5b9a\u7fa9\u3055\u308c\u3066\u3044\u308b typedef unsigned char uchar ; typedef int8_t int8 ; typedef int16_t int16 ; typedef int32_t int32 ; typedef int64_t int64 ; typedef uint8_t uint8 ; typedef uint16_t uint16 ; typedef uint32_t uint32 ; typedef uint64_t uint64 ; #endif #ifndef uint typedef unsigned int uint ; #endif","title":"Header file"},{"location":"src/typeDef.h/#implementation","text":"Header: sstd/src/typeDef.hpp","title":"Implementation"},{"location":"src/hashFunction/md5/","text":"MD5 Abstract md5() calculate MD5 cryptographic hash function. md5() \u306f\u6697\u53f7\u5b66\u7684\u30cf\u30c3\u30b7\u30e5\u95a2\u6570\u3067\u3042\u308b MD5 \u3092\u8a08\u7b97\u3057\u307e\u3059\uff0e Header file namespace sstd { std :: vector < uint8 > md5 ( const uchar * in , size_t in_len ); std :: vector < uint8 > md5 ( const std :: vector < uint8 >& in ); } Usage input #include <sstd/sstd.hpp> std :: string uint8_to_str ( const std :: vector < uint8 >& v ){ std :: string s ; for ( uint i = 0 ; i < v . size (); ++ i ){ s += sstd :: ssprintf ( \"%02x\" , ( int ) v [ i ]); } return s ; } int main (){ sstd :: mkdir ( \"./tmp\" ); sstd :: system ( \"head -c 5m /dev/urandom > ./tmp/rand.txt\" ); // generate 5 MB random file sstd :: system ( \"md5sum ./tmp/rand.txt\" ); std :: vector < uint8 > vBin = sstd :: readAll_bin ( \"./tmp/rand.txt\" ); // read all as a binary std :: string md5_str = uint8_to_str ( sstd :: md5 ( vBin ) ); sstd :: printn ( md5_str ); sstd :: rm ( \"./tmp\" ); } output 34b62fb641944779c4500d29f2bc5b60 ./tmp/rand.txt md5_str = \"34b62fb641944779c4500d29f2bc5b60\" Implementation Source: sstd/src/hashFnc_of_MD5_SHA1_SHA2/sstd_md5_sha1_sha2_wrapper.cpp Header: sstd/src/hashFnc_of_MD5_SHA1_SHA2/sstd_md5_sha1_sha2_wrapper.hpp Test: test/hashFnc_of_MD5_SHA1_SHA2/sstd_md5_sha1_sha2_wrapper.hpp (Not implemented yet)","title":"MD5"},{"location":"src/hashFunction/md5/#md5","text":"","title":"MD5"},{"location":"src/hashFunction/md5/#abstract","text":"md5() calculate MD5 cryptographic hash function. md5() \u306f\u6697\u53f7\u5b66\u7684\u30cf\u30c3\u30b7\u30e5\u95a2\u6570\u3067\u3042\u308b MD5 \u3092\u8a08\u7b97\u3057\u307e\u3059\uff0e","title":"Abstract"},{"location":"src/hashFunction/md5/#header-file","text":"namespace sstd { std :: vector < uint8 > md5 ( const uchar * in , size_t in_len ); std :: vector < uint8 > md5 ( const std :: vector < uint8 >& in ); }","title":"Header file"},{"location":"src/hashFunction/md5/#usage","text":"input #include <sstd/sstd.hpp> std :: string uint8_to_str ( const std :: vector < uint8 >& v ){ std :: string s ; for ( uint i = 0 ; i < v . size (); ++ i ){ s += sstd :: ssprintf ( \"%02x\" , ( int ) v [ i ]); } return s ; } int main (){ sstd :: mkdir ( \"./tmp\" ); sstd :: system ( \"head -c 5m /dev/urandom > ./tmp/rand.txt\" ); // generate 5 MB random file sstd :: system ( \"md5sum ./tmp/rand.txt\" ); std :: vector < uint8 > vBin = sstd :: readAll_bin ( \"./tmp/rand.txt\" ); // read all as a binary std :: string md5_str = uint8_to_str ( sstd :: md5 ( vBin ) ); sstd :: printn ( md5_str ); sstd :: rm ( \"./tmp\" ); } output 34b62fb641944779c4500d29f2bc5b60 ./tmp/rand.txt md5_str = \"34b62fb641944779c4500d29f2bc5b60\"","title":"Usage"},{"location":"src/hashFunction/md5/#implementation","text":"Source: sstd/src/hashFnc_of_MD5_SHA1_SHA2/sstd_md5_sha1_sha2_wrapper.cpp Header: sstd/src/hashFnc_of_MD5_SHA1_SHA2/sstd_md5_sha1_sha2_wrapper.hpp Test: test/hashFnc_of_MD5_SHA1_SHA2/sstd_md5_sha1_sha2_wrapper.hpp (Not implemented yet)","title":"Implementation"},{"location":"src/hashFunction/sha1/","text":"SHA-1 Abstract sha1() calculate SHA-1 cryptographic hash function. sha1() \u306f\u6697\u53f7\u5b66\u7684\u30cf\u30c3\u30b7\u30e5\u95a2\u6570\u3067\u3042\u308b SHA-1 \u3092\u8a08\u7b97\u3057\u307e\u3059\uff0e Header file namespace sstd { std :: vector < uint8 > sha1 ( const uchar * in , size_t in_len ); std :: vector < uint8 > sha1 ( const std :: vector < uint8 >& in ); } Usage input #include <sstd/sstd.hpp> std :: string uint8_to_str ( const std :: vector < uint8 >& v ){ std :: string s ; for ( uint i = 0 ; i < v . size (); ++ i ){ s += sstd :: ssprintf ( \"%02x\" , ( int ) v [ i ]); } return s ; } int main (){ sstd :: mkdir ( \"./tmp\" ); sstd :: system ( \"head -c 5m /dev/urandom > ./tmp/rand.txt\" ); // generate 5 MB random file sstd :: system ( \"sha1sum ./tmp/rand.txt\" ); std :: vector < uint8 > vBin = sstd :: readAll_bin ( \"./tmp/rand.txt\" ); // read all as a binary std :: string md5_str = uint8_to_str ( sstd :: sha1 ( vBin ) ); sstd :: printn ( md5_str ); sstd :: rm ( \"./tmp\" ); } output 87202b5bab18258534053f6f1fb8d2c16bbdcdb5 ./tmp/rand.txt md5_str = \"87202b5bab18258534053f6f1fb8d2c16bbdcdb5\" Implementation Source: sstd/src/hashFnc_of_MD5_SHA1_SHA2/sstd_md5_sha1_sha2_wrapper.cpp Header: sstd/src/hashFnc_of_MD5_SHA1_SHA2/sstd_md5_sha1_sha2_wrapper.hpp Test: test/hashFnc_of_MD5_SHA1_SHA2/sstd_md5_sha1_sha2_wrapper.hpp (Not implemented yet)","title":"SHA-1"},{"location":"src/hashFunction/sha1/#sha-1","text":"","title":"SHA-1"},{"location":"src/hashFunction/sha1/#abstract","text":"sha1() calculate SHA-1 cryptographic hash function. sha1() \u306f\u6697\u53f7\u5b66\u7684\u30cf\u30c3\u30b7\u30e5\u95a2\u6570\u3067\u3042\u308b SHA-1 \u3092\u8a08\u7b97\u3057\u307e\u3059\uff0e","title":"Abstract"},{"location":"src/hashFunction/sha1/#header-file","text":"namespace sstd { std :: vector < uint8 > sha1 ( const uchar * in , size_t in_len ); std :: vector < uint8 > sha1 ( const std :: vector < uint8 >& in ); }","title":"Header file"},{"location":"src/hashFunction/sha1/#usage","text":"input #include <sstd/sstd.hpp> std :: string uint8_to_str ( const std :: vector < uint8 >& v ){ std :: string s ; for ( uint i = 0 ; i < v . size (); ++ i ){ s += sstd :: ssprintf ( \"%02x\" , ( int ) v [ i ]); } return s ; } int main (){ sstd :: mkdir ( \"./tmp\" ); sstd :: system ( \"head -c 5m /dev/urandom > ./tmp/rand.txt\" ); // generate 5 MB random file sstd :: system ( \"sha1sum ./tmp/rand.txt\" ); std :: vector < uint8 > vBin = sstd :: readAll_bin ( \"./tmp/rand.txt\" ); // read all as a binary std :: string md5_str = uint8_to_str ( sstd :: sha1 ( vBin ) ); sstd :: printn ( md5_str ); sstd :: rm ( \"./tmp\" ); } output 87202b5bab18258534053f6f1fb8d2c16bbdcdb5 ./tmp/rand.txt md5_str = \"87202b5bab18258534053f6f1fb8d2c16bbdcdb5\"","title":"Usage"},{"location":"src/hashFunction/sha1/#implementation","text":"Source: sstd/src/hashFnc_of_MD5_SHA1_SHA2/sstd_md5_sha1_sha2_wrapper.cpp Header: sstd/src/hashFnc_of_MD5_SHA1_SHA2/sstd_md5_sha1_sha2_wrapper.hpp Test: test/hashFnc_of_MD5_SHA1_SHA2/sstd_md5_sha1_sha2_wrapper.hpp (Not implemented yet)","title":"Implementation"},{"location":"src/hashFunction/sha2/","text":"SHA-2 (224, 256, 384, 512 bits) Abstract sha224() , sha256() , sha384() and sha512() calculate SHA-2 cryptographic hash function. sha224() , sha256() , sha384() \u304a\u3088\u3073 sha512() \u306f\u6697\u53f7\u5b66\u7684\u30cf\u30c3\u30b7\u30e5\u95a2\u6570\u3067\u3042\u308b SHA-2 \u3092\u8a08\u7b97\u3057\u307e\u3059\uff0e Header file namespace sstd { std :: vector < uint8 > sha224 ( const uchar * in , size_t in_len ); std :: vector < uint8 > sha256 ( const uchar * in , size_t in_len ); std :: vector < uint8 > sha384 ( const uchar * in , size_t in_len ); std :: vector < uint8 > sha512 ( const uchar * in , size_t in_len ); std :: vector < uint8 > sha224 ( const std :: vector < uint8 >& in ); std :: vector < uint8 > sha256 ( const std :: vector < uint8 >& in ); std :: vector < uint8 > sha384 ( const std :: vector < uint8 >& in ); std :: vector < uint8 > sha512 ( const std :: vector < uint8 >& in ); } Usage input #include <sstd/sstd.hpp> std :: string uint8_to_str ( const std :: vector < uint8 >& v ){ std :: string s ; for ( uint i = 0 ; i < v . size (); ++ i ){ s += sstd :: ssprintf ( \"%02x\" , ( int ) v [ i ]); } return s ; } int main (){ sstd :: mkdir ( \"./tmp\" ); sstd :: system ( \"head -c 5m /dev/urandom > ./tmp/rand.txt\" ); // generate 5 MB random file sstd :: system ( \"sha224sum ./tmp/rand.txt\" ); std :: vector < uint8 > vBin = sstd :: readAll_bin ( \"./tmp/rand.txt\" ); // read all as a binary std :: string sha224_str = uint8_to_str ( sstd :: sha224 ( vBin ) ); sstd :: printn ( sha224_str ); sstd :: rm ( \"./tmp\" ); } output 46c01d5690404df623c993c4e0619fb24ab7dbd8538824f7ba62fe25 ./tmp/rand.txt sha224_str = \"46c01d5690404df623c993c4e0619fb24ab7dbd8538824f7ba62fe25\" Implementation Source: sstd/src/hashFnc_of_MD5_SHA1_SHA2/sstd_md5_sha1_sha2_wrapper.cpp Header: sstd/src/hashFnc_of_MD5_SHA1_SHA2/sstd_md5_sha1_sha2_wrapper.hpp Test: test/hashFnc_of_MD5_SHA1_SHA2/sstd_md5_sha1_sha2_wrapper.hpp (Not implemented yet)","title":"SHA-2 (224, 256, 384, 512 bits)"},{"location":"src/hashFunction/sha2/#sha-2-224-256-384-512-bits","text":"","title":"SHA-2 (224, 256, 384, 512 bits)"},{"location":"src/hashFunction/sha2/#abstract","text":"sha224() , sha256() , sha384() and sha512() calculate SHA-2 cryptographic hash function. sha224() , sha256() , sha384() \u304a\u3088\u3073 sha512() \u306f\u6697\u53f7\u5b66\u7684\u30cf\u30c3\u30b7\u30e5\u95a2\u6570\u3067\u3042\u308b SHA-2 \u3092\u8a08\u7b97\u3057\u307e\u3059\uff0e","title":"Abstract"},{"location":"src/hashFunction/sha2/#header-file","text":"namespace sstd { std :: vector < uint8 > sha224 ( const uchar * in , size_t in_len ); std :: vector < uint8 > sha256 ( const uchar * in , size_t in_len ); std :: vector < uint8 > sha384 ( const uchar * in , size_t in_len ); std :: vector < uint8 > sha512 ( const uchar * in , size_t in_len ); std :: vector < uint8 > sha224 ( const std :: vector < uint8 >& in ); std :: vector < uint8 > sha256 ( const std :: vector < uint8 >& in ); std :: vector < uint8 > sha384 ( const std :: vector < uint8 >& in ); std :: vector < uint8 > sha512 ( const std :: vector < uint8 >& in ); }","title":"Header file"},{"location":"src/hashFunction/sha2/#usage","text":"input #include <sstd/sstd.hpp> std :: string uint8_to_str ( const std :: vector < uint8 >& v ){ std :: string s ; for ( uint i = 0 ; i < v . size (); ++ i ){ s += sstd :: ssprintf ( \"%02x\" , ( int ) v [ i ]); } return s ; } int main (){ sstd :: mkdir ( \"./tmp\" ); sstd :: system ( \"head -c 5m /dev/urandom > ./tmp/rand.txt\" ); // generate 5 MB random file sstd :: system ( \"sha224sum ./tmp/rand.txt\" ); std :: vector < uint8 > vBin = sstd :: readAll_bin ( \"./tmp/rand.txt\" ); // read all as a binary std :: string sha224_str = uint8_to_str ( sstd :: sha224 ( vBin ) ); sstd :: printn ( sha224_str ); sstd :: rm ( \"./tmp\" ); } output 46c01d5690404df623c993c4e0619fb24ab7dbd8538824f7ba62fe25 ./tmp/rand.txt sha224_str = \"46c01d5690404df623c993c4e0619fb24ab7dbd8538824f7ba62fe25\"","title":"Usage"},{"location":"src/hashFunction/sha2/#implementation","text":"Source: sstd/src/hashFnc_of_MD5_SHA1_SHA2/sstd_md5_sha1_sha2_wrapper.cpp Header: sstd/src/hashFnc_of_MD5_SHA1_SHA2/sstd_md5_sha1_sha2_wrapper.hpp Test: test/hashFnc_of_MD5_SHA1_SHA2/sstd_md5_sha1_sha2_wrapper.hpp (Not implemented yet)","title":"Implementation"},{"location":"src/matrix/bmat/","text":"bmat (binary-matrix) Abstract bmat is a binary matrix calculation container. bmat \u306f\u30d0\u30a4\u30ca\u30ea\u884c\u5217\u8a08\u7b97\u30b3\u30f3\u30c6\u30ca\u3067\u3059\uff0e Header file namespace sstd { class bmat ; void copy ( class sstd :: bmat & lhs , class sstd :: bmat & rhs ); void move ( class sstd :: bmat & lhs , class sstd :: bmat & rhs ); void eye ( class sstd :: bmat & bMat ); void ones ( class sstd :: bmat & bMat ); void zeros ( class sstd :: bmat & bMat ); class sstd :: bmat eye ( const uint & row , const uint & col ); // \u3053\u306e\u3042\u305f\u308a\uff0c\u623b\u308a\u5024\u3067\u95a2\u6570\u306f\u30aa\u30fc\u30d0\u30fc\u30ed\u30fc\u30c9\u3067\u304d\u306a\u3044\u306e\u3067\uff0c\u4ed6\u306e\u578b\u306b\u3064\u3044\u3066\u3082\u5b9f\u88c5\u3059\u308b\u3068\uff0c\u885d\u7a81\u3059\u308b\u5371\u967a\u304c\u3042\u308b\uff0e(\u66f8\u304d\u76f4\u3057\uff0e class sstd :: bmat ones ( const uint & row , const uint & col ); class sstd :: bmat zeros ( const uint & row , const uint & col ); class sstd :: bmat eye ( const uint & size ); class sstd :: bmat ones ( const uint & size ); class sstd :: bmat zeros ( const uint & size ); class sstd :: bmat LxShiftMat ( uint size , uint xShift ); // square matrix [size x size] class sstd :: bmat RxShiftMat ( uint size , uint xShift ); // square matrix [size x size] class sstd :: bmat Tr ( class sstd :: bmat & rhs ); // lhs = Transpose(rhs) void Tr_myself ( class sstd :: bmat & rhs ); // Transpose(rhs) class sstd :: bmat add ( class sstd :: bmat & lhs , class sstd :: bmat & rhs ); // lhs + rhs (XOR) class sstd :: bmat mul ( class sstd :: bmat & lhs , class sstd :: bmat & rhs ); // lhs * rhs class sstd :: bmat pow ( class sstd :: bmat base , uint64 exponent ); // base^{exponent} void add_myself ( class sstd :: bmat & lhs , class sstd :: bmat & rhs ); // lhs += rhs (XOR) void mul_myself ( class sstd :: bmat & lhs , class sstd :: bmat & rhs ); // lhs *= rhs void pow_myself ( class sstd :: bmat & base , uint64 exponent ); // lhs ^= exponent class sstd :: bmat and_ ( class sstd :: bmat & lhs , class sstd :: bmat & rhs ); // lhs & rhs (AND) class sstd :: bmat or_ ( class sstd :: bmat & lhs , class sstd :: bmat & rhs ); // lhs | rhs (OR) class sstd :: bmat not_ ( class sstd :: bmat & rhs ); // ~rhs (NOT) class sstd :: bmat xor_ ( class sstd :: bmat & lhs , class sstd :: bmat & rhs ); // lhs + rhs (XOR) void and_myself ( class sstd :: bmat & lhs , class sstd :: bmat & rhs ); // lhs & rhs (AND) void or_myself ( class sstd :: bmat & lhs , class sstd :: bmat & rhs ); // lhs | rhs (OR) bool eq ( class sstd :: bmat & lhs , class sstd :: bmat & rhs ); // lhs == rhs bool ne ( class sstd :: bmat & lhs , class sstd :: bmat & rhs ); // lhs != rhs class sstd :: bmat REShift ( class sstd :: bmat & rhs , uint ShiftNum ); // RightExpansionShift // \u884c\u5217\u62e1\u5927\u53f3\u30b7\u30d5\u30c8 class sstd :: bmat DEShift ( class sstd :: bmat & rhs , uint ShiftNum ); // DownExpansionShift // \u884c\u5217\u62e1\u5927\u4e0b\u30b7\u30d5\u30c8 class sstd :: bmat horzcat2 ( class sstd :: bmat & lhs , class sstd :: bmat & rhs ); // lhs << rhs class sstd :: bmat vertcat2 ( class sstd :: bmat & us , class sstd :: bmat & ds ); // us && ds // upside, downside. }; class sstd :: bmat { private : uint rowNum ; // \u884c\u6570 uint colNum ; // \u5217\u6570 sstd :: mat_c < uint64 > binMat8x8 ; // 8x8 \u306e BinMartix \u884c\u5217\u306e\u96c6\u5408 public : bmat (); bmat ( const uint & row , const uint & col ); bmat ( class bmat & rhs ); bmat ( class bmat && rhs ); ~ bmat (){} // inline sstd::mat_c<uint64> bMat8x8(){ return binMat8x8; } // Do not do this to avoid object copy inline const sstd :: mat_c < uint64 >& bMat8x8_R () const { return binMat8x8 ; } inline const uint rows () const ; inline const uint cols () const ; // RW: read and write inline sstd :: mat_c < uint64 >& bMat8x8_RW (); inline uint & rows_RW (); inline uint & cols_RW (); class bmat & operator = ( const class bmat & rhs ); // called by \"lhs = sstd::add(A, B);\". class bmat operator + ( const class bmat & rhs ); // called by \"lhs + rhs;\". // XOR class bmat operator * ( const class bmat & rhs ); // called by \"lhs * rhs;\". // mul class bmat operator ^ ( const uint64 & rhs ); // called by \"lhs ^ rhs;\". // pow (not XOR) class bmat operator & ( const class bmat & rhs ); // called by \"lhs & rhs;\". // AND class bmat operator | ( const class bmat & rhs ); // called by \"lhs | rhs;\". // OR class bmat operator ~ () // called by \"~rhs;\". // NOT class bmat & operator += ( const class bmat & rhs ); // called by \"lhs += rhs;\". class bmat & operator *= ( const class bmat & rhs ); // called by \"lhs *= rhs;\". class bmat & operator ^= ( const uint64 & rhs ); // called by \"lhs ^= rhs;\". class bmat & operator &= ( const class bmat & rhs ); // called by \"lhs &= rhs;\". class bmat & operator |= ( const class bmat & rhs ); // called by \"lhs |= rhs;\". bool operator == ( const class bmat & rhs ); // called by \"sstd::bmat bMatA, bMatB; if(bMatA == bMatB){printf(\"same\\n\");}else{printf(\"different\\n\");}\". bool operator != ( const class bmat & rhs ); // called by \"sstd::bmat bMatA, bMatB; if(bMatA == bMatB){printf(\"same\\n\");}else{printf(\"different\\n\");}\". class bmat operator << ( const class bmat & rhs ); // called by \"sstd::bmat bMatA, bMatB, bMatC; bMatC = bMatA << bMatB;\". // Horizontal connection of matrix. class bmat operator && ( const class bmat & ds ); // called by \"sstd::bmat bMatA, bMatB, bMatC; bMatC = bMatA && bMatB;\". // Vertical connection of matrix. class SwapByOneIndex operator []( const uint & p ); // col-major order // called by \"sstd::bmat bMat; bool buf = bMat[0]; bool bMat[0] = buf;\". class SwapByOneIndex operator []( const int & p ); // col-major order // called by \"sstd::bmat bMat; bool buf = bMat[0]; bool bMat[0] = buf;\". class SwapByTwoIndex operator ()( const uint & p , const uint & q ); // called by \"sstd::bmat bMat; bool buf = bMat(0, 0); bool bMat(0, 0) = buf;\". class SwapByTwoIndex operator ()( const int & p , const uint & q ); // called by \"sstd::bmat bMat; bool buf = bMat(0, 0); bool bMat(0, 0) = buf;\". class SwapByTwoIndex operator ()( const uint & p , const int & q ); // called by \"sstd::bmat bMat; bool buf = bMat(0, 0); bool bMat(0, 0) = buf;\". class SwapByTwoIndex operator ()( const int & p , const int & q ); // called by \"sstd::bmat bMat; bool buf = bMat(0, 0); bool bMat(0, 0) = buf;\". }; Usage input #include <sstd/sstd.hpp> bool isFullPeriod_LRL ( std :: vector < uint64 >& divs , uint N , uint a , uint b , uint c ){ sstd :: bmat I = sstd :: eye ( N , N ); sstd :: bmat La = sstd :: LxShiftMat ( N , a ); sstd :: bmat Rb = sstd :: RxShiftMat ( N , b ); sstd :: bmat Lc = sstd :: LxShiftMat ( N , c ); sstd :: bmat T = ( I + La ) * ( I + Rb ) * ( I + Lc ); // sstd::printn(T); for ( uint i = 0 ; i < divs . size () - 1 ; i ++ ){ sstd :: bmat Tp = T ^ ( divs [ i ]); // XORSHIFT if ( Tp == I ){ return false ; } } sstd :: bmat Tp = T ^ ( divs [ divs . size () - 1 ]); // XORSHIFT if ( Tp == I ){ return true ; } else { return false ; } } void T_LRL ( std :: vector < uint64 >& divs , uint N ){ uint num = 0 ; printf ( \" a, b, c \\n \" ); for ( uint a = 0 ; a < N ; a ++ ){ for ( uint b = 0 ; b < N ; b ++ ){ for ( uint c = 0 ; c < N ; c ++ ){ if ( a < c && isFullPeriod_LRL ( divs , N , a , b , c )){ printf ( \"|%2u, %2u, %2u\" , a , b , c ); num ++ ; if ( num % 9 == 0 ){ printf ( \"| \\n \" ); } } } } } } int main (){ printf ( \"\u25a0 measureTime_start--------------- \\n\\n \" ); time_m timem ; sstd :: measureTime_start ( timem ); // calculate divisors of 2^32-1. // std::vector<uint64> divs32 = sstd::divisor(4294967296-1); // Below line returns the same result of this line, but took a little time to run everytime and takes a little heavy memory (about 2 GByte). // std::vector<uint64> divs32 = {1, 3, 5, 15, 17, 51, 85, 255, 257, 771, 1285, 3855, 4369, 13107, 21845, 65535, 65537, 196611, 327685, 983055, 1114129, 3342387, 5570645, 16711935, 16843009, 50529027, 84215045, 252645135, 286331153, 858993459, 1431655765, 4294967295}; std :: vector < uint64 > divs32 = { 1ull * 5ull * 17ull * 257ull * 65537ull , 3ull * 1ull * 17ull * 257ull * 65537ull , 3ull * 5ull * 1ull * 257ull * 65537ull , 3ull * 5ull * 17ull * 1ull * 65537ull , 3ull * 5ull * 17ull * 257ull * 1ull , 3ull * 5ull * 17ull * 257ull * 65537ull }; printf ( \"\u25a1 calculate LRL 32bits \\n \" ); T_LRL ( divs32 , 32 ); printf ( \" \\n \" ); printf ( \" \\n \u25a0 measureTime_stop---------------- \\n \" ); sstd :: measureTime_stop_print ( timem ); return 0 ; } output \u25a0 measureTime_start--------------- \u25a1 calculate LRL 32bits a, b, c | 1, 3, 10| 1, 5, 16| 1, 5, 19| 1, 9, 29| 1, 11, 6| 1, 11, 16| 1, 19, 3| 1, 21, 20| 1, 27, 27| | 2, 5, 15| 2, 5, 21| 2, 7, 7| 2, 7, 9| 2, 7, 25| 2, 9, 15| 2, 15, 17| 2, 15, 25| 2, 21, 9| | 3, 1, 14| 3, 3, 26| 3, 3, 28| 3, 3, 29| 3, 5, 20| 3, 5, 22| 3, 5, 25| 3, 7, 29| 3, 13, 7| | 3, 23, 25| 3, 25, 24| 3, 27, 11| 4, 3, 17| 4, 3, 27| 4, 5, 15| 5, 3, 21| 5, 7, 22| 5, 9, 7| | 5, 9, 28| 5, 9, 31| 5, 13, 6| 5, 15, 17| 5, 17, 13| 5, 21, 12| 5, 27, 8| 5, 27, 21| 5, 27, 25| | 5, 27, 28| 6, 1, 11| 6, 3, 17| 6, 17, 9| 6, 21, 7| 6, 21, 13| 7, 1, 9| 7, 1, 18| 7, 1, 25| | 7, 13, 25| 7, 17, 21| 7, 25, 12| 7, 25, 20| 8, 7, 23| 8, 9, 23| 9, 5, 14| 9, 5, 25| 9, 11, 19| | 9, 21, 16|10, 9, 21|10, 9, 25|11, 7, 12|11, 7, 16|11, 17, 13|11, 21, 13|12, 9, 23|13, 3, 17| |13, 3, 27|13, 5, 19|13, 17, 15|14, 1, 15|14, 13, 15|15, 1, 29|17, 15, 20|17, 15, 23|17, 15, 26| \u25a0 measureTime_stop---------------- -------------------------------- Execution time: 2. 475 sec -------------------------------- Implementation Source: sstd/src/matrixContainer_binary/bmat.cpp Header: sstd/src/matrixContainer_binary/bmat.hpp Test: test/bmat.hpp (Not implemented yet)","title":"bmat (binary-matrix)"},{"location":"src/matrix/bmat/#bmat-binary-matrix","text":"","title":"bmat (binary-matrix)"},{"location":"src/matrix/bmat/#abstract","text":"bmat is a binary matrix calculation container. bmat \u306f\u30d0\u30a4\u30ca\u30ea\u884c\u5217\u8a08\u7b97\u30b3\u30f3\u30c6\u30ca\u3067\u3059\uff0e","title":"Abstract"},{"location":"src/matrix/bmat/#header-file","text":"namespace sstd { class bmat ; void copy ( class sstd :: bmat & lhs , class sstd :: bmat & rhs ); void move ( class sstd :: bmat & lhs , class sstd :: bmat & rhs ); void eye ( class sstd :: bmat & bMat ); void ones ( class sstd :: bmat & bMat ); void zeros ( class sstd :: bmat & bMat ); class sstd :: bmat eye ( const uint & row , const uint & col ); // \u3053\u306e\u3042\u305f\u308a\uff0c\u623b\u308a\u5024\u3067\u95a2\u6570\u306f\u30aa\u30fc\u30d0\u30fc\u30ed\u30fc\u30c9\u3067\u304d\u306a\u3044\u306e\u3067\uff0c\u4ed6\u306e\u578b\u306b\u3064\u3044\u3066\u3082\u5b9f\u88c5\u3059\u308b\u3068\uff0c\u885d\u7a81\u3059\u308b\u5371\u967a\u304c\u3042\u308b\uff0e(\u66f8\u304d\u76f4\u3057\uff0e class sstd :: bmat ones ( const uint & row , const uint & col ); class sstd :: bmat zeros ( const uint & row , const uint & col ); class sstd :: bmat eye ( const uint & size ); class sstd :: bmat ones ( const uint & size ); class sstd :: bmat zeros ( const uint & size ); class sstd :: bmat LxShiftMat ( uint size , uint xShift ); // square matrix [size x size] class sstd :: bmat RxShiftMat ( uint size , uint xShift ); // square matrix [size x size] class sstd :: bmat Tr ( class sstd :: bmat & rhs ); // lhs = Transpose(rhs) void Tr_myself ( class sstd :: bmat & rhs ); // Transpose(rhs) class sstd :: bmat add ( class sstd :: bmat & lhs , class sstd :: bmat & rhs ); // lhs + rhs (XOR) class sstd :: bmat mul ( class sstd :: bmat & lhs , class sstd :: bmat & rhs ); // lhs * rhs class sstd :: bmat pow ( class sstd :: bmat base , uint64 exponent ); // base^{exponent} void add_myself ( class sstd :: bmat & lhs , class sstd :: bmat & rhs ); // lhs += rhs (XOR) void mul_myself ( class sstd :: bmat & lhs , class sstd :: bmat & rhs ); // lhs *= rhs void pow_myself ( class sstd :: bmat & base , uint64 exponent ); // lhs ^= exponent class sstd :: bmat and_ ( class sstd :: bmat & lhs , class sstd :: bmat & rhs ); // lhs & rhs (AND) class sstd :: bmat or_ ( class sstd :: bmat & lhs , class sstd :: bmat & rhs ); // lhs | rhs (OR) class sstd :: bmat not_ ( class sstd :: bmat & rhs ); // ~rhs (NOT) class sstd :: bmat xor_ ( class sstd :: bmat & lhs , class sstd :: bmat & rhs ); // lhs + rhs (XOR) void and_myself ( class sstd :: bmat & lhs , class sstd :: bmat & rhs ); // lhs & rhs (AND) void or_myself ( class sstd :: bmat & lhs , class sstd :: bmat & rhs ); // lhs | rhs (OR) bool eq ( class sstd :: bmat & lhs , class sstd :: bmat & rhs ); // lhs == rhs bool ne ( class sstd :: bmat & lhs , class sstd :: bmat & rhs ); // lhs != rhs class sstd :: bmat REShift ( class sstd :: bmat & rhs , uint ShiftNum ); // RightExpansionShift // \u884c\u5217\u62e1\u5927\u53f3\u30b7\u30d5\u30c8 class sstd :: bmat DEShift ( class sstd :: bmat & rhs , uint ShiftNum ); // DownExpansionShift // \u884c\u5217\u62e1\u5927\u4e0b\u30b7\u30d5\u30c8 class sstd :: bmat horzcat2 ( class sstd :: bmat & lhs , class sstd :: bmat & rhs ); // lhs << rhs class sstd :: bmat vertcat2 ( class sstd :: bmat & us , class sstd :: bmat & ds ); // us && ds // upside, downside. }; class sstd :: bmat { private : uint rowNum ; // \u884c\u6570 uint colNum ; // \u5217\u6570 sstd :: mat_c < uint64 > binMat8x8 ; // 8x8 \u306e BinMartix \u884c\u5217\u306e\u96c6\u5408 public : bmat (); bmat ( const uint & row , const uint & col ); bmat ( class bmat & rhs ); bmat ( class bmat && rhs ); ~ bmat (){} // inline sstd::mat_c<uint64> bMat8x8(){ return binMat8x8; } // Do not do this to avoid object copy inline const sstd :: mat_c < uint64 >& bMat8x8_R () const { return binMat8x8 ; } inline const uint rows () const ; inline const uint cols () const ; // RW: read and write inline sstd :: mat_c < uint64 >& bMat8x8_RW (); inline uint & rows_RW (); inline uint & cols_RW (); class bmat & operator = ( const class bmat & rhs ); // called by \"lhs = sstd::add(A, B);\". class bmat operator + ( const class bmat & rhs ); // called by \"lhs + rhs;\". // XOR class bmat operator * ( const class bmat & rhs ); // called by \"lhs * rhs;\". // mul class bmat operator ^ ( const uint64 & rhs ); // called by \"lhs ^ rhs;\". // pow (not XOR) class bmat operator & ( const class bmat & rhs ); // called by \"lhs & rhs;\". // AND class bmat operator | ( const class bmat & rhs ); // called by \"lhs | rhs;\". // OR class bmat operator ~ () // called by \"~rhs;\". // NOT class bmat & operator += ( const class bmat & rhs ); // called by \"lhs += rhs;\". class bmat & operator *= ( const class bmat & rhs ); // called by \"lhs *= rhs;\". class bmat & operator ^= ( const uint64 & rhs ); // called by \"lhs ^= rhs;\". class bmat & operator &= ( const class bmat & rhs ); // called by \"lhs &= rhs;\". class bmat & operator |= ( const class bmat & rhs ); // called by \"lhs |= rhs;\". bool operator == ( const class bmat & rhs ); // called by \"sstd::bmat bMatA, bMatB; if(bMatA == bMatB){printf(\"same\\n\");}else{printf(\"different\\n\");}\". bool operator != ( const class bmat & rhs ); // called by \"sstd::bmat bMatA, bMatB; if(bMatA == bMatB){printf(\"same\\n\");}else{printf(\"different\\n\");}\". class bmat operator << ( const class bmat & rhs ); // called by \"sstd::bmat bMatA, bMatB, bMatC; bMatC = bMatA << bMatB;\". // Horizontal connection of matrix. class bmat operator && ( const class bmat & ds ); // called by \"sstd::bmat bMatA, bMatB, bMatC; bMatC = bMatA && bMatB;\". // Vertical connection of matrix. class SwapByOneIndex operator []( const uint & p ); // col-major order // called by \"sstd::bmat bMat; bool buf = bMat[0]; bool bMat[0] = buf;\". class SwapByOneIndex operator []( const int & p ); // col-major order // called by \"sstd::bmat bMat; bool buf = bMat[0]; bool bMat[0] = buf;\". class SwapByTwoIndex operator ()( const uint & p , const uint & q ); // called by \"sstd::bmat bMat; bool buf = bMat(0, 0); bool bMat(0, 0) = buf;\". class SwapByTwoIndex operator ()( const int & p , const uint & q ); // called by \"sstd::bmat bMat; bool buf = bMat(0, 0); bool bMat(0, 0) = buf;\". class SwapByTwoIndex operator ()( const uint & p , const int & q ); // called by \"sstd::bmat bMat; bool buf = bMat(0, 0); bool bMat(0, 0) = buf;\". class SwapByTwoIndex operator ()( const int & p , const int & q ); // called by \"sstd::bmat bMat; bool buf = bMat(0, 0); bool bMat(0, 0) = buf;\". };","title":"Header file"},{"location":"src/matrix/bmat/#usage","text":"input #include <sstd/sstd.hpp> bool isFullPeriod_LRL ( std :: vector < uint64 >& divs , uint N , uint a , uint b , uint c ){ sstd :: bmat I = sstd :: eye ( N , N ); sstd :: bmat La = sstd :: LxShiftMat ( N , a ); sstd :: bmat Rb = sstd :: RxShiftMat ( N , b ); sstd :: bmat Lc = sstd :: LxShiftMat ( N , c ); sstd :: bmat T = ( I + La ) * ( I + Rb ) * ( I + Lc ); // sstd::printn(T); for ( uint i = 0 ; i < divs . size () - 1 ; i ++ ){ sstd :: bmat Tp = T ^ ( divs [ i ]); // XORSHIFT if ( Tp == I ){ return false ; } } sstd :: bmat Tp = T ^ ( divs [ divs . size () - 1 ]); // XORSHIFT if ( Tp == I ){ return true ; } else { return false ; } } void T_LRL ( std :: vector < uint64 >& divs , uint N ){ uint num = 0 ; printf ( \" a, b, c \\n \" ); for ( uint a = 0 ; a < N ; a ++ ){ for ( uint b = 0 ; b < N ; b ++ ){ for ( uint c = 0 ; c < N ; c ++ ){ if ( a < c && isFullPeriod_LRL ( divs , N , a , b , c )){ printf ( \"|%2u, %2u, %2u\" , a , b , c ); num ++ ; if ( num % 9 == 0 ){ printf ( \"| \\n \" ); } } } } } } int main (){ printf ( \"\u25a0 measureTime_start--------------- \\n\\n \" ); time_m timem ; sstd :: measureTime_start ( timem ); // calculate divisors of 2^32-1. // std::vector<uint64> divs32 = sstd::divisor(4294967296-1); // Below line returns the same result of this line, but took a little time to run everytime and takes a little heavy memory (about 2 GByte). // std::vector<uint64> divs32 = {1, 3, 5, 15, 17, 51, 85, 255, 257, 771, 1285, 3855, 4369, 13107, 21845, 65535, 65537, 196611, 327685, 983055, 1114129, 3342387, 5570645, 16711935, 16843009, 50529027, 84215045, 252645135, 286331153, 858993459, 1431655765, 4294967295}; std :: vector < uint64 > divs32 = { 1ull * 5ull * 17ull * 257ull * 65537ull , 3ull * 1ull * 17ull * 257ull * 65537ull , 3ull * 5ull * 1ull * 257ull * 65537ull , 3ull * 5ull * 17ull * 1ull * 65537ull , 3ull * 5ull * 17ull * 257ull * 1ull , 3ull * 5ull * 17ull * 257ull * 65537ull }; printf ( \"\u25a1 calculate LRL 32bits \\n \" ); T_LRL ( divs32 , 32 ); printf ( \" \\n \" ); printf ( \" \\n \u25a0 measureTime_stop---------------- \\n \" ); sstd :: measureTime_stop_print ( timem ); return 0 ; } output \u25a0 measureTime_start--------------- \u25a1 calculate LRL 32bits a, b, c | 1, 3, 10| 1, 5, 16| 1, 5, 19| 1, 9, 29| 1, 11, 6| 1, 11, 16| 1, 19, 3| 1, 21, 20| 1, 27, 27| | 2, 5, 15| 2, 5, 21| 2, 7, 7| 2, 7, 9| 2, 7, 25| 2, 9, 15| 2, 15, 17| 2, 15, 25| 2, 21, 9| | 3, 1, 14| 3, 3, 26| 3, 3, 28| 3, 3, 29| 3, 5, 20| 3, 5, 22| 3, 5, 25| 3, 7, 29| 3, 13, 7| | 3, 23, 25| 3, 25, 24| 3, 27, 11| 4, 3, 17| 4, 3, 27| 4, 5, 15| 5, 3, 21| 5, 7, 22| 5, 9, 7| | 5, 9, 28| 5, 9, 31| 5, 13, 6| 5, 15, 17| 5, 17, 13| 5, 21, 12| 5, 27, 8| 5, 27, 21| 5, 27, 25| | 5, 27, 28| 6, 1, 11| 6, 3, 17| 6, 17, 9| 6, 21, 7| 6, 21, 13| 7, 1, 9| 7, 1, 18| 7, 1, 25| | 7, 13, 25| 7, 17, 21| 7, 25, 12| 7, 25, 20| 8, 7, 23| 8, 9, 23| 9, 5, 14| 9, 5, 25| 9, 11, 19| | 9, 21, 16|10, 9, 21|10, 9, 25|11, 7, 12|11, 7, 16|11, 17, 13|11, 21, 13|12, 9, 23|13, 3, 17| |13, 3, 27|13, 5, 19|13, 17, 15|14, 1, 15|14, 13, 15|15, 1, 29|17, 15, 20|17, 15, 23|17, 15, 26| \u25a0 measureTime_stop---------------- -------------------------------- Execution time: 2. 475 sec --------------------------------","title":"Usage"},{"location":"src/matrix/bmat/#implementation","text":"Source: sstd/src/matrixContainer_binary/bmat.cpp Header: sstd/src/matrixContainer_binary/bmat.hpp Test: test/bmat.hpp (Not implemented yet)","title":"Implementation"},{"location":"src/matrix/mat_colMajor/","text":"mat_c (Col-major) Abstract mat_c is a column-major matrix container. mat_c \u306f\u5217\u512a\u5148\u306e\u884c\u5217\u30b3\u30f3\u30c6\u30ca\u3067\u3059. Header file namespace sstd { template < typename T > class mat_c ; template < typename T > void copy ( sstd :: mat_c < T >& lhs , const sstd :: mat_c < T >& rhs ); template < typename T > void move ( sstd :: mat_c < T >& lhs , sstd :: mat_c < T >& rhs ); template < typename T > void swap ( sstd :: mat_c < T >& lhs , sstd :: mat_c < T >& rhs ); template < typename T > void eye ( sstd :: mat_c < T >& rhs ); template < typename T > void ones ( sstd :: mat_c < T >& rhs ); template < typename T > void zeros ( sstd :: mat_c < T >& Mat ); template < typename T > sstd :: mat_c < T > Tr ( const sstd :: mat_c < T >& rhs ); // lhs = Transpose(rhs) template < typename T > void Tr_myself ( sstd :: mat_c < T >& rhs ); // Transpose(rhs) } template < typename T > class sstd :: mat_c { private : T * _pMatT ; uint _rows ; // row size uint _cols ; // column size uint _size ; // number of element public : inline mat_c (); inline mat_c ( const std :: initializer_list < std :: initializer_list < T >>& rhs ); // called by \"sstd::mat_c<T> mat = {{1, 2, 3}, {4, 5, 6}, {7, 8, 9}};\". inline mat_c ( const class mat_c & rhs ); // called by \"sstd::mat_c<T> buf1(N, N); sstd::mat_c<T> buf2(buf1);\" inline mat_c ( class mat_c && rhs ); // called by \"return std::move(rhs);\" or \"std::swap(buf1, buf2)\". inline mat_c ( const uint & rowSize , const uint & colSize ); inline ~ mat_c (); // Read only: R inline const uint rows () const ; inline const uint cols () const ; inline const uint size () const ; // Read and Write: RW inline T *& pMatT_RW (); inline uint & rows_RW (); inline uint & cols_RW (); inline uint & size_RW (); class mat_c & operator = ( const class mat_c & rhs ); // called by \"lhs = sstd::mat_c<T>(3, 3);\". inline T & operator []( const uint i ); inline T & operator []( const int i ); inline const T & operator []( const uint i ) const ; inline const T & operator []( const int i ) const ; inline T & operator ()( const uint p , const uint q ); inline T & operator ()( const int p , const uint q ); inline T & operator ()( const uint p , const int q ); inline T & operator ()( const int p , const int q ); inline const T & operator ()( const uint p , const uint q ) const ; inline const T & operator ()( const int p , const uint q ) const ; inline const T & operator ()( const uint p , const int q ) const ; inline const T & operator ()( const int p , const int q ) const ; // for element operations (elements multiplication) inline sstd :: mat_c_elements < T > operator ()(); inline sstd :: mat_c_elements < T > vec (); }; Usage Init input #include <sstd/sstd.hpp> int main (){ sstd :: mat_c < double > m = {{ 1 , 2 }, { 3 , 4 }}; sstd :: mat_c < double > m_eye ( 2 , 2 ); sstd :: eye ( m_eye ); sstd :: mat_c < double > m_ones ( 2 , 2 ); sstd :: ones ( m_ones ); sstd :: mat_c < double > m_zeros ( 2 , 2 ); sstd :: zeros ( m_zeros ); sstd :: printn ( m ); printf ( \" \\n \" ); sstd :: printn ( m_eye ); printf ( \" \\n \" ); sstd :: printn ( m_ones ); printf ( \" \\n \" ); sstd :: printn ( m_zeros ); } output m = 1.000000 2.000000 3.000000 4.000000 m_eye = 1.000000 0.000000 0.000000 1.000000 m_ones = 1.000000 1.000000 1.000000 1.000000 m_zeros = 0.000000 0.000000 0.000000 0.000000 Access to elements As a matrix input #include <sstd/sstd.hpp> int main (){ sstd :: mat_c < double > m ( 2 , 2 ); uint i = 0 ; for ( uint c = 0 ; c < m . cols (); ++ c ){ for ( uint r = 0 ; r < m . rows (); ++ r ){ m ( r , c ) = i ; ++ i ; } } sstd :: printn ( m ); } output m = 0.000000 2.000000 1.000000 3.000000 As a vector input #include <sstd/sstd.hpp> int main (){ sstd :: mat_c < double > m ( 2 , 2 ); for ( uint i = 0 ; i < m . size (); ++ i ){ m [ i ] = i ; } sstd :: printn ( m ); } output m = 0.000000 2.000000 1.000000 3.000000 Tr (Transpose) input #include <sstd/sstd.hpp> int main (){ sstd :: mat_c < double > m1 = {{ 1 , 2 }, { 3 , 4 }}; sstd :: printn ( m1 ); sstd :: printn ( sstd :: Tr ( m1 ) ); printf ( \" \\n \" ); sstd :: mat_c < double > m2 = {{ 1 , 2 }, { 3 , 4 }}; sstd :: printn ( m2 ); sstd :: Tr_myself ( m2 ); sstd :: printn ( m2 ); } output m1 = 1.000000 2.000000 3.000000 4.000000 sstd::Tr( m1 ) = 1.000000 3.000000 2.000000 4.000000 m2 = 1.000000 2.000000 3.000000 4.000000 m2 = 1.000000 3.000000 2.000000 4.000000 Operator matrix \u00d7 scalar input #include <sstd/sstd.hpp> int main (){ sstd :: mat_c < double > m ( 2 , 2 ); for ( uint i = 0 ; i < m . size (); ++ i ){ m [ i ] = i ; } sstd :: printn ( m ); printf ( \" \\n \" ); sstd :: printn ( m * 2 ); } output m = 0.000000 2.000000 1.000000 3.000000 m * 2 = 0.000000 4.000000 2.000000 6.000000 matrix \u00d7 matrix input #include <sstd/sstd.hpp> int main (){ sstd :: mat_c < double > m1 ( 2 , 2 ); for ( uint i = 0 ; i < m1 . size (); ++ i ){ m1 [ i ] = i ; } sstd :: mat_c < double > m2 ( 2 , 2 ); for ( uint i = 0 ; i < m2 . size (); ++ i ){ m2 [ i ] = i + 1 ; } sstd :: printn ( m1 ); printf ( \" \\n \" ); sstd :: printn ( m2 ); printf ( \" \\n \" ); sstd :: printn ( m1 * m2 ); } output m1 = 0.000000 2.000000 1.000000 3.000000 m2 = 1.000000 3.000000 2.000000 4.000000 m1 * m2 = 4.000000 8.000000 7.000000 15.000000 matrix (as a vector) \u00d7 matrix (as a vector) input #include <sstd/sstd.hpp> int main (){ sstd :: mat_c < double > m1 ( 2 , 2 ); for ( uint i = 0 ; i < m1 . size (); ++ i ){ m1 [ i ] = i ; } sstd :: mat_c < double > m2 ( 2 , 2 ); for ( uint i = 0 ; i < m2 . size (); ++ i ){ m2 [ i ] = i + 1 ; } sstd :: printn ( m1 ); printf ( \" \\n \" ); sstd :: printn ( m2 ); printf ( \" \\n \" ); sstd :: printn ( m1 () * m2 () ); } output m1 = 0.000000 2.000000 1.000000 3.000000 m2 = 1.000000 3.000000 2.000000 4.000000 m1() * m2() = 0.000000 6.000000 2.000000 12.000000 Implementation Source: sstd/src/matrixContainer_rowMajor/mat_c.cpp Header: sstd/src/matrixContainer_rowMajor/mat_c.hpp Test: test/mat_c.hpp (Not implemented yet)","title":"mat_c (Col-major)"},{"location":"src/matrix/mat_colMajor/#mat_c-col-major","text":"","title":"mat_c (Col-major)"},{"location":"src/matrix/mat_colMajor/#abstract","text":"mat_c is a column-major matrix container. mat_c \u306f\u5217\u512a\u5148\u306e\u884c\u5217\u30b3\u30f3\u30c6\u30ca\u3067\u3059.","title":"Abstract"},{"location":"src/matrix/mat_colMajor/#header-file","text":"namespace sstd { template < typename T > class mat_c ; template < typename T > void copy ( sstd :: mat_c < T >& lhs , const sstd :: mat_c < T >& rhs ); template < typename T > void move ( sstd :: mat_c < T >& lhs , sstd :: mat_c < T >& rhs ); template < typename T > void swap ( sstd :: mat_c < T >& lhs , sstd :: mat_c < T >& rhs ); template < typename T > void eye ( sstd :: mat_c < T >& rhs ); template < typename T > void ones ( sstd :: mat_c < T >& rhs ); template < typename T > void zeros ( sstd :: mat_c < T >& Mat ); template < typename T > sstd :: mat_c < T > Tr ( const sstd :: mat_c < T >& rhs ); // lhs = Transpose(rhs) template < typename T > void Tr_myself ( sstd :: mat_c < T >& rhs ); // Transpose(rhs) } template < typename T > class sstd :: mat_c { private : T * _pMatT ; uint _rows ; // row size uint _cols ; // column size uint _size ; // number of element public : inline mat_c (); inline mat_c ( const std :: initializer_list < std :: initializer_list < T >>& rhs ); // called by \"sstd::mat_c<T> mat = {{1, 2, 3}, {4, 5, 6}, {7, 8, 9}};\". inline mat_c ( const class mat_c & rhs ); // called by \"sstd::mat_c<T> buf1(N, N); sstd::mat_c<T> buf2(buf1);\" inline mat_c ( class mat_c && rhs ); // called by \"return std::move(rhs);\" or \"std::swap(buf1, buf2)\". inline mat_c ( const uint & rowSize , const uint & colSize ); inline ~ mat_c (); // Read only: R inline const uint rows () const ; inline const uint cols () const ; inline const uint size () const ; // Read and Write: RW inline T *& pMatT_RW (); inline uint & rows_RW (); inline uint & cols_RW (); inline uint & size_RW (); class mat_c & operator = ( const class mat_c & rhs ); // called by \"lhs = sstd::mat_c<T>(3, 3);\". inline T & operator []( const uint i ); inline T & operator []( const int i ); inline const T & operator []( const uint i ) const ; inline const T & operator []( const int i ) const ; inline T & operator ()( const uint p , const uint q ); inline T & operator ()( const int p , const uint q ); inline T & operator ()( const uint p , const int q ); inline T & operator ()( const int p , const int q ); inline const T & operator ()( const uint p , const uint q ) const ; inline const T & operator ()( const int p , const uint q ) const ; inline const T & operator ()( const uint p , const int q ) const ; inline const T & operator ()( const int p , const int q ) const ; // for element operations (elements multiplication) inline sstd :: mat_c_elements < T > operator ()(); inline sstd :: mat_c_elements < T > vec (); };","title":"Header file"},{"location":"src/matrix/mat_colMajor/#usage","text":"","title":"Usage"},{"location":"src/matrix/mat_colMajor/#init","text":"input #include <sstd/sstd.hpp> int main (){ sstd :: mat_c < double > m = {{ 1 , 2 }, { 3 , 4 }}; sstd :: mat_c < double > m_eye ( 2 , 2 ); sstd :: eye ( m_eye ); sstd :: mat_c < double > m_ones ( 2 , 2 ); sstd :: ones ( m_ones ); sstd :: mat_c < double > m_zeros ( 2 , 2 ); sstd :: zeros ( m_zeros ); sstd :: printn ( m ); printf ( \" \\n \" ); sstd :: printn ( m_eye ); printf ( \" \\n \" ); sstd :: printn ( m_ones ); printf ( \" \\n \" ); sstd :: printn ( m_zeros ); } output m = 1.000000 2.000000 3.000000 4.000000 m_eye = 1.000000 0.000000 0.000000 1.000000 m_ones = 1.000000 1.000000 1.000000 1.000000 m_zeros = 0.000000 0.000000 0.000000 0.000000","title":"Init"},{"location":"src/matrix/mat_colMajor/#access-to-elements","text":"","title":"Access to elements"},{"location":"src/matrix/mat_colMajor/#as-a-matrix","text":"input #include <sstd/sstd.hpp> int main (){ sstd :: mat_c < double > m ( 2 , 2 ); uint i = 0 ; for ( uint c = 0 ; c < m . cols (); ++ c ){ for ( uint r = 0 ; r < m . rows (); ++ r ){ m ( r , c ) = i ; ++ i ; } } sstd :: printn ( m ); } output m = 0.000000 2.000000 1.000000 3.000000","title":"As a matrix"},{"location":"src/matrix/mat_colMajor/#as-a-vector","text":"input #include <sstd/sstd.hpp> int main (){ sstd :: mat_c < double > m ( 2 , 2 ); for ( uint i = 0 ; i < m . size (); ++ i ){ m [ i ] = i ; } sstd :: printn ( m ); } output m = 0.000000 2.000000 1.000000 3.000000","title":"As a vector"},{"location":"src/matrix/mat_colMajor/#tr-transpose","text":"input #include <sstd/sstd.hpp> int main (){ sstd :: mat_c < double > m1 = {{ 1 , 2 }, { 3 , 4 }}; sstd :: printn ( m1 ); sstd :: printn ( sstd :: Tr ( m1 ) ); printf ( \" \\n \" ); sstd :: mat_c < double > m2 = {{ 1 , 2 }, { 3 , 4 }}; sstd :: printn ( m2 ); sstd :: Tr_myself ( m2 ); sstd :: printn ( m2 ); } output m1 = 1.000000 2.000000 3.000000 4.000000 sstd::Tr( m1 ) = 1.000000 3.000000 2.000000 4.000000 m2 = 1.000000 2.000000 3.000000 4.000000 m2 = 1.000000 3.000000 2.000000 4.000000","title":"Tr (Transpose)"},{"location":"src/matrix/mat_colMajor/#operator","text":"","title":"Operator"},{"location":"src/matrix/mat_colMajor/#matrix-scalar","text":"input #include <sstd/sstd.hpp> int main (){ sstd :: mat_c < double > m ( 2 , 2 ); for ( uint i = 0 ; i < m . size (); ++ i ){ m [ i ] = i ; } sstd :: printn ( m ); printf ( \" \\n \" ); sstd :: printn ( m * 2 ); } output m = 0.000000 2.000000 1.000000 3.000000 m * 2 = 0.000000 4.000000 2.000000 6.000000","title":"matrix \u00d7 scalar"},{"location":"src/matrix/mat_colMajor/#matrix-matrix","text":"input #include <sstd/sstd.hpp> int main (){ sstd :: mat_c < double > m1 ( 2 , 2 ); for ( uint i = 0 ; i < m1 . size (); ++ i ){ m1 [ i ] = i ; } sstd :: mat_c < double > m2 ( 2 , 2 ); for ( uint i = 0 ; i < m2 . size (); ++ i ){ m2 [ i ] = i + 1 ; } sstd :: printn ( m1 ); printf ( \" \\n \" ); sstd :: printn ( m2 ); printf ( \" \\n \" ); sstd :: printn ( m1 * m2 ); } output m1 = 0.000000 2.000000 1.000000 3.000000 m2 = 1.000000 3.000000 2.000000 4.000000 m1 * m2 = 4.000000 8.000000 7.000000 15.000000","title":"matrix \u00d7 matrix"},{"location":"src/matrix/mat_colMajor/#matrix-as-a-vector-matrix-as-a-vector","text":"input #include <sstd/sstd.hpp> int main (){ sstd :: mat_c < double > m1 ( 2 , 2 ); for ( uint i = 0 ; i < m1 . size (); ++ i ){ m1 [ i ] = i ; } sstd :: mat_c < double > m2 ( 2 , 2 ); for ( uint i = 0 ; i < m2 . size (); ++ i ){ m2 [ i ] = i + 1 ; } sstd :: printn ( m1 ); printf ( \" \\n \" ); sstd :: printn ( m2 ); printf ( \" \\n \" ); sstd :: printn ( m1 () * m2 () ); } output m1 = 0.000000 2.000000 1.000000 3.000000 m2 = 1.000000 3.000000 2.000000 4.000000 m1() * m2() = 0.000000 6.000000 2.000000 12.000000","title":"matrix (as a vector) \u00d7 matrix (as a vector)"},{"location":"src/matrix/mat_colMajor/#implementation","text":"Source: sstd/src/matrixContainer_rowMajor/mat_c.cpp Header: sstd/src/matrixContainer_rowMajor/mat_c.hpp Test: test/mat_c.hpp (Not implemented yet)","title":"Implementation"},{"location":"src/matrix/mat_rowMajor/","text":"mat_r (Row-major) Abstract mat_r is a row-major matrix container. mat_r \u306f\u884c\u512a\u5148\u306e\u884c\u5217\u30b3\u30f3\u30c6\u30ca\u3067\u3059. Header file namespace sstd { template < typename T > class mat_r ; template < typename T > void copy ( sstd :: mat_r < T >& lhs , const sstd :: mat_r < T >& rhs ); template < typename T > void move ( sstd :: mat_r < T >& lhs , sstd :: mat_r < T >& rhs ); template < typename T > void swap ( sstd :: mat_r < T >& lhs , sstd :: mat_r < T >& rhs ); template < typename T > void eye ( sstd :: mat_r < T >& rhs ); template < typename T > void ones ( sstd :: mat_r < T >& rhs ); template < typename T > void zeros ( sstd :: mat_r < T >& Mat ); template < typename T > sstd :: mat_r < T > Tr ( const sstd :: mat_r < T >& rhs ); // lhs = Transpose(rhs) template < typename T > void Tr_myself ( sstd :: mat_r < T >& rhs ); // Transpose(rhs) } template < typename T > class sstd :: mat_r { private : T * _pMatT ; uint _rows ; // row size uint _cols ; // column size uint _size ; // number of element public : inline mat_r (); inline mat_r ( const std :: initializer_list < std :: initializer_list < T >>& rhs ); // called by \"sstd::mat_r<T> mat = {{1, 2, 3}, {4, 5, 6}, {7, 8, 9}};\". inline mat_r ( const class mat_r & rhs ); // called by \"sstd::mat_r<T> buf1(N, N); sstd::mat_r<T> buf2(buf1);\" inline mat_r ( class mat_r && rhs ); // called by \"return std::move(rhs);\" or \"std::swap(buf1, buf2)\". inline mat_r ( const uint & rowSize , const uint & colSize ); inline ~ mat_r (); // Read only: R inline const uint rows () const ; inline const uint cols () const ; inline const uint size () const ; // Read and Write: RW inline T *& pMatT_RW (); inline uint & rows_RW (); inline uint & cols_RW (); inline uint & size_RW (); class mat_r & operator = ( const class mat_r & rhs ); // called by \"lhs = sstd::mat_r<T>(3, 3);\". inline T & operator []( const uint i ); inline T & operator []( const int i ); inline const T & operator []( const uint i ) const ; inline const T & operator []( const int i ) const ; inline T & operator ()( const uint p , const uint q ); inline T & operator ()( const int p , const uint q ); inline T & operator ()( const uint p , const int q ); inline T & operator ()( const int p , const int q ); inline const T & operator ()( const uint p , const uint q ) const ; inline const T & operator ()( const int p , const uint q ) const ; inline const T & operator ()( const uint p , const int q ) const ; inline const T & operator ()( const int p , const int q ) const ; // for element operations (elements multiplication) inline sstd :: mat_r_elements < T > operator ()(); inline sstd :: mat_r_elements < T > vec (); }; Usage Init input #include <sstd/sstd.hpp> int main (){ sstd :: mat_r < double > m = {{ 1 , 2 }, { 3 , 4 }}; sstd :: mat_r < double > m_eye ( 2 , 2 ); sstd :: eye ( m_eye ); sstd :: mat_r < double > m_ones ( 2 , 2 ); sstd :: ones ( m_ones ); sstd :: mat_r < double > m_zeros ( 2 , 2 ); sstd :: zeros ( m_zeros ); sstd :: printn ( m ); printf ( \" \\n \" ); sstd :: printn ( m_eye ); printf ( \" \\n \" ); sstd :: printn ( m_ones ); printf ( \" \\n \" ); sstd :: printn ( m_zeros ); } output m = 1.000000 2.000000 3.000000 4.000000 m_eye = 1.000000 0.000000 0.000000 1.000000 m_ones = 1.000000 1.000000 1.000000 1.000000 m_zeros = 0.000000 0.000000 0.000000 0.000000 Access to elements As a matrix input #include <sstd/sstd.hpp> int main (){ sstd :: mat_r < double > m ( 2 , 2 ); uint i = 0 ; for ( uint r = 0 ; r < m . rows (); ++ r ){ for ( uint c = 0 ; c < m . cols (); ++ c ){ m ( r , c ) = i ; ++ i ; } } sstd :: printn ( m ); } output m = 0.000000 1.000000 2.000000 3.000000 As a vector input #include <sstd/sstd.hpp> int main (){ sstd :: mat_r < double > m ( 2 , 2 ); for ( uint i = 0 ; i < m . size (); ++ i ){ m [ i ] = i ; } sstd :: printn ( m ); } output m = 0.000000 1.000000 2.000000 3.000000 Tr (Transpose) input #include <sstd/sstd.hpp> int main (){ sstd :: mat_r < double > m1 = {{ 1 , 2 }, { 3 , 4 }}; sstd :: printn ( m1 ); sstd :: printn ( sstd :: Tr ( m1 ) ); printf ( \" \\n \" ); sstd :: mat_r < double > m2 = {{ 1 , 2 }, { 3 , 4 }}; sstd :: printn ( m2 ); sstd :: Tr_myself ( m2 ); sstd :: printn ( m2 ); } output m1 = 1.000000 2.000000 3.000000 4.000000 sstd::Tr( m1 ) = 1.000000 3.000000 2.000000 4.000000 m2 = 1.000000 2.000000 3.000000 4.000000 m2 = 1.000000 3.000000 2.000000 4.000000 Operator matrix \u00d7 scalar input #include <sstd/sstd.hpp> int main (){ sstd :: mat_r < double > m ( 2 , 2 ); for ( uint i = 0 ; i < m . size (); ++ i ){ m [ i ] = i ; } sstd :: printn ( m ); printf ( \" \\n \" ); sstd :: printn ( m * 2 ); } output m = 0.000000 1.000000 2.000000 3.000000 m * 2 = 0.000000 2.000000 4.000000 6.000000 matrix \u00d7 matrix input #include <sstd/sstd.hpp> int main (){ sstd :: mat_r < double > m1 ( 2 , 2 ); for ( uint i = 0 ; i < m1 . size (); ++ i ){ m1 [ i ] = i ; } sstd :: mat_r < double > m2 ( 2 , 2 ); for ( uint i = 0 ; i < m2 . size (); ++ i ){ m2 [ i ] = i + 1 ; } sstd :: printn ( m1 ); printf ( \" \\n \" ); sstd :: printn ( m2 ); printf ( \" \\n \" ); sstd :: printn ( m1 * m2 ); } output m1 = 0.000000 1.000000 2.000000 3.000000 m2 = 1.000000 2.000000 3.000000 4.000000 m1 * m2 = 3.000000 4.000000 11.000000 16.000000 matrix (as a vector) \u00d7 matrix (as a vector) input #include <sstd/sstd.hpp> int main (){ sstd :: mat_r < double > m1 ( 2 , 2 ); for ( uint i = 0 ; i < m1 . size (); ++ i ){ m1 [ i ] = i ; } sstd :: mat_r < double > m2 ( 2 , 2 ); for ( uint i = 0 ; i < m2 . size (); ++ i ){ m2 [ i ] = i + 1 ; } sstd :: printn ( m1 ); printf ( \" \\n \" ); sstd :: printn ( m2 ); printf ( \" \\n \" ); sstd :: printn ( m1 () * m2 () ); } output m1 = 0.000000 1.000000 2.000000 3.000000 m2 = 1.000000 2.000000 3.000000 4.000000 m1() * m2() = 0.000000 2.000000 6.000000 12.000000 Implementation Source: sstd/src/matrixContainer_rowMajor/mat_r.cpp Header: sstd/src/matrixContainer_rowMajor/mat_r.hpp Test: test/mat_r.hpp (Not implemented yet)","title":"mat_r (Row-major)"},{"location":"src/matrix/mat_rowMajor/#mat_r-row-major","text":"","title":"mat_r (Row-major)"},{"location":"src/matrix/mat_rowMajor/#abstract","text":"mat_r is a row-major matrix container. mat_r \u306f\u884c\u512a\u5148\u306e\u884c\u5217\u30b3\u30f3\u30c6\u30ca\u3067\u3059.","title":"Abstract"},{"location":"src/matrix/mat_rowMajor/#header-file","text":"namespace sstd { template < typename T > class mat_r ; template < typename T > void copy ( sstd :: mat_r < T >& lhs , const sstd :: mat_r < T >& rhs ); template < typename T > void move ( sstd :: mat_r < T >& lhs , sstd :: mat_r < T >& rhs ); template < typename T > void swap ( sstd :: mat_r < T >& lhs , sstd :: mat_r < T >& rhs ); template < typename T > void eye ( sstd :: mat_r < T >& rhs ); template < typename T > void ones ( sstd :: mat_r < T >& rhs ); template < typename T > void zeros ( sstd :: mat_r < T >& Mat ); template < typename T > sstd :: mat_r < T > Tr ( const sstd :: mat_r < T >& rhs ); // lhs = Transpose(rhs) template < typename T > void Tr_myself ( sstd :: mat_r < T >& rhs ); // Transpose(rhs) } template < typename T > class sstd :: mat_r { private : T * _pMatT ; uint _rows ; // row size uint _cols ; // column size uint _size ; // number of element public : inline mat_r (); inline mat_r ( const std :: initializer_list < std :: initializer_list < T >>& rhs ); // called by \"sstd::mat_r<T> mat = {{1, 2, 3}, {4, 5, 6}, {7, 8, 9}};\". inline mat_r ( const class mat_r & rhs ); // called by \"sstd::mat_r<T> buf1(N, N); sstd::mat_r<T> buf2(buf1);\" inline mat_r ( class mat_r && rhs ); // called by \"return std::move(rhs);\" or \"std::swap(buf1, buf2)\". inline mat_r ( const uint & rowSize , const uint & colSize ); inline ~ mat_r (); // Read only: R inline const uint rows () const ; inline const uint cols () const ; inline const uint size () const ; // Read and Write: RW inline T *& pMatT_RW (); inline uint & rows_RW (); inline uint & cols_RW (); inline uint & size_RW (); class mat_r & operator = ( const class mat_r & rhs ); // called by \"lhs = sstd::mat_r<T>(3, 3);\". inline T & operator []( const uint i ); inline T & operator []( const int i ); inline const T & operator []( const uint i ) const ; inline const T & operator []( const int i ) const ; inline T & operator ()( const uint p , const uint q ); inline T & operator ()( const int p , const uint q ); inline T & operator ()( const uint p , const int q ); inline T & operator ()( const int p , const int q ); inline const T & operator ()( const uint p , const uint q ) const ; inline const T & operator ()( const int p , const uint q ) const ; inline const T & operator ()( const uint p , const int q ) const ; inline const T & operator ()( const int p , const int q ) const ; // for element operations (elements multiplication) inline sstd :: mat_r_elements < T > operator ()(); inline sstd :: mat_r_elements < T > vec (); };","title":"Header file"},{"location":"src/matrix/mat_rowMajor/#usage","text":"","title":"Usage"},{"location":"src/matrix/mat_rowMajor/#init","text":"input #include <sstd/sstd.hpp> int main (){ sstd :: mat_r < double > m = {{ 1 , 2 }, { 3 , 4 }}; sstd :: mat_r < double > m_eye ( 2 , 2 ); sstd :: eye ( m_eye ); sstd :: mat_r < double > m_ones ( 2 , 2 ); sstd :: ones ( m_ones ); sstd :: mat_r < double > m_zeros ( 2 , 2 ); sstd :: zeros ( m_zeros ); sstd :: printn ( m ); printf ( \" \\n \" ); sstd :: printn ( m_eye ); printf ( \" \\n \" ); sstd :: printn ( m_ones ); printf ( \" \\n \" ); sstd :: printn ( m_zeros ); } output m = 1.000000 2.000000 3.000000 4.000000 m_eye = 1.000000 0.000000 0.000000 1.000000 m_ones = 1.000000 1.000000 1.000000 1.000000 m_zeros = 0.000000 0.000000 0.000000 0.000000","title":"Init"},{"location":"src/matrix/mat_rowMajor/#access-to-elements","text":"","title":"Access to elements"},{"location":"src/matrix/mat_rowMajor/#as-a-matrix","text":"input #include <sstd/sstd.hpp> int main (){ sstd :: mat_r < double > m ( 2 , 2 ); uint i = 0 ; for ( uint r = 0 ; r < m . rows (); ++ r ){ for ( uint c = 0 ; c < m . cols (); ++ c ){ m ( r , c ) = i ; ++ i ; } } sstd :: printn ( m ); } output m = 0.000000 1.000000 2.000000 3.000000","title":"As a matrix"},{"location":"src/matrix/mat_rowMajor/#as-a-vector","text":"input #include <sstd/sstd.hpp> int main (){ sstd :: mat_r < double > m ( 2 , 2 ); for ( uint i = 0 ; i < m . size (); ++ i ){ m [ i ] = i ; } sstd :: printn ( m ); } output m = 0.000000 1.000000 2.000000 3.000000","title":"As a vector"},{"location":"src/matrix/mat_rowMajor/#tr-transpose","text":"input #include <sstd/sstd.hpp> int main (){ sstd :: mat_r < double > m1 = {{ 1 , 2 }, { 3 , 4 }}; sstd :: printn ( m1 ); sstd :: printn ( sstd :: Tr ( m1 ) ); printf ( \" \\n \" ); sstd :: mat_r < double > m2 = {{ 1 , 2 }, { 3 , 4 }}; sstd :: printn ( m2 ); sstd :: Tr_myself ( m2 ); sstd :: printn ( m2 ); } output m1 = 1.000000 2.000000 3.000000 4.000000 sstd::Tr( m1 ) = 1.000000 3.000000 2.000000 4.000000 m2 = 1.000000 2.000000 3.000000 4.000000 m2 = 1.000000 3.000000 2.000000 4.000000","title":"Tr (Transpose)"},{"location":"src/matrix/mat_rowMajor/#operator","text":"","title":"Operator"},{"location":"src/matrix/mat_rowMajor/#matrix-scalar","text":"input #include <sstd/sstd.hpp> int main (){ sstd :: mat_r < double > m ( 2 , 2 ); for ( uint i = 0 ; i < m . size (); ++ i ){ m [ i ] = i ; } sstd :: printn ( m ); printf ( \" \\n \" ); sstd :: printn ( m * 2 ); } output m = 0.000000 1.000000 2.000000 3.000000 m * 2 = 0.000000 2.000000 4.000000 6.000000","title":"matrix \u00d7 scalar"},{"location":"src/matrix/mat_rowMajor/#matrix-matrix","text":"input #include <sstd/sstd.hpp> int main (){ sstd :: mat_r < double > m1 ( 2 , 2 ); for ( uint i = 0 ; i < m1 . size (); ++ i ){ m1 [ i ] = i ; } sstd :: mat_r < double > m2 ( 2 , 2 ); for ( uint i = 0 ; i < m2 . size (); ++ i ){ m2 [ i ] = i + 1 ; } sstd :: printn ( m1 ); printf ( \" \\n \" ); sstd :: printn ( m2 ); printf ( \" \\n \" ); sstd :: printn ( m1 * m2 ); } output m1 = 0.000000 1.000000 2.000000 3.000000 m2 = 1.000000 2.000000 3.000000 4.000000 m1 * m2 = 3.000000 4.000000 11.000000 16.000000","title":"matrix \u00d7 matrix"},{"location":"src/matrix/mat_rowMajor/#matrix-as-a-vector-matrix-as-a-vector","text":"input #include <sstd/sstd.hpp> int main (){ sstd :: mat_r < double > m1 ( 2 , 2 ); for ( uint i = 0 ; i < m1 . size (); ++ i ){ m1 [ i ] = i ; } sstd :: mat_r < double > m2 ( 2 , 2 ); for ( uint i = 0 ; i < m2 . size (); ++ i ){ m2 [ i ] = i + 1 ; } sstd :: printn ( m1 ); printf ( \" \\n \" ); sstd :: printn ( m2 ); printf ( \" \\n \" ); sstd :: printn ( m1 () * m2 () ); } output m1 = 0.000000 1.000000 2.000000 3.000000 m2 = 1.000000 2.000000 3.000000 4.000000 m1() * m2() = 0.000000 2.000000 6.000000 12.000000","title":"matrix (as a vector) \u00d7 matrix (as a vector)"},{"location":"src/matrix/mat_rowMajor/#implementation","text":"Source: sstd/src/matrixContainer_rowMajor/mat_r.cpp Header: sstd/src/matrixContainer_rowMajor/mat_r.hpp Test: test/mat_r.hpp (Not implemented yet)","title":"Implementation"},{"location":"src/stdlib/system/","text":"system Abstract system() executes the specified command. system() \u306f\u6307\u5b9a\u3055\u308c\u305f\u30b3\u30de\u30f3\u30c9\u3092\u5b9f\u884c\u3057\u307e\u3059\uff0e Header file namespace sstd { int system ( const char * str ); int system ( const std :: string & str ); } Usage input #include <sstd/sstd.hpp> int main (){ sstd :: system ( \"mkdir -p ./tmp/a/b/c\" ); sstd :: system ( \"tree ./tmp\" ); sstd :: system ( \"rm -rf ./tmp\" ); } output ./tmp \u2514\u2500\u2500 a \u2514\u2500\u2500 b \u2514\u2500\u2500 c 3 directories, 0 files Implementation Source: sstd/src/stdlib.cpp Header: sstd/src/stdlib.hpp Test: test/stdlib.hpp (Not implemented yet)","title":"system"},{"location":"src/stdlib/system/#system","text":"","title":"system"},{"location":"src/stdlib/system/#abstract","text":"system() executes the specified command. system() \u306f\u6307\u5b9a\u3055\u308c\u305f\u30b3\u30de\u30f3\u30c9\u3092\u5b9f\u884c\u3057\u307e\u3059\uff0e","title":"Abstract"},{"location":"src/stdlib/system/#header-file","text":"namespace sstd { int system ( const char * str ); int system ( const std :: string & str ); }","title":"Header file"},{"location":"src/stdlib/system/#usage","text":"input #include <sstd/sstd.hpp> int main (){ sstd :: system ( \"mkdir -p ./tmp/a/b/c\" ); sstd :: system ( \"tree ./tmp\" ); sstd :: system ( \"rm -rf ./tmp\" ); } output ./tmp \u2514\u2500\u2500 a \u2514\u2500\u2500 b \u2514\u2500\u2500 c 3 directories, 0 files","title":"Usage"},{"location":"src/stdlib/system/#implementation","text":"Source: sstd/src/stdlib.cpp Header: sstd/src/stdlib.hpp Test: test/stdlib.hpp (Not implemented yet)","title":"Implementation"},{"location":"src/vector/Tr/","text":"Tr (Transpose) Abstract Tr() are the transpose functions for std::vector<std::vector<T>> . Tr() \u306f std::vector<std::vector<T>> \u3092\u8ee2\u7f6e\u3059\u308b\u305f\u3081\u306e\u95a2\u6570\u3067\u3059. Header file namespace sstd { template < typename T > std :: vector < std :: vector < T >> Tr ( const std :: vector < std :: vector < T >>& rhs ); template < typename T > std :: vector < std :: vector < T >> Tr ( std :: vector < std :: vector < T >>&& rhs ); } Usage Transpose. Ex: 1 input #include <sstd/sstd.hpp> int main (){ std :: vector < std :: vector < int >> vvec = { { 1 , 2 , 3 } }; sstd :: printn ( vvec ); std :: vector < std :: vector < int >> vvecTr = sstd :: Tr ( vvec ); sstd :: printn ( vvecTr ); } output vvec = [[1 2 3]] vvecTr = [[1] [2] [3]] Transpose. Ex: 2 input #include <sstd/sstd.hpp> int main (){ std :: vector < std :: vector < int >> vvec = { { 1 , 2 , 3 }, { 4 , 5 , 6 }, { 7 , 8 , 9 } }; sstd :: printn ( vvec ); std :: vector < std :: vector < int >> vvecTr = sstd :: Tr ( vvec ); sstd :: printn ( vvecTr ); } output vvec = [[1 2 3] [4 5 6] [7 8 9]] vvecTr = [[1 4 7] [2 5 8] [3 6 9]] Transpose. Ex: 3 input #include <sstd/sstd.hpp> int main (){ std :: vector < std :: vector < int >> vvec = { { 1 }, { 2 , 3 }, { 4 , 5 , 6 } }; sstd :: printn ( vvec ); std :: vector < std :: vector < int >> vvecTr = sstd :: Tr ( vvec ); sstd :: printn ( vvecTr ); } output vvec = [[1] [2 3] [4 5 6]] vvecTr = [[1 2 4] [0 3 5] [0 0 6]] Implementation Header: sstd/src/vector/vvec.hpp Test: test/vector_vvec.hpp","title":"Tr (Transpose)"},{"location":"src/vector/Tr/#tr-transpose","text":"","title":"Tr (Transpose)"},{"location":"src/vector/Tr/#abstract","text":"Tr() are the transpose functions for std::vector<std::vector<T>> . Tr() \u306f std::vector<std::vector<T>> \u3092\u8ee2\u7f6e\u3059\u308b\u305f\u3081\u306e\u95a2\u6570\u3067\u3059.","title":"Abstract"},{"location":"src/vector/Tr/#header-file","text":"namespace sstd { template < typename T > std :: vector < std :: vector < T >> Tr ( const std :: vector < std :: vector < T >>& rhs ); template < typename T > std :: vector < std :: vector < T >> Tr ( std :: vector < std :: vector < T >>&& rhs ); }","title":"Header file"},{"location":"src/vector/Tr/#usage","text":"","title":"Usage"},{"location":"src/vector/Tr/#transpose-ex-1","text":"input #include <sstd/sstd.hpp> int main (){ std :: vector < std :: vector < int >> vvec = { { 1 , 2 , 3 } }; sstd :: printn ( vvec ); std :: vector < std :: vector < int >> vvecTr = sstd :: Tr ( vvec ); sstd :: printn ( vvecTr ); } output vvec = [[1 2 3]] vvecTr = [[1] [2] [3]]","title":"Transpose. Ex: 1"},{"location":"src/vector/Tr/#transpose-ex-2","text":"input #include <sstd/sstd.hpp> int main (){ std :: vector < std :: vector < int >> vvec = { { 1 , 2 , 3 }, { 4 , 5 , 6 }, { 7 , 8 , 9 } }; sstd :: printn ( vvec ); std :: vector < std :: vector < int >> vvecTr = sstd :: Tr ( vvec ); sstd :: printn ( vvecTr ); } output vvec = [[1 2 3] [4 5 6] [7 8 9]] vvecTr = [[1 4 7] [2 5 8] [3 6 9]]","title":"Transpose. Ex: 2"},{"location":"src/vector/Tr/#transpose-ex-3","text":"input #include <sstd/sstd.hpp> int main (){ std :: vector < std :: vector < int >> vvec = { { 1 }, { 2 , 3 }, { 4 , 5 , 6 } }; sstd :: printn ( vvec ); std :: vector < std :: vector < int >> vvecTr = sstd :: Tr ( vvec ); sstd :: printn ( vvecTr ); } output vvec = [[1] [2 3] [4 5 6]] vvecTr = [[1 2 4] [0 3 5] [0 0 6]]","title":"Transpose. Ex: 3"},{"location":"src/vector/Tr/#implementation","text":"Header: sstd/src/vector/vvec.hpp Test: test/vector_vvec.hpp","title":"Implementation"},{"location":"src/vector/slice/","text":"slice Abstract sstd::slice / sstd::slice_mv \u306f\uff0cPython \u306e slice \u5b9f\u88c5\u3092 C++ \u98a8\u306b\u30a2\u30ec\u30f3\u30b8\u3057\u305f sstd \u306e\u72ec\u81ea\u5b9f\u88c5\u3067\u3059\uff0e sstd::slice \u306f\u8981\u7d20\u30b3\u30d4\u30fc\u3092\u4f34\u3046\u547d\u4ee4\u3067\uff0c sstd::slice_mv \u306f\u5185\u90e8\u7684\u306b std::move \u3092\u547c\u3073\u51fa\u3057\u307e\u3059\uff0e std::vector \u306b\u5bfe\u3059\u308b slice \u64cd\u4f5c\u3092\u5b9a\u7fa9\u3057\u3066\u3044\u307e\u3059\uff0e \u306a\u304a\uff0c sstd::begin \u304a\u3088\u3073 sstd::end \u306f\uff0c src/itr.hpp \u306b\u5b9a\u7fa9\u3055\u308c\u3066\u3044\u308b\uff0e Header file namespace sstd { sstd_vecSc :: slice_i slice ( const int val ); sstd_vecSc :: slice_u slice ( const uint val ); sstd_vecSc :: slice_s slice ( const size_t val ); sstd_vecSc :: slice_b slice ( const sstd :: begin val ); sstd_vecSc :: slice_e slice ( const sstd :: end val ); sstd_vecSc :: slice_ii slice ( const int lhs , const int rhs ); sstd_vecSc :: slice_iu slice ( const int lhs , const uint rhs ); sstd_vecSc :: slice_is slice ( const int lhs , const size_t rhs ); sstd_vecSc :: slice_ui slice ( const uint lhs , const int rhs ); sstd_vecSc :: slice_uu slice ( const uint lhs , const uint rhs ); sstd_vecSc :: slice_us slice ( const uint lhs , const size_t rhs ); sstd_vecSc :: slice_si slice ( const size_t lhs , const int rhs ); sstd_vecSc :: slice_su slice ( const size_t lhs , const uint rhs ); sstd_vecSc :: slice_ss slice ( const size_t lhs , const size_t rhs ); sstd_vecSc :: slice_bi slice ( const sstd :: begin lhs , const int rhs ); sstd_vecSc :: slice_bu slice ( const sstd :: begin lhs , const uint rhs ); sstd_vecSc :: slice_bs slice ( const sstd :: begin lhs , const size_t rhs ); sstd_vecSc :: slice_ie slice ( const int lhs , const sstd :: end rhs ); sstd_vecSc :: slice_ue slice ( const uint lhs , const sstd :: end rhs ); sstd_vecSc :: slice_se slice ( const size_t lhs , const sstd :: end rhs ); sstd_vecSc :: slice_be slice ( const sstd :: begin lhs , const sstd :: end rhs ); //--- sstd_vecSc :: slice_mv_i slice_mv ( const int val ); sstd_vecSc :: slice_mv_u slice_mv ( const uint val ); sstd_vecSc :: slice_mv_s slice_mv ( const size_t val ); sstd_vecSc :: slice_mv_b slice_mv ( const sstd :: begin val ); sstd_vecSc :: slice_mv_e slice_mv ( const sstd :: end val ); sstd_vecSc :: slice_mv_ii slice_mv ( const int lhs , const int rhs ); sstd_vecSc :: slice_mv_iu slice_mv ( const int lhs , const uint rhs ); sstd_vecSc :: slice_mv_is slice_mv ( const int lhs , const size_t rhs ); sstd_vecSc :: slice_mv_ui slice_mv ( const uint lhs , const int rhs ); sstd_vecSc :: slice_mv_uu slice_mv ( const uint lhs , const uint rhs ); sstd_vecSc :: slice_mv_us slice_mv ( const uint lhs , const size_t rhs ); sstd_vecSc :: slice_mv_si slice_mv ( const size_t lhs , const int rhs ); sstd_vecSc :: slice_mv_su slice_mv ( const size_t lhs , const uint rhs ); sstd_vecSc :: slice_mv_ss slice_mv ( const size_t lhs , const size_t rhs ); sstd_vecSc :: slice_mv_bi slice_mv ( const sstd :: begin lhs , const int rhs ); sstd_vecSc :: slice_mv_bu slice_mv ( const sstd :: begin lhs , const uint rhs ); sstd_vecSc :: slice_mv_bs slice_mv ( const sstd :: begin lhs , const size_t rhs ); sstd_vecSc :: slice_mv_ie slice_mv ( const int lhs , const sstd :: end rhs ); sstd_vecSc :: slice_mv_ue slice_mv ( const uint lhs , const sstd :: end rhs ); sstd_vecSc :: slice_mv_se slice_mv ( const size_t lhs , const sstd :: end rhs ); sstd_vecSc :: slice_mv_be slice_mv ( const sstd :: begin lhs , const sstd :: end rhs ); } Usage one arg (copy) input #include <sstd/sstd.hpp> int main (){ std :: vector < int > v = { 1 , 2 , 3 , 4 , 5 }; std :: vector < int > v_sliced01 = v && sstd :: slice ( 1 ); std :: vector < int > v_sliced02 = v && sstd :: slice ( - 1 ); sstd :: printn ( v ); sstd :: printn ( v_sliced01 ); sstd :: printn ( v_sliced02 ); } output v = [1 2 3 4 5] v_sliced01 = [2] v_sliced02 = [5] two args (copy) input #include <sstd/sstd.hpp> int main (){ std :: vector < int > v = { 1 , 2 , 3 , 4 , 5 }; std :: vector < int > v_sliced = v && sstd :: slice ( 1 , 3 ); sstd :: printn ( v ); sstd :: printn ( v_sliced ); } output v = [1 2 3 4 5] v_sliced = [2 3] begin to end (copy) input #include <sstd/sstd.hpp> int main (){ std :: vector < int > v = { 1 , 2 , 3 , 4 , 5 }; std :: vector < int > v_sliced = v && sstd :: slice ( sstd :: begin (), sstd :: end ()); sstd :: printn ( v ); sstd :: printn ( v_sliced ); } output v = [1 2 3 4 5] v_sliced = [1 2 3 4 5] one arg (move) input #include <sstd/sstd.hpp> int main (){ std :: vector < std :: string > v = { \"1\" , \"2\" , \"3\" , \"4\" , \"5\" }; std :: vector < std :: string > v_sliced01 = v && sstd :: slice_mv ( 1 ); std :: vector < std :: string > v_sliced02 = v && sstd :: slice_mv ( - 1 ); sstd :: printn ( v ); sstd :: printn ( v_sliced01 ); sstd :: printn ( v_sliced02 ); } output v = [\"1\" \"\" \"3\" \"4\" \"\"] v_sliced01 = [\"2\"] v_sliced02 = [\"5\"] two args (move) input #include <sstd/sstd.hpp> int main (){ std :: vector < std :: string > v = { \"1\" , \"2\" , \"3\" , \"4\" , \"5\" }; std :: vector < std :: string > v_sliced = v && sstd :: slice_mv ( 1 , 3 ); sstd :: printn ( v ); sstd :: printn ( v_sliced ); } output v = [\"1\" \"\" \"\" \"4\" \"5\"] v_sliced = [\"2\" \"3\"] begin to end (move) input #include <sstd/sstd.hpp> int main (){ std :: vector < std :: string > v = { \"1\" , \"2\" , \"3\" , \"4\" , \"5\" }; std :: vector < std :: string > v_sliced = v && sstd :: slice_mv ( sstd :: begin (), sstd :: end ()); sstd :: printn ( v ); sstd :: printn ( v_sliced ); } output v = [\"\" \"\" \"\" \"\" \"\"] v_sliced = [\"1\" \"2\" \"3\" \"4\" \"5\"] Implementation Header: sstd/src/vector/slice.hpp Test: test/vector_slice.hpp","title":"slice"},{"location":"src/vector/slice/#slice","text":"","title":"slice"},{"location":"src/vector/slice/#abstract","text":"sstd::slice / sstd::slice_mv \u306f\uff0cPython \u306e slice \u5b9f\u88c5\u3092 C++ \u98a8\u306b\u30a2\u30ec\u30f3\u30b8\u3057\u305f sstd \u306e\u72ec\u81ea\u5b9f\u88c5\u3067\u3059\uff0e sstd::slice \u306f\u8981\u7d20\u30b3\u30d4\u30fc\u3092\u4f34\u3046\u547d\u4ee4\u3067\uff0c sstd::slice_mv \u306f\u5185\u90e8\u7684\u306b std::move \u3092\u547c\u3073\u51fa\u3057\u307e\u3059\uff0e std::vector \u306b\u5bfe\u3059\u308b slice \u64cd\u4f5c\u3092\u5b9a\u7fa9\u3057\u3066\u3044\u307e\u3059\uff0e \u306a\u304a\uff0c sstd::begin \u304a\u3088\u3073 sstd::end \u306f\uff0c src/itr.hpp \u306b\u5b9a\u7fa9\u3055\u308c\u3066\u3044\u308b\uff0e","title":"Abstract"},{"location":"src/vector/slice/#header-file","text":"namespace sstd { sstd_vecSc :: slice_i slice ( const int val ); sstd_vecSc :: slice_u slice ( const uint val ); sstd_vecSc :: slice_s slice ( const size_t val ); sstd_vecSc :: slice_b slice ( const sstd :: begin val ); sstd_vecSc :: slice_e slice ( const sstd :: end val ); sstd_vecSc :: slice_ii slice ( const int lhs , const int rhs ); sstd_vecSc :: slice_iu slice ( const int lhs , const uint rhs ); sstd_vecSc :: slice_is slice ( const int lhs , const size_t rhs ); sstd_vecSc :: slice_ui slice ( const uint lhs , const int rhs ); sstd_vecSc :: slice_uu slice ( const uint lhs , const uint rhs ); sstd_vecSc :: slice_us slice ( const uint lhs , const size_t rhs ); sstd_vecSc :: slice_si slice ( const size_t lhs , const int rhs ); sstd_vecSc :: slice_su slice ( const size_t lhs , const uint rhs ); sstd_vecSc :: slice_ss slice ( const size_t lhs , const size_t rhs ); sstd_vecSc :: slice_bi slice ( const sstd :: begin lhs , const int rhs ); sstd_vecSc :: slice_bu slice ( const sstd :: begin lhs , const uint rhs ); sstd_vecSc :: slice_bs slice ( const sstd :: begin lhs , const size_t rhs ); sstd_vecSc :: slice_ie slice ( const int lhs , const sstd :: end rhs ); sstd_vecSc :: slice_ue slice ( const uint lhs , const sstd :: end rhs ); sstd_vecSc :: slice_se slice ( const size_t lhs , const sstd :: end rhs ); sstd_vecSc :: slice_be slice ( const sstd :: begin lhs , const sstd :: end rhs ); //--- sstd_vecSc :: slice_mv_i slice_mv ( const int val ); sstd_vecSc :: slice_mv_u slice_mv ( const uint val ); sstd_vecSc :: slice_mv_s slice_mv ( const size_t val ); sstd_vecSc :: slice_mv_b slice_mv ( const sstd :: begin val ); sstd_vecSc :: slice_mv_e slice_mv ( const sstd :: end val ); sstd_vecSc :: slice_mv_ii slice_mv ( const int lhs , const int rhs ); sstd_vecSc :: slice_mv_iu slice_mv ( const int lhs , const uint rhs ); sstd_vecSc :: slice_mv_is slice_mv ( const int lhs , const size_t rhs ); sstd_vecSc :: slice_mv_ui slice_mv ( const uint lhs , const int rhs ); sstd_vecSc :: slice_mv_uu slice_mv ( const uint lhs , const uint rhs ); sstd_vecSc :: slice_mv_us slice_mv ( const uint lhs , const size_t rhs ); sstd_vecSc :: slice_mv_si slice_mv ( const size_t lhs , const int rhs ); sstd_vecSc :: slice_mv_su slice_mv ( const size_t lhs , const uint rhs ); sstd_vecSc :: slice_mv_ss slice_mv ( const size_t lhs , const size_t rhs ); sstd_vecSc :: slice_mv_bi slice_mv ( const sstd :: begin lhs , const int rhs ); sstd_vecSc :: slice_mv_bu slice_mv ( const sstd :: begin lhs , const uint rhs ); sstd_vecSc :: slice_mv_bs slice_mv ( const sstd :: begin lhs , const size_t rhs ); sstd_vecSc :: slice_mv_ie slice_mv ( const int lhs , const sstd :: end rhs ); sstd_vecSc :: slice_mv_ue slice_mv ( const uint lhs , const sstd :: end rhs ); sstd_vecSc :: slice_mv_se slice_mv ( const size_t lhs , const sstd :: end rhs ); sstd_vecSc :: slice_mv_be slice_mv ( const sstd :: begin lhs , const sstd :: end rhs ); }","title":"Header file"},{"location":"src/vector/slice/#usage","text":"","title":"Usage"},{"location":"src/vector/slice/#one-arg-copy","text":"input #include <sstd/sstd.hpp> int main (){ std :: vector < int > v = { 1 , 2 , 3 , 4 , 5 }; std :: vector < int > v_sliced01 = v && sstd :: slice ( 1 ); std :: vector < int > v_sliced02 = v && sstd :: slice ( - 1 ); sstd :: printn ( v ); sstd :: printn ( v_sliced01 ); sstd :: printn ( v_sliced02 ); } output v = [1 2 3 4 5] v_sliced01 = [2] v_sliced02 = [5]","title":"one arg (copy)"},{"location":"src/vector/slice/#two-args-copy","text":"input #include <sstd/sstd.hpp> int main (){ std :: vector < int > v = { 1 , 2 , 3 , 4 , 5 }; std :: vector < int > v_sliced = v && sstd :: slice ( 1 , 3 ); sstd :: printn ( v ); sstd :: printn ( v_sliced ); } output v = [1 2 3 4 5] v_sliced = [2 3]","title":"two args (copy)"},{"location":"src/vector/slice/#begin-to-end-copy","text":"input #include <sstd/sstd.hpp> int main (){ std :: vector < int > v = { 1 , 2 , 3 , 4 , 5 }; std :: vector < int > v_sliced = v && sstd :: slice ( sstd :: begin (), sstd :: end ()); sstd :: printn ( v ); sstd :: printn ( v_sliced ); } output v = [1 2 3 4 5] v_sliced = [1 2 3 4 5]","title":"begin to end (copy)"},{"location":"src/vector/slice/#one-arg-move","text":"input #include <sstd/sstd.hpp> int main (){ std :: vector < std :: string > v = { \"1\" , \"2\" , \"3\" , \"4\" , \"5\" }; std :: vector < std :: string > v_sliced01 = v && sstd :: slice_mv ( 1 ); std :: vector < std :: string > v_sliced02 = v && sstd :: slice_mv ( - 1 ); sstd :: printn ( v ); sstd :: printn ( v_sliced01 ); sstd :: printn ( v_sliced02 ); } output v = [\"1\" \"\" \"3\" \"4\" \"\"] v_sliced01 = [\"2\"] v_sliced02 = [\"5\"]","title":"one arg (move)"},{"location":"src/vector/slice/#two-args-move","text":"input #include <sstd/sstd.hpp> int main (){ std :: vector < std :: string > v = { \"1\" , \"2\" , \"3\" , \"4\" , \"5\" }; std :: vector < std :: string > v_sliced = v && sstd :: slice_mv ( 1 , 3 ); sstd :: printn ( v ); sstd :: printn ( v_sliced ); } output v = [\"1\" \"\" \"\" \"4\" \"5\"] v_sliced = [\"2\" \"3\"]","title":"two args (move)"},{"location":"src/vector/slice/#begin-to-end-move","text":"input #include <sstd/sstd.hpp> int main (){ std :: vector < std :: string > v = { \"1\" , \"2\" , \"3\" , \"4\" , \"5\" }; std :: vector < std :: string > v_sliced = v && sstd :: slice_mv ( sstd :: begin (), sstd :: end ()); sstd :: printn ( v ); sstd :: printn ( v_sliced ); } output v = [\"\" \"\" \"\" \"\" \"\"] v_sliced = [\"1\" \"2\" \"3\" \"4\" \"5\"]","title":"begin to end (move)"},{"location":"src/vector/slice/#implementation","text":"Header: sstd/src/vector/slice.hpp Test: test/vector_slice.hpp","title":"Implementation"},{"location":"src/vector/stdVector_expansion/","text":"Operator expansions for std::vector<T> Abstract Operator definitions on SSTD. These definitions are read by #include <sstd/sstd.hpp> . SSTD \u306b\u304a\u3051\u308b\u6f14\u7b97\u5b50\u306e\u5b9a\u7fa9\uff0e #include <sstd/sstd.hpp> \u306b\u3088\u308a\u5b9a\u7fa9\u304c\u8aad\u307f\u8fbc\u307e\u308c\u308b\uff0e Header file namespace sstd_stdVecEx { // operators for mathematics SSTD_DEF_stdVecEx_defInNamespace ( add ); // + SSTD_DEF_stdVecEx_defInNamespace_eq ( add_eq ); // += SSTD_DEF_stdVecEx_defInNamespace ( sub ); // - SSTD_DEF_stdVecEx_defInNamespace_eq ( sub_eq ); // -= SSTD_DEF_stdVecEx_defInNamespace ( mul ); // * SSTD_DEF_stdVecEx_defInNamespace_eq ( mul_eq ); // *= SSTD_DEF_stdVecEx_defInNamespace ( div ); // / SSTD_DEF_stdVecEx_defInNamespace_eq ( div_eq ); // /= SSTD_DEF_stdVecEx_defInNamespace ( mod ); // % SSTD_DEF_stdVecEx_defInNamespace_eq ( mod_eq ); // %= SSTD_DEF_stdVecEx_defInNamespace ( pow ); // ^ SSTD_DEF_stdVecEx_defInNamespace_eq ( pow_eq ); // ^= // operators for std::vector SSTD_DEF_stdVecEx_defInNamespace ( push_front ); // >> SSTD_DEF_stdVecEx_defInNamespace_eq ( push_front_eq ); // >>= SSTD_DEF_stdVecEx_defInNamespace ( push_back ); // << SSTD_DEF_stdVecEx_defInNamespace_eq ( push_back_eq ); // <<= } Usage Ope. * and *= vector \u00d7 scalar input #include <sstd/sstd.hpp> int main (){ std :: vector < int > v = { 1 , 2 , 3 }; sstd :: printn ( v * 2 ); v *= 3 ; sstd :: printn ( v ); } output v * 2 = [2 4 6] v = [3 6 9] vector \u00d7 vector input #include <sstd/sstd.hpp> int main (){ std :: vector < int > v1 = { 1 , 2 , 3 }; std :: vector < int > v2 = { 2 , 3 , 4 }; sstd :: printn ( v1 * v2 ); v1 *= v2 ; sstd :: printn ( v1 ); sstd :: printn ( v2 ); } output v1 * v2 = [2 6 12] v1 = [2 6 12] v2 = [2 3 4] Linking << vector << scalar input #include <sstd/sstd.hpp> int main (){ std :: vector < int > v = { 1 , 2 , 3 }; int s = 4 ; sstd :: printn ( v << s ); sstd :: printn ( v ); sstd :: printn ( s ); } output v << s = [1 2 3 4] v = [1 2 3] s = 4 vector << vector input #include <sstd/sstd.hpp> int main (){ std :: vector < int > v1 = { 1 , 2 , 3 }; std :: vector < int > v2 = { 4 , 5 , 6 }; sstd :: printn ( v1 << v2 ); sstd :: printn ( v1 ); sstd :: printn ( v2 ); } output v1 << v2 = [1 2 3 4 5 6] v1 = [1 2 3] v2 = [4 5 6] push_back() vector <<= scalar input #include <sstd/sstd.hpp> int main (){ std :: vector < int > v ; v <<= 1 ; // same as a \"v.push_back(1);\" v <<= 2 ; // same as a \"v.push_back(2);\" v <<= 3 ; // same as a \"v.push_back(3);\" sstd :: printn ( v ); } output v = [1 2 3] vector <<= vector input #include <sstd/sstd.hpp> int main (){ std :: vector < int > v1 = { 1 , 2 , 3 }; std :: vector < int > v2 = { 4 , 5 , 6 }; v1 <<= v2 ; sstd :: printn ( v1 ); sstd :: printn ( v2 ); } output v1 = [1 2 3 4 5 6] v2 = [4 5 6] Linking >> vector >> scalar input #include <sstd/sstd.hpp> int main (){ std :: vector < int > v = { 1 , 2 , 3 }; int s = 0 ; sstd :: printn ( v >> s ); sstd :: printn ( v ); sstd :: printn ( s ); } output v >> s = [0 1 2 3] v = [1 2 3] s = 0 vector >> vector input #include <sstd/sstd.hpp> int main (){ std :: vector < int > v1 = { 1 , 2 , 3 }; std :: vector < int > v2 = { - 2 , - 1 , 0 }; sstd :: printn ( v1 >> v2 ); sstd :: printn ( v1 ); sstd :: printn ( v2 ); } output v1 >> v2 = [-2 -1 0 1 2 3] v1 = [1 2 3] v2 = [-2 -1 0] push_front() vector >>= scalar input #include <sstd/sstd.hpp> int main (){ std :: vector < int > v = { 1 , 2 , 3 }; v >>= 0 ; sstd :: printn ( v ); } output v = [0 1 2 3] vector >>= vector input #include <sstd/sstd.hpp> int main (){ std :: vector < int > v1 = { 1 , 2 , 3 }; std :: vector < int > v2 = { - 2 , - 1 , 0 }; v1 >>= v2 ; sstd :: printn ( v1 ); sstd :: printn ( v2 ); } output v1 = [-2 -1 0 1 2 3] v2 = [-2 -1 0] Implementation Header: sstd/src/vector/stdVector_expansion.hpp Test: test/vector_stdVector_expansion.hpp","title":"Ope. Exp. for std::vector&lt;T&gt;"},{"location":"src/vector/stdVector_expansion/#operator-expansions-for-stdvectort","text":"","title":"Operator expansions for std::vector&lt;T&gt;"},{"location":"src/vector/stdVector_expansion/#abstract","text":"Operator definitions on SSTD. These definitions are read by #include <sstd/sstd.hpp> . SSTD \u306b\u304a\u3051\u308b\u6f14\u7b97\u5b50\u306e\u5b9a\u7fa9\uff0e #include <sstd/sstd.hpp> \u306b\u3088\u308a\u5b9a\u7fa9\u304c\u8aad\u307f\u8fbc\u307e\u308c\u308b\uff0e","title":"Abstract"},{"location":"src/vector/stdVector_expansion/#header-file","text":"namespace sstd_stdVecEx { // operators for mathematics SSTD_DEF_stdVecEx_defInNamespace ( add ); // + SSTD_DEF_stdVecEx_defInNamespace_eq ( add_eq ); // += SSTD_DEF_stdVecEx_defInNamespace ( sub ); // - SSTD_DEF_stdVecEx_defInNamespace_eq ( sub_eq ); // -= SSTD_DEF_stdVecEx_defInNamespace ( mul ); // * SSTD_DEF_stdVecEx_defInNamespace_eq ( mul_eq ); // *= SSTD_DEF_stdVecEx_defInNamespace ( div ); // / SSTD_DEF_stdVecEx_defInNamespace_eq ( div_eq ); // /= SSTD_DEF_stdVecEx_defInNamespace ( mod ); // % SSTD_DEF_stdVecEx_defInNamespace_eq ( mod_eq ); // %= SSTD_DEF_stdVecEx_defInNamespace ( pow ); // ^ SSTD_DEF_stdVecEx_defInNamespace_eq ( pow_eq ); // ^= // operators for std::vector SSTD_DEF_stdVecEx_defInNamespace ( push_front ); // >> SSTD_DEF_stdVecEx_defInNamespace_eq ( push_front_eq ); // >>= SSTD_DEF_stdVecEx_defInNamespace ( push_back ); // << SSTD_DEF_stdVecEx_defInNamespace_eq ( push_back_eq ); // <<= }","title":"Header file"},{"location":"src/vector/stdVector_expansion/#usage","text":"","title":"Usage"},{"location":"src/vector/stdVector_expansion/#ope-and","text":"","title":"Ope. * and *="},{"location":"src/vector/stdVector_expansion/#vector-scalar","text":"input #include <sstd/sstd.hpp> int main (){ std :: vector < int > v = { 1 , 2 , 3 }; sstd :: printn ( v * 2 ); v *= 3 ; sstd :: printn ( v ); } output v * 2 = [2 4 6] v = [3 6 9]","title":"vector \u00d7 scalar"},{"location":"src/vector/stdVector_expansion/#vector-vector","text":"input #include <sstd/sstd.hpp> int main (){ std :: vector < int > v1 = { 1 , 2 , 3 }; std :: vector < int > v2 = { 2 , 3 , 4 }; sstd :: printn ( v1 * v2 ); v1 *= v2 ; sstd :: printn ( v1 ); sstd :: printn ( v2 ); } output v1 * v2 = [2 6 12] v1 = [2 6 12] v2 = [2 3 4]","title":"vector \u00d7 vector"},{"location":"src/vector/stdVector_expansion/#linking","text":"","title":"Linking &lt;&lt;"},{"location":"src/vector/stdVector_expansion/#vector-scalar_1","text":"input #include <sstd/sstd.hpp> int main (){ std :: vector < int > v = { 1 , 2 , 3 }; int s = 4 ; sstd :: printn ( v << s ); sstd :: printn ( v ); sstd :: printn ( s ); } output v << s = [1 2 3 4] v = [1 2 3] s = 4","title":"vector &lt;&lt; scalar"},{"location":"src/vector/stdVector_expansion/#vector-vector_1","text":"input #include <sstd/sstd.hpp> int main (){ std :: vector < int > v1 = { 1 , 2 , 3 }; std :: vector < int > v2 = { 4 , 5 , 6 }; sstd :: printn ( v1 << v2 ); sstd :: printn ( v1 ); sstd :: printn ( v2 ); } output v1 << v2 = [1 2 3 4 5 6] v1 = [1 2 3] v2 = [4 5 6]","title":"vector &lt;&lt; vector"},{"location":"src/vector/stdVector_expansion/#push_back","text":"","title":"push_back()"},{"location":"src/vector/stdVector_expansion/#vector-scalar_2","text":"input #include <sstd/sstd.hpp> int main (){ std :: vector < int > v ; v <<= 1 ; // same as a \"v.push_back(1);\" v <<= 2 ; // same as a \"v.push_back(2);\" v <<= 3 ; // same as a \"v.push_back(3);\" sstd :: printn ( v ); } output v = [1 2 3]","title":"vector &lt;&lt;= scalar"},{"location":"src/vector/stdVector_expansion/#vector-vector_2","text":"input #include <sstd/sstd.hpp> int main (){ std :: vector < int > v1 = { 1 , 2 , 3 }; std :: vector < int > v2 = { 4 , 5 , 6 }; v1 <<= v2 ; sstd :: printn ( v1 ); sstd :: printn ( v2 ); } output v1 = [1 2 3 4 5 6] v2 = [4 5 6]","title":"vector &lt;&lt;= vector"},{"location":"src/vector/stdVector_expansion/#linking_1","text":"","title":"Linking &gt;&gt;"},{"location":"src/vector/stdVector_expansion/#vector-scalar_3","text":"input #include <sstd/sstd.hpp> int main (){ std :: vector < int > v = { 1 , 2 , 3 }; int s = 0 ; sstd :: printn ( v >> s ); sstd :: printn ( v ); sstd :: printn ( s ); } output v >> s = [0 1 2 3] v = [1 2 3] s = 0","title":"vector &gt;&gt; scalar"},{"location":"src/vector/stdVector_expansion/#vector-vector_3","text":"input #include <sstd/sstd.hpp> int main (){ std :: vector < int > v1 = { 1 , 2 , 3 }; std :: vector < int > v2 = { - 2 , - 1 , 0 }; sstd :: printn ( v1 >> v2 ); sstd :: printn ( v1 ); sstd :: printn ( v2 ); } output v1 >> v2 = [-2 -1 0 1 2 3] v1 = [1 2 3] v2 = [-2 -1 0]","title":"vector &gt;&gt; vector"},{"location":"src/vector/stdVector_expansion/#push_front","text":"","title":"push_front()"},{"location":"src/vector/stdVector_expansion/#vector-scalar_4","text":"input #include <sstd/sstd.hpp> int main (){ std :: vector < int > v = { 1 , 2 , 3 }; v >>= 0 ; sstd :: printn ( v ); } output v = [0 1 2 3]","title":"vector &gt;&gt;= scalar"},{"location":"src/vector/stdVector_expansion/#vector-vector_4","text":"input #include <sstd/sstd.hpp> int main (){ std :: vector < int > v1 = { 1 , 2 , 3 }; std :: vector < int > v2 = { - 2 , - 1 , 0 }; v1 >>= v2 ; sstd :: printn ( v1 ); sstd :: printn ( v2 ); } output v1 = [-2 -1 0 1 2 3] v2 = [-2 -1 0]","title":"vector &gt;&gt;= vector"},{"location":"src/vector/stdVector_expansion/#implementation","text":"Header: sstd/src/vector/stdVector_expansion.hpp Test: test/vector_stdVector_expansion.hpp","title":"Implementation"},{"location":"src/vector/vec_vvec/","text":"vec/vvec Abstract Type definitions on SSTD. These definitions are read by #include <sstd/sstd.hpp> . SSTD \u306b\u304a\u3051\u308b\u578b\u306e\u5b9a\u7fa9\uff0e #include <sstd/sstd.hpp> \u306b\u3088\u308a\u5b9a\u7fa9\u304c\u8aad\u307f\u8fbc\u307e\u308c\u308b\uff0e Header file namespace sstd { template < class T > using vec = std :: vector < T > ; template < class T > using vvec = std :: vector < std :: vector < T >> ; } Usage input #include <sstd/sstd.hpp> int main (){ sstd :: vec < int > v = { 1 , 2 , 3 }; // same as a \"std::vector<int> v = {1, 2, 3};\" sstd :: printn ( v ); sstd :: vvec < int > vv = {{ 1 , 2 , 3 }, { 4 , 5 , 6 }}; // same as a \"std::vector<vector<int>> vv = {{1, 2, 3}, {4, 5, 6}};\" sstd :: printn ( vv ); } output v = [1 2 3] vv = [[1 2 3] [4 5 6]] Implementation Header: sstd/src/vector/typeDef.hpp Test: test/vector/typeDef.hpp (Not implemented yet)","title":"vec/vvec"},{"location":"src/vector/vec_vvec/#vecvvec","text":"","title":"vec/vvec"},{"location":"src/vector/vec_vvec/#abstract","text":"Type definitions on SSTD. These definitions are read by #include <sstd/sstd.hpp> . SSTD \u306b\u304a\u3051\u308b\u578b\u306e\u5b9a\u7fa9\uff0e #include <sstd/sstd.hpp> \u306b\u3088\u308a\u5b9a\u7fa9\u304c\u8aad\u307f\u8fbc\u307e\u308c\u308b\uff0e","title":"Abstract"},{"location":"src/vector/vec_vvec/#header-file","text":"namespace sstd { template < class T > using vec = std :: vector < T > ; template < class T > using vvec = std :: vector < std :: vector < T >> ; }","title":"Header file"},{"location":"src/vector/vec_vvec/#usage","text":"input #include <sstd/sstd.hpp> int main (){ sstd :: vec < int > v = { 1 , 2 , 3 }; // same as a \"std::vector<int> v = {1, 2, 3};\" sstd :: printn ( v ); sstd :: vvec < int > vv = {{ 1 , 2 , 3 }, { 4 , 5 , 6 }}; // same as a \"std::vector<vector<int>> vv = {{1, 2, 3}, {4, 5, 6}};\" sstd :: printn ( vv ); } output v = [1 2 3] vv = [[1 2 3] [4 5 6]]","title":"Usage"},{"location":"src/vector/vec_vvec/#implementation","text":"Header: sstd/src/vector/typeDef.hpp Test: test/vector/typeDef.hpp (Not implemented yet)","title":"Implementation"}]}