{"config":{"lang":["en","ja"],"min_search_length":3,"prebuild_index":false,"separator":"[\\s\\-]+"},"docs":[{"location":"","text":".img_overlay { /* parent div */ position: relative; } .img_overlay p { position: absolute; font-size: 40px; font-weight: normal; color: white; /* string color */ top: 0; left: 0; margin:0; padding:0; margin-top:-5px; } .img_overlay img { width: 100%; } SubStandardLibrary What is SSTD ? SubStandardLibrary (SSTD) is a convenient functions set for C++, works on GCC (g++). Installation Downloading source code from github.com/admiswalker/SubStandardLibrary . Copying all of under ./sstd/*. Compilling the sstd. $ cd ./sstd $ make Adding flags in your makefile. CFLAGS += -I./sstd/include -L./sstd/lib -lsstd CFLAGS += -std=gnu++0x Including a header #include <sstd/sstd.hpp> in your code. License MIT licence or Public domain. (This software is dual license, so you can choose whichever you want). Repository github.com/admiswalker/SubStandardLibrary","title":"What is SSTD ?"},{"location":"#what-is-sstd","text":"SubStandardLibrary (SSTD) is a convenient functions set for C++, works on GCC (g++).","title":"What is SSTD ?"},{"location":"#installation","text":"Downloading source code from github.com/admiswalker/SubStandardLibrary . Copying all of under ./sstd/*. Compilling the sstd. $ cd ./sstd $ make Adding flags in your makefile. CFLAGS += -I./sstd/include -L./sstd/lib -lsstd CFLAGS += -std=gnu++0x Including a header #include <sstd/sstd.hpp> in your code.","title":"Installation"},{"location":"#license","text":"MIT licence or Public domain. (This software is dual license, so you can choose whichever you want).","title":"License"},{"location":"#repository","text":"github.com/admiswalker/SubStandardLibrary","title":"Repository"},{"location":"src/glob/","text":"glob Abstract glob \u306f\uff0c\u6b63\u898f\u8868\u73fe * \u306b\u3088\u308a\uff0c\u30c7\u30a3\u30ec\u30af\u30c8\u30ea\u3092\u63a2\u7d22\u3057\u307e\u3059\uff0e \u203b\u305d\u306e\u4ed6\u306e\u6b63\u898f\u8868\u73fe\u306b\u3064\u3044\u3066\u306f\uff0c\u73fe\u72b6\u672a\u5b9f\u88c5\u3067\u3059\uff0e Header file namespace sstd { std :: vector < std :: string > glob ( const char * path ); std :: vector < std :: string > glob ( const std :: string & path ); } Usage input #include <sstd/sstd.hpp> int main (){ sstd :: mkdir ( \"./tmp\" ); sstd :: system ( \"touch ./tmp/a.txt\" ); sstd :: system ( \"touch ./tmp/b.csv\" ); sstd :: system ( \"touch ./tmp/c.txt\" ); std :: vector < std :: string > vStr = sstd :: glob ( \"./tmp/*.txt\" ); sstd :: printn ( vStr ); sstd :: rm ( \"./tmp\" ); } output vStr = [\"./tmp/a.txt\" \"./tmp/c.txt\"] Implementation Source: sstd/src/glob.cpp Header: sstd/src/glob.hpp Test: test/glob.hpp","title":"glob"},{"location":"src/glob/#glob","text":"","title":"glob"},{"location":"src/glob/#abstract","text":"glob \u306f\uff0c\u6b63\u898f\u8868\u73fe * \u306b\u3088\u308a\uff0c\u30c7\u30a3\u30ec\u30af\u30c8\u30ea\u3092\u63a2\u7d22\u3057\u307e\u3059\uff0e \u203b\u305d\u306e\u4ed6\u306e\u6b63\u898f\u8868\u73fe\u306b\u3064\u3044\u3066\u306f\uff0c\u73fe\u72b6\u672a\u5b9f\u88c5\u3067\u3059\uff0e","title":"Abstract"},{"location":"src/glob/#header-file","text":"namespace sstd { std :: vector < std :: string > glob ( const char * path ); std :: vector < std :: string > glob ( const std :: string & path ); }","title":"Header file"},{"location":"src/glob/#usage","text":"input #include <sstd/sstd.hpp> int main (){ sstd :: mkdir ( \"./tmp\" ); sstd :: system ( \"touch ./tmp/a.txt\" ); sstd :: system ( \"touch ./tmp/b.csv\" ); sstd :: system ( \"touch ./tmp/c.txt\" ); std :: vector < std :: string > vStr = sstd :: glob ( \"./tmp/*.txt\" ); sstd :: printn ( vStr ); sstd :: rm ( \"./tmp\" ); } output vStr = [\"./tmp/a.txt\" \"./tmp/c.txt\"]","title":"Usage"},{"location":"src/glob/#implementation","text":"Source: sstd/src/glob.cpp Header: sstd/src/glob.hpp Test: test/glob.hpp","title":"Implementation"},{"location":"src/itr/","text":"itr Abstract sstd::begin() and sstd::end() are the definitions for SSTD iterator. sstd::begin() \u3068 sstd::end() \u306f SSTD \u306e\u30a4\u30c6\u30ec\u30fc\u30bf\u306b\u5229\u7528\u3059\u308b\u305f\u3081\u306e\u5b9a\u7fa9\u3067\u3059\uff0e Header file namespace sstd { class begin ; class end ; } Usage input #include <sstd/sstd.hpp> int main (){ std :: vector < int > v = { 1 , 2 , 3 , 4 , 5 }; std :: vector < int > v_sliced = v && sstd :: slice ( sstd :: begin (), sstd :: end ()); sstd :: printn ( v ); sstd :: printn ( v_sliced ); } output v = [1 2 3 4 5] v_sliced = [1 2 3 4 5] Implementation Header: sstd/src/itr.hpp","title":"itr"},{"location":"src/itr/#itr","text":"","title":"itr"},{"location":"src/itr/#abstract","text":"sstd::begin() and sstd::end() are the definitions for SSTD iterator. sstd::begin() \u3068 sstd::end() \u306f SSTD \u306e\u30a4\u30c6\u30ec\u30fc\u30bf\u306b\u5229\u7528\u3059\u308b\u305f\u3081\u306e\u5b9a\u7fa9\u3067\u3059\uff0e","title":"Abstract"},{"location":"src/itr/#header-file","text":"namespace sstd { class begin ; class end ; }","title":"Header file"},{"location":"src/itr/#usage","text":"input #include <sstd/sstd.hpp> int main (){ std :: vector < int > v = { 1 , 2 , 3 , 4 , 5 }; std :: vector < int > v_sliced = v && sstd :: slice ( sstd :: begin (), sstd :: end ()); sstd :: printn ( v ); sstd :: printn ( v_sliced ); } output v = [1 2 3 4 5] v_sliced = [1 2 3 4 5]","title":"Usage"},{"location":"src/itr/#implementation","text":"Header: sstd/src/itr.hpp","title":"Implementation"},{"location":"src/measureTime/","text":"measureTime Abstract measureTime measures the execution time. measureTime \u306f\u5b9f\u884c\u6642\u9593\u3092\u8a08\u6e2c\u3057\u307e\u3059\uff0e Header file namespace sstd { void measureTime_start ( time_m & startTime ); double measureTime_stop_s ( const time_m & startTime ); // sec double measureTime_stop_ms ( const time_m & startTime ); // milli sec double measureTime_stop_us ( const time_m & startTime ); // micro sec double measureTime_stop_ns ( const time_m & startTime ); // nano sec std :: string measureTime_ms2str ( uint64 tmp ); std :: string measureTime_stop_str ( const time_m & startTime ); void measureTime_stop_print ( const time_m & startTime ); } Usage Measurement of execution time. (\u5b9f\u884c\u6642\u9593\u306e\u8a08\u6e2c) input #include <sstd/sstd.hpp> int main (){ printf ( \" \\n \" ); printf ( \"+---------------------------------------------------+ \\n \" ); printf ( \"| | \\n \" ); printf ( \"| Welcome to Sub Standard Library (SSTD) ! | \\n \" ); printf ( \"| | \\n \" ); printf ( \"+---------------------------------------------------+ \\n \" ); printf ( \" \\n \" ); printf ( \"\u25a0 measureTime_start--------------- \\n\\n \" ); time_m timem ; sstd :: measureTime_start ( timem ); sstd :: sleep_s ( 1 ); sstd :: sleep_ms ( 100 ); sstd :: sleep_us ( 11 * 1000 ); printf ( \" \\n \" ); printf ( \"\u25a0 measureTime_stop---------------- \\n \" ); sstd :: measureTime_stop_print ( timem ); sstd :: pauseIfWin32 (); return 0 ; } output +---------------------------------------------------+ | | | Welcome to Sub Standard Library (SSTD) ! | | | +---------------------------------------------------+ \u25a0 measureTime_start--------------- \u25a0 measureTime_stop---------------- -------------------------------- Execution time: 1. 113 sec -------------------------------- Lap time measurement. (\u30e9\u30c3\u30d7\u30bf\u30a4\u30e0\u306e\u6e2c\u5b9a) input #include <sstd/sstd.hpp> int main (){ std :: vector < double > vLT_ms ; time_m timem ; sstd :: measureTime_start ( timem ); vLT_ms . push_back ( sstd :: measureTime_stop_ms ( timem ) ); for ( uint i = 0 ; i < 5 ; ++ i ){ sstd :: sleep_ms ( 10 ); vLT_ms . push_back ( sstd :: measureTime_stop_ms ( timem ) ); } sstd :: printn ( vLT_ms ); return 0 ; } output vLT_ms = [0. 10.387 21.146 32.757 43.823 59.418] Implementation Source: sstd/src/measureTime.cpp Header: sstd/src/measureTime.hpp Test: test/measureTime.hpp","title":"measureTime"},{"location":"src/measureTime/#measuretime","text":"","title":"measureTime"},{"location":"src/measureTime/#abstract","text":"measureTime measures the execution time. measureTime \u306f\u5b9f\u884c\u6642\u9593\u3092\u8a08\u6e2c\u3057\u307e\u3059\uff0e","title":"Abstract"},{"location":"src/measureTime/#header-file","text":"namespace sstd { void measureTime_start ( time_m & startTime ); double measureTime_stop_s ( const time_m & startTime ); // sec double measureTime_stop_ms ( const time_m & startTime ); // milli sec double measureTime_stop_us ( const time_m & startTime ); // micro sec double measureTime_stop_ns ( const time_m & startTime ); // nano sec std :: string measureTime_ms2str ( uint64 tmp ); std :: string measureTime_stop_str ( const time_m & startTime ); void measureTime_stop_print ( const time_m & startTime ); }","title":"Header file"},{"location":"src/measureTime/#usage","text":"","title":"Usage"},{"location":"src/measureTime/#measurement-of-execution-time","text":"input #include <sstd/sstd.hpp> int main (){ printf ( \" \\n \" ); printf ( \"+---------------------------------------------------+ \\n \" ); printf ( \"| | \\n \" ); printf ( \"| Welcome to Sub Standard Library (SSTD) ! | \\n \" ); printf ( \"| | \\n \" ); printf ( \"+---------------------------------------------------+ \\n \" ); printf ( \" \\n \" ); printf ( \"\u25a0 measureTime_start--------------- \\n\\n \" ); time_m timem ; sstd :: measureTime_start ( timem ); sstd :: sleep_s ( 1 ); sstd :: sleep_ms ( 100 ); sstd :: sleep_us ( 11 * 1000 ); printf ( \" \\n \" ); printf ( \"\u25a0 measureTime_stop---------------- \\n \" ); sstd :: measureTime_stop_print ( timem ); sstd :: pauseIfWin32 (); return 0 ; } output +---------------------------------------------------+ | | | Welcome to Sub Standard Library (SSTD) ! | | | +---------------------------------------------------+ \u25a0 measureTime_start--------------- \u25a0 measureTime_stop---------------- -------------------------------- Execution time: 1. 113 sec --------------------------------","title":"Measurement of execution time. (\u5b9f\u884c\u6642\u9593\u306e\u8a08\u6e2c)"},{"location":"src/measureTime/#lap-time-measurement","text":"input #include <sstd/sstd.hpp> int main (){ std :: vector < double > vLT_ms ; time_m timem ; sstd :: measureTime_start ( timem ); vLT_ms . push_back ( sstd :: measureTime_stop_ms ( timem ) ); for ( uint i = 0 ; i < 5 ; ++ i ){ sstd :: sleep_ms ( 10 ); vLT_ms . push_back ( sstd :: measureTime_stop_ms ( timem ) ); } sstd :: printn ( vLT_ms ); return 0 ; } output vLT_ms = [0. 10.387 21.146 32.757 43.823 59.418]","title":"Lap time measurement. (\u30e9\u30c3\u30d7\u30bf\u30a4\u30e0\u306e\u6e2c\u5b9a)"},{"location":"src/measureTime/#implementation","text":"Source: sstd/src/measureTime.cpp Header: sstd/src/measureTime.hpp Test: test/measureTime.hpp","title":"Implementation"},{"location":"src/mkdir/","text":"mkdir Abstract mkdir creates directories recursively. mkdir \u306f\u30c7\u30a3\u30ec\u30af\u30c8\u30ea\u3092\u518d\u5e30\u7684\u306b\u4f5c\u6210\u3057\u307e\u3059\uff0e Header file namespace sstd { void mkdir ( const char * pPath ); void mkdir ( const std :: string & path ); } Usage input #include <sstd/sstd.hpp> int main (){ sstd :: mkdir ( \"./tmp/a/b/c/\" ); sstd :: system ( \"tree ./tmp\" ); sstd :: rm ( \"./tmp\" ); } output ./tmp \u2514\u2500\u2500 a \u2514\u2500\u2500 b \u2514\u2500\u2500 c 3 directories, 0 files Implementation Source: sstd/src/mkdir.cpp Header: sstd/src/mkdir.hpp Test: test/mkdir.hpp (Not implemented yet)","title":"mkdir"},{"location":"src/mkdir/#mkdir","text":"","title":"mkdir"},{"location":"src/mkdir/#abstract","text":"mkdir creates directories recursively. mkdir \u306f\u30c7\u30a3\u30ec\u30af\u30c8\u30ea\u3092\u518d\u5e30\u7684\u306b\u4f5c\u6210\u3057\u307e\u3059\uff0e","title":"Abstract"},{"location":"src/mkdir/#header-file","text":"namespace sstd { void mkdir ( const char * pPath ); void mkdir ( const std :: string & path ); }","title":"Header file"},{"location":"src/mkdir/#usage","text":"input #include <sstd/sstd.hpp> int main (){ sstd :: mkdir ( \"./tmp/a/b/c/\" ); sstd :: system ( \"tree ./tmp\" ); sstd :: rm ( \"./tmp\" ); } output ./tmp \u2514\u2500\u2500 a \u2514\u2500\u2500 b \u2514\u2500\u2500 c 3 directories, 0 files","title":"Usage"},{"location":"src/mkdir/#implementation","text":"Source: sstd/src/mkdir.cpp Header: sstd/src/mkdir.hpp Test: test/mkdir.hpp (Not implemented yet)","title":"Implementation"},{"location":"src/pid/","text":"pid Abstract getpid returns the PID of its own process. getpid \u306f\u81ea\u30d7\u30ed\u30bb\u30b9\u306e PID \u3092\u8fd4\u3057\u307e\u3059\uff0e Header file namespace sstd { int32 getpid (); } Usage input #include <sstd/sstd.hpp> int main (){ sstd :: printn ( sstd :: getpid () ); } output sstd::getpid() = 31669 Implementation Source: sstd/src/pid.cpp Header: sstd/src/pid.hpp Test: test/pid.hpp (Not implemented yet)","title":"pid"},{"location":"src/pid/#pid","text":"","title":"pid"},{"location":"src/pid/#abstract","text":"getpid returns the PID of its own process. getpid \u306f\u81ea\u30d7\u30ed\u30bb\u30b9\u306e PID \u3092\u8fd4\u3057\u307e\u3059\uff0e","title":"Abstract"},{"location":"src/pid/#header-file","text":"namespace sstd { int32 getpid (); }","title":"Header file"},{"location":"src/pid/#usage","text":"input #include <sstd/sstd.hpp> int main (){ sstd :: printn ( sstd :: getpid () ); } output sstd::getpid() = 31669","title":"Usage"},{"location":"src/pid/#implementation","text":"Source: sstd/src/pid.cpp Header: sstd/src/pid.hpp Test: test/pid.hpp (Not implemented yet)","title":"Implementation"},{"location":"src/rm/","text":"rm Abstract rm.cpp / rm.hpp contains the processing related to deletion. rm.cpp / rm.hpp \u306b\u306f\u30c7\u30a3\u30ec\u30af\u30c8\u30ea\u524a\u9664\u306b\u95a2\u3059\u308b\u51e6\u7406\u3092\u53ce\u9332\u3057\u307e\u3059\uff0e Header file namespace sstd { struct pathAndType { std :: string path ; char type ; // 'f': file, 'd': directory }; bool unlink ( const char * pPath ); // delete file bool unlink ( const std :: string & path ); // delete file bool rmdir ( const char * pPath ); // delete empty directory bool rmdir ( const std :: string & path ); // delete empty directory bool getAllPath ( std :: vector < struct sstd :: pathAndType >& ret , const char * pPath ); // get all path in the directory bool getAllPath ( std :: vector < std :: string >& ret , const char * pPath ); // get all path in the directory bool getAllFile ( std :: vector < std :: string >& ret , const char * pPath ); // get all file path in the directory bool getAllDir ( std :: vector < std :: string >& ret , const char * pPath ); // get all directory path in the directory bool rm ( const char * pPath ); // delete all under the pPath bool rm ( const std :: string & path ); // delete all under the path } Usage Removing directories recursively (\u30c7\u30a3\u30ec\u30af\u30c8\u30ea\u306e\u518d\u5e30\u7684\u306a\u524a\u9664) input #include <sstd/sstd.hpp> int main (){ printf ( \"--- mkdir --- \\n \" ); fflush ( stdout ); sstd :: mkdir ( \"./tmp/a/b/c\" ); sstd :: system ( \"tree ./tmp\" ); printf ( \" \\n\\n \" ); printf ( \"--- rm --- \\n \" ); fflush ( stdout ); sstd :: rm ( \"./tmp\" ); sstd :: system ( \"tree ./tmp\" ); } output --- mkdir --- ./tmp \u2514\u2500\u2500 a \u2514\u2500\u2500 b \u2514\u2500\u2500 c 3 directories, 0 files --- rm --- ./tmp [error opening dir] 0 directories, 0 files Implementation Source: sstd/src/rm.cpp Header: sstd/src/rm.hpp Test: test/rm.hpp (Not implemented yet)","title":"rm"},{"location":"src/rm/#rm","text":"","title":"rm"},{"location":"src/rm/#abstract","text":"rm.cpp / rm.hpp contains the processing related to deletion. rm.cpp / rm.hpp \u306b\u306f\u30c7\u30a3\u30ec\u30af\u30c8\u30ea\u524a\u9664\u306b\u95a2\u3059\u308b\u51e6\u7406\u3092\u53ce\u9332\u3057\u307e\u3059\uff0e","title":"Abstract"},{"location":"src/rm/#header-file","text":"namespace sstd { struct pathAndType { std :: string path ; char type ; // 'f': file, 'd': directory }; bool unlink ( const char * pPath ); // delete file bool unlink ( const std :: string & path ); // delete file bool rmdir ( const char * pPath ); // delete empty directory bool rmdir ( const std :: string & path ); // delete empty directory bool getAllPath ( std :: vector < struct sstd :: pathAndType >& ret , const char * pPath ); // get all path in the directory bool getAllPath ( std :: vector < std :: string >& ret , const char * pPath ); // get all path in the directory bool getAllFile ( std :: vector < std :: string >& ret , const char * pPath ); // get all file path in the directory bool getAllDir ( std :: vector < std :: string >& ret , const char * pPath ); // get all directory path in the directory bool rm ( const char * pPath ); // delete all under the pPath bool rm ( const std :: string & path ); // delete all under the path }","title":"Header file"},{"location":"src/rm/#usage","text":"","title":"Usage"},{"location":"src/rm/#removing-directories-recursively","text":"input #include <sstd/sstd.hpp> int main (){ printf ( \"--- mkdir --- \\n \" ); fflush ( stdout ); sstd :: mkdir ( \"./tmp/a/b/c\" ); sstd :: system ( \"tree ./tmp\" ); printf ( \" \\n\\n \" ); printf ( \"--- rm --- \\n \" ); fflush ( stdout ); sstd :: rm ( \"./tmp\" ); sstd :: system ( \"tree ./tmp\" ); } output --- mkdir --- ./tmp \u2514\u2500\u2500 a \u2514\u2500\u2500 b \u2514\u2500\u2500 c 3 directories, 0 files --- rm --- ./tmp [error opening dir] 0 directories, 0 files","title":"Removing directories recursively (\u30c7\u30a3\u30ec\u30af\u30c8\u30ea\u306e\u518d\u5e30\u7684\u306a\u524a\u9664)"},{"location":"src/rm/#implementation","text":"Source: sstd/src/rm.cpp Header: sstd/src/rm.hpp Test: test/rm.hpp (Not implemented yet)","title":"Implementation"},{"location":"src/sleep/","text":"sleep Abstract sleep waits for the specified time. sleep \u306f\u6307\u5b9a\u6642\u9593\u5f85\u6a5f\u3057\u307e\u3059\uff0e Header file namespace sstd { inline void sleep_hour ( uint rhs ); inline void sleep_min ( uint rhs ); inline void sleep_s ( uint rhs ); inline void sleep_ms ( uint rhs ); inline void sleep_us ( uint rhs ); inline void sleep_ns ( uint rhs ); } Usage input #include <sstd/sstd.hpp> int main (){ time_m timem ; sstd :: measureTime_start ( timem ); sstd :: sleep_s ( 1 ); sstd :: sleep_ms ( 100 ); sstd :: sleep_us ( 11 * 1000 ); sstd :: measureTime_stop_print ( timem ); return 0 ; } output -------------------------------- Execution time: 1. 113 sec -------------------------------- Implementation Header: sstd/src/sleep.hpp Test: test/sleep.hpp (Not implemented yet)","title":"sleep"},{"location":"src/sleep/#sleep","text":"","title":"sleep"},{"location":"src/sleep/#abstract","text":"sleep waits for the specified time. sleep \u306f\u6307\u5b9a\u6642\u9593\u5f85\u6a5f\u3057\u307e\u3059\uff0e","title":"Abstract"},{"location":"src/sleep/#header-file","text":"namespace sstd { inline void sleep_hour ( uint rhs ); inline void sleep_min ( uint rhs ); inline void sleep_s ( uint rhs ); inline void sleep_ms ( uint rhs ); inline void sleep_us ( uint rhs ); inline void sleep_ns ( uint rhs ); }","title":"Header file"},{"location":"src/sleep/#usage","text":"input #include <sstd/sstd.hpp> int main (){ time_m timem ; sstd :: measureTime_start ( timem ); sstd :: sleep_s ( 1 ); sstd :: sleep_ms ( 100 ); sstd :: sleep_us ( 11 * 1000 ); sstd :: measureTime_stop_print ( timem ); return 0 ; } output -------------------------------- Execution time: 1. 113 sec --------------------------------","title":"Usage"},{"location":"src/sleep/#implementation","text":"Header: sstd/src/sleep.hpp Test: test/sleep.hpp (Not implemented yet)","title":"Implementation"},{"location":"src/ssprintf/","text":"ssprintf Abstract ssprintf() is the std::string version of sprintf() . ssprintf() \u306f\uff0c sprintf() \u306e std::string \u7248\u3067\u3059\uff0e Header file namespace sstd { std :: string ssprintf ( const char * format , ...); } Usage input #include <sstd/sstd.hpp> int main (){ std :: string s = sstd :: ssprintf ( \"%s %d%d%d %03d\" , \"ABC\" , 0 , 1 , 2 , 3 ); sstd :: printn ( s ); } output s = \"ABC 012 003\" Implementation Source: sstd/src/ssprintf.cpp Header: sstd/src/ssprintf.hpp Test: test/ssprintf.hpp (Not implemented yet)","title":"ssprintf"},{"location":"src/ssprintf/#ssprintf","text":"","title":"ssprintf"},{"location":"src/ssprintf/#abstract","text":"ssprintf() is the std::string version of sprintf() . ssprintf() \u306f\uff0c sprintf() \u306e std::string \u7248\u3067\u3059\uff0e","title":"Abstract"},{"location":"src/ssprintf/#header-file","text":"namespace sstd { std :: string ssprintf ( const char * format , ...); }","title":"Header file"},{"location":"src/ssprintf/#usage","text":"input #include <sstd/sstd.hpp> int main (){ std :: string s = sstd :: ssprintf ( \"%s %d%d%d %03d\" , \"ABC\" , 0 , 1 , 2 , 3 ); sstd :: printn ( s ); } output s = \"ABC 012 003\"","title":"Usage"},{"location":"src/ssprintf/#implementation","text":"Source: sstd/src/ssprintf.cpp Header: sstd/src/ssprintf.hpp Test: test/ssprintf.hpp (Not implemented yet)","title":"Implementation"},{"location":"src/strEdit/","text":"strEdit Abstract strEdit.hpp / strEdit.cpp \u306f\uff0c\u6587\u5b57\u5217\u3092\u7de8\u96c6\u3059\u308b\u305f\u3081\u306e\u95a2\u6570\u3092\u53ce\u9332\u3057\u3066\u3044\u308b\uff0e Header file namespace sstd { std :: vector < uint8 > readAll_bin ( const char * pReadFile ); // read all of the file as a binary std :: vector < uint8 > readAll_bin ( const std :: string & readFile ); // read all of the file as a binary bool writeAll_bin ( const char * pWritePath , std :: vector < uint8 >& rhs ); bool writeAll_bin ( const std :: string & writePath , std :: vector < uint8 >& rhs ); std :: string readAll ( const char * pReadFile ); // readAll_str() std :: string readAll ( const std :: string & readFile ); // readAll_str() std :: string readAll_withoutBOM ( const char * pReadFile ); std :: string readAll_withoutBOM ( const std :: string & readFile ); std :: vector < std :: string > splitByLine ( const std :: string & str ); std :: vector < std :: string > split ( const char * str , const char X ); std :: vector < std :: string > split ( const std :: string & str , const char X ); // remove space or tab. std :: string lstrip ( const char * str ); // removing head spaces std :: string lstrip ( const std :: string & str ); // removing head spaces void lstrip_ow ( std :: string & str ); // removing head spaces. ow: overwrite std :: string rstrip ( const char * str ); // removing tail spaces std :: string rstrip ( const std :: string & str ); // removing tail spaces void rstrip_ow ( std :: string & str ); // removing tail spaces. ow: overwrite std :: string strip ( const char * str ); // removing head and tail tab and spaces std :: string strip ( const std :: string & str ); // removing head and tail tab and spaces void strip_ow ( std :: string & str ); // removing head and tail tab and spaces. ow: overwrite std :: vector < std :: string > strip ( const std :: vector < std :: string >& vec ); // -> strip(str) // removing head and tail spaces bool strcmp ( const char * str1 , const char * str2 ); bool strcmp ( const char * str1 , const std :: string & str2 ); bool strcmp ( const std :: string & str1 , const char * str2 ); bool strcmp ( const std :: string & str1 , const std :: string & str2 ); bool strIn ( const char * lhs , const char * rhs ); // is lhs in rhs ? (is rhs include lhs ?) bool strIn ( const char * lhs , const std :: string & rhs ); bool strIn ( const std :: string & lhs , const char * rhs ); bool strIn ( const std :: string & lhs , const std :: string & rhs ); } Functions Removing spaces and tabs. \u7a7a\u767d (\u534a\u89d2\u30b9\u30da\u30fc\u30b9) \u3068\u30bf\u30d6\u6587\u5b57\u306e\u9664\u53bb\uff0e Name Description lstrip Removing head spaces and tabs. \u6587\u5b57\u5217\u306e\u5148\u982d\u306b\u3042\u308b\u534a\u89d2\u30b9\u30da\u30fc\u30b9\u3068\u30bf\u30d6\u6587\u5b57\u3092\u9664\u53bb\u3057\u307e\u3059\uff0e lstrip_ow Removing head spaces and tabs. _ow means overwrite. \u6587\u5b57\u5217\u306e\u5148\u982d\u306b\u3042\u308b\u534a\u89d2\u30b9\u30da\u30fc\u30b9\u3068\u30bf\u30d6\u6587\u5b57\u3092\u9664\u53bb\u3057\u307e\u3059\uff0e _ow \u306f overwrite \u306e\u610f\u5473\u3067\uff0c\u5f15\u6570\u306b\u7d50\u679c\u3092\u4e0a\u66f8\u304d\u3057\u307e\u3059\uff0e rstrip Removing tail spaces and tabs. \u6587\u5b57\u5217\u306e\u672b\u5c3e\u306b\u3042\u308b\u534a\u89d2\u30b9\u30da\u30fc\u30b9\u3068\u30bf\u30d6\u6587\u5b57\u3092\u9664\u53bb\u3057\u307e\u3059\uff0e rstrip_ow Removing tail spaces and tabs. _ow means overwrite. \u6587\u5b57\u5217\u306e\u672b\u5c3e\u306b\u3042\u308b\u534a\u89d2\u30b9\u30da\u30fc\u30b9\u3068\u30bf\u30d6\u6587\u5b57\u3092\u9664\u53bb\u3057\u307e\u3059\uff0e _ow \u306f overwrite \u306e\u610f\u5473\u3067\uff0c\u5f15\u6570\u306b\u7d50\u679c\u3092\u4e0a\u66f8\u304d\u3057\u307e\u3059\uff0e strip Removing head and tail spaces and tabs. \u6587\u5b57\u5217\u306e\u5148\u982d\u3068\u672b\u5c3e\u306b\u3042\u308b\u534a\u89d2\u30b9\u30da\u30fc\u30b9\u3068\u30bf\u30d6\u6587\u5b57\u3092\u9664\u53bb\u3057\u307e\u3059\uff0e strip_ow Removing head and tail spaces and tabs. _ow means overwrite. \u6587\u5b57\u5217\u306e\u5148\u982d\u3068\u672b\u5c3e\u306b\u3042\u308b\u534a\u89d2\u30b9\u30da\u30fc\u30b9\u3068\u30bf\u30d6\u6587\u5b57\u3092\u9664\u53bb\u3057\u307e\u3059\uff0e _ow \u306f overwrite \u306e\u610f\u5473\u3067\uff0c\u5f15\u6570\u306b\u7d50\u679c\u3092\u4e0a\u66f8\u304d\u3057\u307e\u3059\uff0e String comparison \u6587\u5b57\u5217\u306e\u6bd4\u8f03\uff0e\u5f15\u6570\u306e\u578b\u306e\u9055\u3044\u306b\u3088\u308a\u8907\u6570\u5b9a\u7fa9\u3055\u308c\u3066\u3044\u308b\uff0e Name Description strcmp Comparing two strings given as input arguments and returns true if they are equal, false otherwise. \u5165\u529b\u5f15\u6570\u306b\u4e0e\u3048\u3089\u308c\u308b 2 \u3064\u306e\u6587\u5b57\u5217\u3092\u6bd4\u8f03\u3057\uff0c\u7b49\u3057\u3044\u5834\u5408\u306f true \u3092\uff0c\u305d\u308c\u4ee5\u5916\u306f false \u3092\u8fd4\u3059\uff0e Usage input #include <sstd/sstd.hpp> int main (){ std :: string s = \" abc \" ; sstd :: printn ( sstd :: lstrip ( s )); sstd :: printn ( sstd :: rstrip ( s )); sstd :: printn ( sstd :: strip ( s )); sstd :: strip_ow ( s ); sstd :: printn ( s ); } output sstd::lstrip(s) = \"abc \" sstd::rstrip(s) = \" abc\" sstd::strip(s) = \"abc\" s = \"abc\" Implementation Source: sstd/src/vector/strEdit.cpp Header: sstd/src/vector/strEdit.hpp Test: test/strEdit.hpp","title":"strEdit"},{"location":"src/strEdit/#stredit","text":"","title":"strEdit"},{"location":"src/strEdit/#abstract","text":"strEdit.hpp / strEdit.cpp \u306f\uff0c\u6587\u5b57\u5217\u3092\u7de8\u96c6\u3059\u308b\u305f\u3081\u306e\u95a2\u6570\u3092\u53ce\u9332\u3057\u3066\u3044\u308b\uff0e","title":"Abstract"},{"location":"src/strEdit/#header-file","text":"namespace sstd { std :: vector < uint8 > readAll_bin ( const char * pReadFile ); // read all of the file as a binary std :: vector < uint8 > readAll_bin ( const std :: string & readFile ); // read all of the file as a binary bool writeAll_bin ( const char * pWritePath , std :: vector < uint8 >& rhs ); bool writeAll_bin ( const std :: string & writePath , std :: vector < uint8 >& rhs ); std :: string readAll ( const char * pReadFile ); // readAll_str() std :: string readAll ( const std :: string & readFile ); // readAll_str() std :: string readAll_withoutBOM ( const char * pReadFile ); std :: string readAll_withoutBOM ( const std :: string & readFile ); std :: vector < std :: string > splitByLine ( const std :: string & str ); std :: vector < std :: string > split ( const char * str , const char X ); std :: vector < std :: string > split ( const std :: string & str , const char X ); // remove space or tab. std :: string lstrip ( const char * str ); // removing head spaces std :: string lstrip ( const std :: string & str ); // removing head spaces void lstrip_ow ( std :: string & str ); // removing head spaces. ow: overwrite std :: string rstrip ( const char * str ); // removing tail spaces std :: string rstrip ( const std :: string & str ); // removing tail spaces void rstrip_ow ( std :: string & str ); // removing tail spaces. ow: overwrite std :: string strip ( const char * str ); // removing head and tail tab and spaces std :: string strip ( const std :: string & str ); // removing head and tail tab and spaces void strip_ow ( std :: string & str ); // removing head and tail tab and spaces. ow: overwrite std :: vector < std :: string > strip ( const std :: vector < std :: string >& vec ); // -> strip(str) // removing head and tail spaces bool strcmp ( const char * str1 , const char * str2 ); bool strcmp ( const char * str1 , const std :: string & str2 ); bool strcmp ( const std :: string & str1 , const char * str2 ); bool strcmp ( const std :: string & str1 , const std :: string & str2 ); bool strIn ( const char * lhs , const char * rhs ); // is lhs in rhs ? (is rhs include lhs ?) bool strIn ( const char * lhs , const std :: string & rhs ); bool strIn ( const std :: string & lhs , const char * rhs ); bool strIn ( const std :: string & lhs , const std :: string & rhs ); }","title":"Header file"},{"location":"src/strEdit/#functions","text":"Removing spaces and tabs. \u7a7a\u767d (\u534a\u89d2\u30b9\u30da\u30fc\u30b9) \u3068\u30bf\u30d6\u6587\u5b57\u306e\u9664\u53bb\uff0e Name Description lstrip Removing head spaces and tabs. \u6587\u5b57\u5217\u306e\u5148\u982d\u306b\u3042\u308b\u534a\u89d2\u30b9\u30da\u30fc\u30b9\u3068\u30bf\u30d6\u6587\u5b57\u3092\u9664\u53bb\u3057\u307e\u3059\uff0e lstrip_ow Removing head spaces and tabs. _ow means overwrite. \u6587\u5b57\u5217\u306e\u5148\u982d\u306b\u3042\u308b\u534a\u89d2\u30b9\u30da\u30fc\u30b9\u3068\u30bf\u30d6\u6587\u5b57\u3092\u9664\u53bb\u3057\u307e\u3059\uff0e _ow \u306f overwrite \u306e\u610f\u5473\u3067\uff0c\u5f15\u6570\u306b\u7d50\u679c\u3092\u4e0a\u66f8\u304d\u3057\u307e\u3059\uff0e rstrip Removing tail spaces and tabs. \u6587\u5b57\u5217\u306e\u672b\u5c3e\u306b\u3042\u308b\u534a\u89d2\u30b9\u30da\u30fc\u30b9\u3068\u30bf\u30d6\u6587\u5b57\u3092\u9664\u53bb\u3057\u307e\u3059\uff0e rstrip_ow Removing tail spaces and tabs. _ow means overwrite. \u6587\u5b57\u5217\u306e\u672b\u5c3e\u306b\u3042\u308b\u534a\u89d2\u30b9\u30da\u30fc\u30b9\u3068\u30bf\u30d6\u6587\u5b57\u3092\u9664\u53bb\u3057\u307e\u3059\uff0e _ow \u306f overwrite \u306e\u610f\u5473\u3067\uff0c\u5f15\u6570\u306b\u7d50\u679c\u3092\u4e0a\u66f8\u304d\u3057\u307e\u3059\uff0e strip Removing head and tail spaces and tabs. \u6587\u5b57\u5217\u306e\u5148\u982d\u3068\u672b\u5c3e\u306b\u3042\u308b\u534a\u89d2\u30b9\u30da\u30fc\u30b9\u3068\u30bf\u30d6\u6587\u5b57\u3092\u9664\u53bb\u3057\u307e\u3059\uff0e strip_ow Removing head and tail spaces and tabs. _ow means overwrite. \u6587\u5b57\u5217\u306e\u5148\u982d\u3068\u672b\u5c3e\u306b\u3042\u308b\u534a\u89d2\u30b9\u30da\u30fc\u30b9\u3068\u30bf\u30d6\u6587\u5b57\u3092\u9664\u53bb\u3057\u307e\u3059\uff0e _ow \u306f overwrite \u306e\u610f\u5473\u3067\uff0c\u5f15\u6570\u306b\u7d50\u679c\u3092\u4e0a\u66f8\u304d\u3057\u307e\u3059\uff0e String comparison \u6587\u5b57\u5217\u306e\u6bd4\u8f03\uff0e\u5f15\u6570\u306e\u578b\u306e\u9055\u3044\u306b\u3088\u308a\u8907\u6570\u5b9a\u7fa9\u3055\u308c\u3066\u3044\u308b\uff0e Name Description strcmp Comparing two strings given as input arguments and returns true if they are equal, false otherwise. \u5165\u529b\u5f15\u6570\u306b\u4e0e\u3048\u3089\u308c\u308b 2 \u3064\u306e\u6587\u5b57\u5217\u3092\u6bd4\u8f03\u3057\uff0c\u7b49\u3057\u3044\u5834\u5408\u306f true \u3092\uff0c\u305d\u308c\u4ee5\u5916\u306f false \u3092\u8fd4\u3059\uff0e","title":"Functions"},{"location":"src/strEdit/#usage","text":"input #include <sstd/sstd.hpp> int main (){ std :: string s = \" abc \" ; sstd :: printn ( sstd :: lstrip ( s )); sstd :: printn ( sstd :: rstrip ( s )); sstd :: printn ( sstd :: strip ( s )); sstd :: strip_ow ( s ); sstd :: printn ( s ); } output sstd::lstrip(s) = \"abc \" sstd::rstrip(s) = \" abc\" sstd::strip(s) = \"abc\" s = \"abc\"","title":"Usage"},{"location":"src/strEdit/#implementation","text":"Source: sstd/src/vector/strEdit.cpp Header: sstd/src/vector/strEdit.hpp Test: test/strEdit.hpp","title":"Implementation"},{"location":"src/time/","text":"time Abstract struct tm \u3068 time_t (unixtime) \u304a\u3088\u3073\uff0c\u305d\u306e\u4ed6\u306e\u6642\u523b\u3092\u76f8\u4e92\u5909\u63db\u3059\u308b\uff0e Header file namespace sstd { struct tm time2tm ( time_t unixtime ); time_t tm2time ( struct tm & rhs ); struct tm timeGm2tmLocal ( time_t unixtime ); time_t tmLocal2timeGm ( struct tm & rhs ); std :: string time2str ( time_t unixtime ); std :: string tm2str ( struct tm & rhs ); double time2unixday ( time_t unixtime ); double tm2unixday ( struct tm & rhs ); time_t yday2time ( uint year , uint yday ); struct tm yday2tm ( uint year , uint yday ); struct timeval getTimeval (); double unixtime2JulianDate ( time_t unixtime ); double Julius_T ( time_t unixtime ); double JulianDate2Julius_T ( double JulianDate ); double TJuliusD ( time_t unixtime ); double JulianDate2TJuliusD ( double JulianDate ); void print ( const struct tm & rhs ); void for_printn ( const struct tm & rhs ); } Usage input #include <time.h> // for time() #include <sstd/sstd.hpp> int main (){ time_t unixtime_UTC ; time ( & unixtime_UTC ); // get current unixtime (UTC) struct tm tm_UTC = sstd :: time2tm ( unixtime_UTC ); struct tm tm_Local = sstd :: timeGm2tmLocal ( unixtime_UTC ); sstd :: printn ( unixtime_UTC ); sstd :: printn ( tm_UTC ); sstd :: printn ( tm_Local ); } output Below is the result on Japanese local time (UTC+9hour). unixtime_UTC = 1609228877 tm_UTC = 2020-12-29 08:01:17 tm_Local = 2020-12-29 17:01:17 Appendix struct tm { int tm_sec ; /* \u79d2 [0-61] \u6700\u59272\u79d2\u307e\u3067\u306e\u3046\u308b\u3046\u79d2\u3092\u8003\u616e */ int tm_min ; /* \u5206 [0-59] */ int tm_hour ; /* \u6642 [0-23] */ int tm_mday ; /* \u65e5 [1-31] */ int tm_mon ; /* \u6708 [0-11] 0\u304b\u3089\u59cb\u307e\u308b\u3053\u3068\u306b\u6ce8\u610f */ int tm_year ; /* \u5e74 [1900\u304b\u3089\u306e\u7d4c\u904e\u5e74\u6570] */ int tm_wday ; /* \u66dc\u65e5 [0:\u65e5 1:\u6708 ... 6:\u571f] */ int tm_yday ; /* \u5e74\u5185\u306e\u901a\u3057\u65e5\u6570 [0-365] 0\u304b\u3089\u59cb\u307e\u308b\u3053\u3068\u306b\u6ce8\u610f*/ int tm_isdst ; /* \u590f\u6642\u9593\u304c\u7121\u52b9\u3067\u3042\u308c\u3070 0 */ }; ref: localtime - \u521d\u5fc3\u8005\u306e\u305f\u3081\u306e\u30dd\u30a4\u30f3\u30c8\u5b66\u7fd2 C \u8a00\u8a9e Implementation Source: sstd/src/time.cpp Header: sstd/src/time.hpp Test: test/time.hpp (Not implemented yet)","title":"time"},{"location":"src/time/#time","text":"","title":"time"},{"location":"src/time/#abstract","text":"struct tm \u3068 time_t (unixtime) \u304a\u3088\u3073\uff0c\u305d\u306e\u4ed6\u306e\u6642\u523b\u3092\u76f8\u4e92\u5909\u63db\u3059\u308b\uff0e","title":"Abstract"},{"location":"src/time/#header-file","text":"namespace sstd { struct tm time2tm ( time_t unixtime ); time_t tm2time ( struct tm & rhs ); struct tm timeGm2tmLocal ( time_t unixtime ); time_t tmLocal2timeGm ( struct tm & rhs ); std :: string time2str ( time_t unixtime ); std :: string tm2str ( struct tm & rhs ); double time2unixday ( time_t unixtime ); double tm2unixday ( struct tm & rhs ); time_t yday2time ( uint year , uint yday ); struct tm yday2tm ( uint year , uint yday ); struct timeval getTimeval (); double unixtime2JulianDate ( time_t unixtime ); double Julius_T ( time_t unixtime ); double JulianDate2Julius_T ( double JulianDate ); double TJuliusD ( time_t unixtime ); double JulianDate2TJuliusD ( double JulianDate ); void print ( const struct tm & rhs ); void for_printn ( const struct tm & rhs ); }","title":"Header file"},{"location":"src/time/#usage","text":"input #include <time.h> // for time() #include <sstd/sstd.hpp> int main (){ time_t unixtime_UTC ; time ( & unixtime_UTC ); // get current unixtime (UTC) struct tm tm_UTC = sstd :: time2tm ( unixtime_UTC ); struct tm tm_Local = sstd :: timeGm2tmLocal ( unixtime_UTC ); sstd :: printn ( unixtime_UTC ); sstd :: printn ( tm_UTC ); sstd :: printn ( tm_Local ); } output Below is the result on Japanese local time (UTC+9hour). unixtime_UTC = 1609228877 tm_UTC = 2020-12-29 08:01:17 tm_Local = 2020-12-29 17:01:17","title":"Usage"},{"location":"src/time/#appendix","text":"struct tm { int tm_sec ; /* \u79d2 [0-61] \u6700\u59272\u79d2\u307e\u3067\u306e\u3046\u308b\u3046\u79d2\u3092\u8003\u616e */ int tm_min ; /* \u5206 [0-59] */ int tm_hour ; /* \u6642 [0-23] */ int tm_mday ; /* \u65e5 [1-31] */ int tm_mon ; /* \u6708 [0-11] 0\u304b\u3089\u59cb\u307e\u308b\u3053\u3068\u306b\u6ce8\u610f */ int tm_year ; /* \u5e74 [1900\u304b\u3089\u306e\u7d4c\u904e\u5e74\u6570] */ int tm_wday ; /* \u66dc\u65e5 [0:\u65e5 1:\u6708 ... 6:\u571f] */ int tm_yday ; /* \u5e74\u5185\u306e\u901a\u3057\u65e5\u6570 [0-365] 0\u304b\u3089\u59cb\u307e\u308b\u3053\u3068\u306b\u6ce8\u610f*/ int tm_isdst ; /* \u590f\u6642\u9593\u304c\u7121\u52b9\u3067\u3042\u308c\u3070 0 */ }; ref: localtime - \u521d\u5fc3\u8005\u306e\u305f\u3081\u306e\u30dd\u30a4\u30f3\u30c8\u5b66\u7fd2 C \u8a00\u8a9e","title":"Appendix"},{"location":"src/time/#implementation","text":"Source: sstd/src/time.cpp Header: sstd/src/time.hpp Test: test/time.hpp (Not implemented yet)","title":"Implementation"},{"location":"src/typeDef.h/","text":"typeDef.h Abstract Type definitions on SSTD. These definitions are read by #include <sstd/sstd.hpp> . SSTD \u306b\u304a\u3051\u308b\u578b\u306e\u5b9a\u7fa9\uff0e #include <sstd/sstd.hpp> \u306b\u3088\u308a\u5b9a\u7fa9\u304c\u8aad\u307f\u8fbc\u307e\u308c\u308b\uff0e Header file #pragma once #ifdef _WIN32 typedef unsigned char uchar ; typedef __int8 int8 ; typedef __int16 int16 ; typedef __int32 int32 ; typedef __int64 int64 ; typedef unsigned __int8 uint8 ; typedef unsigned __int16 uint16 ; typedef unsigned __int32 uint32 ; typedef unsigned __int64 uint64 ; #else #include <stdint.h> // intXX_t, uintXX_t \u304c\u5b9a\u7fa9\u3055\u308c\u3066\u3044\u308b typedef unsigned char uchar ; typedef int8_t int8 ; typedef int16_t int16 ; typedef int32_t int32 ; typedef int64_t int64 ; typedef uint8_t uint8 ; typedef uint16_t uint16 ; typedef uint32_t uint32 ; typedef uint64_t uint64 ; #endif #ifndef uint typedef unsigned int uint ; #endif Implementation Header: sstd/src/typeDef.hpp","title":"typeDef.h"},{"location":"src/typeDef.h/#typedefh","text":"","title":"typeDef.h"},{"location":"src/typeDef.h/#abstract","text":"Type definitions on SSTD. These definitions are read by #include <sstd/sstd.hpp> . SSTD \u306b\u304a\u3051\u308b\u578b\u306e\u5b9a\u7fa9\uff0e #include <sstd/sstd.hpp> \u306b\u3088\u308a\u5b9a\u7fa9\u304c\u8aad\u307f\u8fbc\u307e\u308c\u308b\uff0e","title":"Abstract"},{"location":"src/typeDef.h/#header-file","text":"#pragma once #ifdef _WIN32 typedef unsigned char uchar ; typedef __int8 int8 ; typedef __int16 int16 ; typedef __int32 int32 ; typedef __int64 int64 ; typedef unsigned __int8 uint8 ; typedef unsigned __int16 uint16 ; typedef unsigned __int32 uint32 ; typedef unsigned __int64 uint64 ; #else #include <stdint.h> // intXX_t, uintXX_t \u304c\u5b9a\u7fa9\u3055\u308c\u3066\u3044\u308b typedef unsigned char uchar ; typedef int8_t int8 ; typedef int16_t int16 ; typedef int32_t int32 ; typedef int64_t int64 ; typedef uint8_t uint8 ; typedef uint16_t uint16 ; typedef uint32_t uint32 ; typedef uint64_t uint64 ; #endif #ifndef uint typedef unsigned int uint ; #endif","title":"Header file"},{"location":"src/typeDef.h/#implementation","text":"Header: sstd/src/typeDef.hpp","title":"Implementation"},{"location":"src/matrix/mat_colMajor/","text":"mat_c (Col-major) Abstract mat_c is a column-major matrix container. mat_c \u306f\u5217\u512a\u5148\u306e\u884c\u5217\u30b3\u30f3\u30c6\u30ca\u3067\u3059. Header file namespace sstd { template < typename T > class mat_c ; template < typename T > void copy ( sstd :: mat_c < T >& lhs , const sstd :: mat_c < T >& rhs ); template < typename T > void move ( sstd :: mat_c < T >& lhs , sstd :: mat_c < T >& rhs ); template < typename T > void swap ( sstd :: mat_c < T >& lhs , sstd :: mat_c < T >& rhs ); template < typename T > void eye ( sstd :: mat_c < T >& rhs ); template < typename T > void ones ( sstd :: mat_c < T >& rhs ); template < typename T > void zeros ( sstd :: mat_c < T >& Mat ); template < typename T > sstd :: mat_c < T > Tr ( const sstd :: mat_c < T >& rhs ); // lhs = Transpose(rhs) template < typename T > void Tr_myself ( sstd :: mat_c < T >& rhs ); // Transpose(rhs) } template < typename T > class sstd :: mat_c { private : T * _pMatT ; uint _rows ; // row size uint _cols ; // column size uint _size ; // number of element public : inline mat_c (); inline mat_c ( const std :: initializer_list < std :: initializer_list < T >>& rhs ); // called by \"sstd::mat_c<T> mat = {{1, 2, 3}, {4, 5, 6}, {7, 8, 9}};\". inline mat_c ( const class mat_c & rhs ); // called by \"sstd::mat_c<T> buf1(N, N); sstd::mat_c<T> buf2(buf1);\" inline mat_c ( class mat_c && rhs ); // called by \"return std::move(rhs);\" or \"std::swap(buf1, buf2)\". inline mat_c ( const uint & rowSize , const uint & colSize ); inline ~ mat_c (); // Read only: R inline const uint rows () const ; inline const uint cols () const ; inline const uint size () const ; // Read and Write: RW inline T *& pMatT_RW (); inline uint & rows_RW (); inline uint & cols_RW (); inline uint & size_RW (); class mat_c & operator = ( const class mat_c & rhs ); // called by \"lhs = sstd::mat_c<T>(3, 3);\". inline T & operator []( const uint i ); inline T & operator []( const int i ); inline const T & operator []( const uint i ) const ; inline const T & operator []( const int i ) const ; inline T & operator ()( const uint p , const uint q ); inline T & operator ()( const int p , const uint q ); inline T & operator ()( const uint p , const int q ); inline T & operator ()( const int p , const int q ); inline const T & operator ()( const uint p , const uint q ) const ; inline const T & operator ()( const int p , const uint q ) const ; inline const T & operator ()( const uint p , const int q ) const ; inline const T & operator ()( const int p , const int q ) const ; // for element operations (elements multiplication) inline sstd :: mat_c_elements < T > operator ()(); inline sstd :: mat_c_elements < T > vec (); }; Usage Init input #include <sstd/sstd.hpp> int main (){ sstd :: mat_c < double > m = {{ 1 , 2 }, { 3 , 4 }}; sstd :: mat_c < double > m_eye ( 2 , 2 ); sstd :: eye ( m_eye ); sstd :: mat_c < double > m_ones ( 2 , 2 ); sstd :: ones ( m_ones ); sstd :: mat_c < double > m_zeros ( 2 , 2 ); sstd :: zeros ( m_zeros ); sstd :: printn ( m ); printf ( \" \\n \" ); sstd :: printn ( m_eye ); printf ( \" \\n \" ); sstd :: printn ( m_ones ); printf ( \" \\n \" ); sstd :: printn ( m_zeros ); } output m = 1.000000 2.000000 3.000000 4.000000 m_eye = 1.000000 0.000000 0.000000 1.000000 m_ones = 1.000000 1.000000 1.000000 1.000000 m_zeros = 0.000000 0.000000 0.000000 0.000000 Access to elements As a matrix input #include <sstd/sstd.hpp> int main (){ sstd :: mat_c < double > m ( 2 , 2 ); uint i = 0 ; for ( uint c = 0 ; c < m . cols (); ++ c ){ for ( uint r = 0 ; r < m . rows (); ++ r ){ m ( r , c ) = i ; ++ i ; } } sstd :: printn ( m ); } output m = 0.000000 2.000000 1.000000 3.000000 As a vector input #include <sstd/sstd.hpp> int main (){ sstd :: mat_c < double > m ( 2 , 2 ); for ( uint i = 0 ; i < m . size (); ++ i ){ m [ i ] = i ; } sstd :: printn ( m ); } output m = 0.000000 2.000000 1.000000 3.000000 Tr (Transpose) input #include <sstd/sstd.hpp> int main (){ sstd :: mat_c < double > m1 = {{ 1 , 2 }, { 3 , 4 }}; sstd :: printn ( m1 ); sstd :: printn ( sstd :: Tr ( m1 ) ); printf ( \" \\n \" ); sstd :: mat_c < double > m2 = {{ 1 , 2 }, { 3 , 4 }}; sstd :: printn ( m2 ); sstd :: Tr_myself ( m2 ); sstd :: printn ( m2 ); } output m1 = 1.000000 2.000000 3.000000 4.000000 sstd::Tr( m1 ) = 1.000000 3.000000 2.000000 4.000000 m2 = 1.000000 2.000000 3.000000 4.000000 m2 = 1.000000 3.000000 2.000000 4.000000 Operator matrix \u00d7 scalar input #include <sstd/sstd.hpp> int main (){ sstd :: mat_c < double > m ( 2 , 2 ); for ( uint i = 0 ; i < m . size (); ++ i ){ m [ i ] = i ; } sstd :: printn ( m ); printf ( \" \\n \" ); sstd :: printn ( m * 2 ); } output m = 0.000000 2.000000 1.000000 3.000000 m * 2 = 0.000000 4.000000 2.000000 6.000000 matrix \u00d7 matrix input #include <sstd/sstd.hpp> int main (){ sstd :: mat_c < double > m1 ( 2 , 2 ); for ( uint i = 0 ; i < m1 . size (); ++ i ){ m1 [ i ] = i ; } sstd :: mat_c < double > m2 ( 2 , 2 ); for ( uint i = 0 ; i < m2 . size (); ++ i ){ m2 [ i ] = i + 1 ; } sstd :: printn ( m1 ); printf ( \" \\n \" ); sstd :: printn ( m2 ); printf ( \" \\n \" ); sstd :: printn ( m1 * m2 ); } output m1 = 0.000000 2.000000 1.000000 3.000000 m2 = 1.000000 3.000000 2.000000 4.000000 m1 * m2 = 4.000000 8.000000 7.000000 15.000000 matrix (as a vector) \u00d7 matrix (as a vector) input #include <sstd/sstd.hpp> int main (){ sstd :: mat_c < double > m1 ( 2 , 2 ); for ( uint i = 0 ; i < m1 . size (); ++ i ){ m1 [ i ] = i ; } sstd :: mat_c < double > m2 ( 2 , 2 ); for ( uint i = 0 ; i < m2 . size (); ++ i ){ m2 [ i ] = i + 1 ; } sstd :: printn ( m1 ); printf ( \" \\n \" ); sstd :: printn ( m2 ); printf ( \" \\n \" ); sstd :: printn ( m1 () * m2 () ); } output m1 = 0.000000 2.000000 1.000000 3.000000 m2 = 1.000000 3.000000 2.000000 4.000000 m1() * m2() = 0.000000 6.000000 2.000000 12.000000 Implementation Source: sstd/src/matrixContainer_rowMajor/mat_c.cpp Header: sstd/src/matrixContainer_rowMajor/mat_c.hpp Test: test/mat_c.hpp (Not implemented yet)","title":"mat_c (Col-major)"},{"location":"src/matrix/mat_colMajor/#mat_c-col-major","text":"","title":"mat_c (Col-major)"},{"location":"src/matrix/mat_colMajor/#abstract","text":"mat_c is a column-major matrix container. mat_c \u306f\u5217\u512a\u5148\u306e\u884c\u5217\u30b3\u30f3\u30c6\u30ca\u3067\u3059.","title":"Abstract"},{"location":"src/matrix/mat_colMajor/#header-file","text":"namespace sstd { template < typename T > class mat_c ; template < typename T > void copy ( sstd :: mat_c < T >& lhs , const sstd :: mat_c < T >& rhs ); template < typename T > void move ( sstd :: mat_c < T >& lhs , sstd :: mat_c < T >& rhs ); template < typename T > void swap ( sstd :: mat_c < T >& lhs , sstd :: mat_c < T >& rhs ); template < typename T > void eye ( sstd :: mat_c < T >& rhs ); template < typename T > void ones ( sstd :: mat_c < T >& rhs ); template < typename T > void zeros ( sstd :: mat_c < T >& Mat ); template < typename T > sstd :: mat_c < T > Tr ( const sstd :: mat_c < T >& rhs ); // lhs = Transpose(rhs) template < typename T > void Tr_myself ( sstd :: mat_c < T >& rhs ); // Transpose(rhs) } template < typename T > class sstd :: mat_c { private : T * _pMatT ; uint _rows ; // row size uint _cols ; // column size uint _size ; // number of element public : inline mat_c (); inline mat_c ( const std :: initializer_list < std :: initializer_list < T >>& rhs ); // called by \"sstd::mat_c<T> mat = {{1, 2, 3}, {4, 5, 6}, {7, 8, 9}};\". inline mat_c ( const class mat_c & rhs ); // called by \"sstd::mat_c<T> buf1(N, N); sstd::mat_c<T> buf2(buf1);\" inline mat_c ( class mat_c && rhs ); // called by \"return std::move(rhs);\" or \"std::swap(buf1, buf2)\". inline mat_c ( const uint & rowSize , const uint & colSize ); inline ~ mat_c (); // Read only: R inline const uint rows () const ; inline const uint cols () const ; inline const uint size () const ; // Read and Write: RW inline T *& pMatT_RW (); inline uint & rows_RW (); inline uint & cols_RW (); inline uint & size_RW (); class mat_c & operator = ( const class mat_c & rhs ); // called by \"lhs = sstd::mat_c<T>(3, 3);\". inline T & operator []( const uint i ); inline T & operator []( const int i ); inline const T & operator []( const uint i ) const ; inline const T & operator []( const int i ) const ; inline T & operator ()( const uint p , const uint q ); inline T & operator ()( const int p , const uint q ); inline T & operator ()( const uint p , const int q ); inline T & operator ()( const int p , const int q ); inline const T & operator ()( const uint p , const uint q ) const ; inline const T & operator ()( const int p , const uint q ) const ; inline const T & operator ()( const uint p , const int q ) const ; inline const T & operator ()( const int p , const int q ) const ; // for element operations (elements multiplication) inline sstd :: mat_c_elements < T > operator ()(); inline sstd :: mat_c_elements < T > vec (); };","title":"Header file"},{"location":"src/matrix/mat_colMajor/#usage","text":"","title":"Usage"},{"location":"src/matrix/mat_colMajor/#init","text":"input #include <sstd/sstd.hpp> int main (){ sstd :: mat_c < double > m = {{ 1 , 2 }, { 3 , 4 }}; sstd :: mat_c < double > m_eye ( 2 , 2 ); sstd :: eye ( m_eye ); sstd :: mat_c < double > m_ones ( 2 , 2 ); sstd :: ones ( m_ones ); sstd :: mat_c < double > m_zeros ( 2 , 2 ); sstd :: zeros ( m_zeros ); sstd :: printn ( m ); printf ( \" \\n \" ); sstd :: printn ( m_eye ); printf ( \" \\n \" ); sstd :: printn ( m_ones ); printf ( \" \\n \" ); sstd :: printn ( m_zeros ); } output m = 1.000000 2.000000 3.000000 4.000000 m_eye = 1.000000 0.000000 0.000000 1.000000 m_ones = 1.000000 1.000000 1.000000 1.000000 m_zeros = 0.000000 0.000000 0.000000 0.000000","title":"Init"},{"location":"src/matrix/mat_colMajor/#access-to-elements","text":"","title":"Access to elements"},{"location":"src/matrix/mat_colMajor/#as-a-matrix","text":"input #include <sstd/sstd.hpp> int main (){ sstd :: mat_c < double > m ( 2 , 2 ); uint i = 0 ; for ( uint c = 0 ; c < m . cols (); ++ c ){ for ( uint r = 0 ; r < m . rows (); ++ r ){ m ( r , c ) = i ; ++ i ; } } sstd :: printn ( m ); } output m = 0.000000 2.000000 1.000000 3.000000","title":"As a matrix"},{"location":"src/matrix/mat_colMajor/#as-a-vector","text":"input #include <sstd/sstd.hpp> int main (){ sstd :: mat_c < double > m ( 2 , 2 ); for ( uint i = 0 ; i < m . size (); ++ i ){ m [ i ] = i ; } sstd :: printn ( m ); } output m = 0.000000 2.000000 1.000000 3.000000","title":"As a vector"},{"location":"src/matrix/mat_colMajor/#tr-transpose","text":"input #include <sstd/sstd.hpp> int main (){ sstd :: mat_c < double > m1 = {{ 1 , 2 }, { 3 , 4 }}; sstd :: printn ( m1 ); sstd :: printn ( sstd :: Tr ( m1 ) ); printf ( \" \\n \" ); sstd :: mat_c < double > m2 = {{ 1 , 2 }, { 3 , 4 }}; sstd :: printn ( m2 ); sstd :: Tr_myself ( m2 ); sstd :: printn ( m2 ); } output m1 = 1.000000 2.000000 3.000000 4.000000 sstd::Tr( m1 ) = 1.000000 3.000000 2.000000 4.000000 m2 = 1.000000 2.000000 3.000000 4.000000 m2 = 1.000000 3.000000 2.000000 4.000000","title":"Tr (Transpose)"},{"location":"src/matrix/mat_colMajor/#operator","text":"","title":"Operator"},{"location":"src/matrix/mat_colMajor/#matrix-scalar","text":"input #include <sstd/sstd.hpp> int main (){ sstd :: mat_c < double > m ( 2 , 2 ); for ( uint i = 0 ; i < m . size (); ++ i ){ m [ i ] = i ; } sstd :: printn ( m ); printf ( \" \\n \" ); sstd :: printn ( m * 2 ); } output m = 0.000000 2.000000 1.000000 3.000000 m * 2 = 0.000000 4.000000 2.000000 6.000000","title":"matrix \u00d7 scalar"},{"location":"src/matrix/mat_colMajor/#matrix-matrix","text":"input #include <sstd/sstd.hpp> int main (){ sstd :: mat_c < double > m1 ( 2 , 2 ); for ( uint i = 0 ; i < m1 . size (); ++ i ){ m1 [ i ] = i ; } sstd :: mat_c < double > m2 ( 2 , 2 ); for ( uint i = 0 ; i < m2 . size (); ++ i ){ m2 [ i ] = i + 1 ; } sstd :: printn ( m1 ); printf ( \" \\n \" ); sstd :: printn ( m2 ); printf ( \" \\n \" ); sstd :: printn ( m1 * m2 ); } output m1 = 0.000000 2.000000 1.000000 3.000000 m2 = 1.000000 3.000000 2.000000 4.000000 m1 * m2 = 4.000000 8.000000 7.000000 15.000000","title":"matrix \u00d7 matrix"},{"location":"src/matrix/mat_colMajor/#matrix-as-a-vector-matrix-as-a-vector","text":"input #include <sstd/sstd.hpp> int main (){ sstd :: mat_c < double > m1 ( 2 , 2 ); for ( uint i = 0 ; i < m1 . size (); ++ i ){ m1 [ i ] = i ; } sstd :: mat_c < double > m2 ( 2 , 2 ); for ( uint i = 0 ; i < m2 . size (); ++ i ){ m2 [ i ] = i + 1 ; } sstd :: printn ( m1 ); printf ( \" \\n \" ); sstd :: printn ( m2 ); printf ( \" \\n \" ); sstd :: printn ( m1 () * m2 () ); } output m1 = 0.000000 2.000000 1.000000 3.000000 m2 = 1.000000 3.000000 2.000000 4.000000 m1() * m2() = 0.000000 6.000000 2.000000 12.000000","title":"matrix (as a vector) \u00d7 matrix (as a vector)"},{"location":"src/matrix/mat_colMajor/#implementation","text":"Source: sstd/src/matrixContainer_rowMajor/mat_c.cpp Header: sstd/src/matrixContainer_rowMajor/mat_c.hpp Test: test/mat_c.hpp (Not implemented yet)","title":"Implementation"},{"location":"src/matrix/mat_rowMajor/","text":"mat_r (Row-major) Abstract mat_r is a row-major matrix container. mat_r \u306f\u884c\u512a\u5148\u306e\u884c\u5217\u30b3\u30f3\u30c6\u30ca\u3067\u3059. Header file namespace sstd { template < typename T > class mat_r ; template < typename T > void copy ( sstd :: mat_r < T >& lhs , const sstd :: mat_r < T >& rhs ); template < typename T > void move ( sstd :: mat_r < T >& lhs , sstd :: mat_r < T >& rhs ); template < typename T > void swap ( sstd :: mat_r < T >& lhs , sstd :: mat_r < T >& rhs ); template < typename T > void eye ( sstd :: mat_r < T >& rhs ); template < typename T > void ones ( sstd :: mat_r < T >& rhs ); template < typename T > void zeros ( sstd :: mat_r < T >& Mat ); template < typename T > sstd :: mat_r < T > Tr ( const sstd :: mat_r < T >& rhs ); // lhs = Transpose(rhs) template < typename T > void Tr_myself ( sstd :: mat_r < T >& rhs ); // Transpose(rhs) } template < typename T > class sstd :: mat_r { private : T * _pMatT ; uint _rows ; // row size uint _cols ; // column size uint _size ; // number of element public : inline mat_r (); inline mat_r ( const std :: initializer_list < std :: initializer_list < T >>& rhs ); // called by \"sstd::mat_r<T> mat = {{1, 2, 3}, {4, 5, 6}, {7, 8, 9}};\". inline mat_r ( const class mat_r & rhs ); // called by \"sstd::mat_r<T> buf1(N, N); sstd::mat_r<T> buf2(buf1);\" inline mat_r ( class mat_r && rhs ); // called by \"return std::move(rhs);\" or \"std::swap(buf1, buf2)\". inline mat_r ( const uint & rowSize , const uint & colSize ); inline ~ mat_r (); // Read only: R inline const uint rows () const ; inline const uint cols () const ; inline const uint size () const ; // Read and Write: RW inline T *& pMatT_RW (); inline uint & rows_RW (); inline uint & cols_RW (); inline uint & size_RW (); class mat_r & operator = ( const class mat_r & rhs ); // called by \"lhs = sstd::mat_r<T>(3, 3);\". inline T & operator []( const uint i ); inline T & operator []( const int i ); inline const T & operator []( const uint i ) const ; inline const T & operator []( const int i ) const ; inline T & operator ()( const uint p , const uint q ); inline T & operator ()( const int p , const uint q ); inline T & operator ()( const uint p , const int q ); inline T & operator ()( const int p , const int q ); inline const T & operator ()( const uint p , const uint q ) const ; inline const T & operator ()( const int p , const uint q ) const ; inline const T & operator ()( const uint p , const int q ) const ; inline const T & operator ()( const int p , const int q ) const ; // for element operations (elements multiplication) inline sstd :: mat_r_elements < T > operator ()(); inline sstd :: mat_r_elements < T > vec (); }; Usage Init input #include <sstd/sstd.hpp> int main (){ sstd :: mat_r < double > m = {{ 1 , 2 }, { 3 , 4 }}; sstd :: mat_r < double > m_eye ( 2 , 2 ); sstd :: eye ( m_eye ); sstd :: mat_r < double > m_ones ( 2 , 2 ); sstd :: ones ( m_ones ); sstd :: mat_r < double > m_zeros ( 2 , 2 ); sstd :: zeros ( m_zeros ); sstd :: printn ( m ); printf ( \" \\n \" ); sstd :: printn ( m_eye ); printf ( \" \\n \" ); sstd :: printn ( m_ones ); printf ( \" \\n \" ); sstd :: printn ( m_zeros ); } output m = 1.000000 2.000000 3.000000 4.000000 m_eye = 1.000000 0.000000 0.000000 1.000000 m_ones = 1.000000 1.000000 1.000000 1.000000 m_zeros = 0.000000 0.000000 0.000000 0.000000 Access to elements As a matrix input #include <sstd/sstd.hpp> int main (){ sstd :: mat_r < double > m ( 2 , 2 ); uint i = 0 ; for ( uint r = 0 ; r < m . rows (); ++ r ){ for ( uint c = 0 ; c < m . cols (); ++ c ){ m ( r , c ) = i ; ++ i ; } } sstd :: printn ( m ); } output m = 0.000000 1.000000 2.000000 3.000000 As a vector input #include <sstd/sstd.hpp> int main (){ sstd :: mat_r < double > m ( 2 , 2 ); for ( uint i = 0 ; i < m . size (); ++ i ){ m [ i ] = i ; } sstd :: printn ( m ); } output m = 0.000000 1.000000 2.000000 3.000000 Tr (Transpose) input #include <sstd/sstd.hpp> int main (){ sstd :: mat_r < double > m1 = {{ 1 , 2 }, { 3 , 4 }}; sstd :: printn ( m1 ); sstd :: printn ( sstd :: Tr ( m1 ) ); printf ( \" \\n \" ); sstd :: mat_r < double > m2 = {{ 1 , 2 }, { 3 , 4 }}; sstd :: printn ( m2 ); sstd :: Tr_myself ( m2 ); sstd :: printn ( m2 ); } output m1 = 1.000000 2.000000 3.000000 4.000000 sstd::Tr( m1 ) = 1.000000 3.000000 2.000000 4.000000 m2 = 1.000000 2.000000 3.000000 4.000000 m2 = 1.000000 3.000000 2.000000 4.000000 Operator matrix \u00d7 scalar input #include <sstd/sstd.hpp> int main (){ sstd :: mat_r < double > m ( 2 , 2 ); for ( uint i = 0 ; i < m . size (); ++ i ){ m [ i ] = i ; } sstd :: printn ( m ); printf ( \" \\n \" ); sstd :: printn ( m * 2 ); } output m = 0.000000 1.000000 2.000000 3.000000 m * 2 = 0.000000 2.000000 4.000000 6.000000 matrix \u00d7 matrix input #include <sstd/sstd.hpp> int main (){ sstd :: mat_r < double > m1 ( 2 , 2 ); for ( uint i = 0 ; i < m1 . size (); ++ i ){ m1 [ i ] = i ; } sstd :: mat_r < double > m2 ( 2 , 2 ); for ( uint i = 0 ; i < m2 . size (); ++ i ){ m2 [ i ] = i + 1 ; } sstd :: printn ( m1 ); printf ( \" \\n \" ); sstd :: printn ( m2 ); printf ( \" \\n \" ); sstd :: printn ( m1 * m2 ); } output m1 = 0.000000 1.000000 2.000000 3.000000 m2 = 1.000000 2.000000 3.000000 4.000000 m1 * m2 = 3.000000 4.000000 11.000000 16.000000 matrix (as a vector) \u00d7 matrix (as a vector) input #include <sstd/sstd.hpp> int main (){ sstd :: mat_r < double > m1 ( 2 , 2 ); for ( uint i = 0 ; i < m1 . size (); ++ i ){ m1 [ i ] = i ; } sstd :: mat_r < double > m2 ( 2 , 2 ); for ( uint i = 0 ; i < m2 . size (); ++ i ){ m2 [ i ] = i + 1 ; } sstd :: printn ( m1 ); printf ( \" \\n \" ); sstd :: printn ( m2 ); printf ( \" \\n \" ); sstd :: printn ( m1 () * m2 () ); } output m1 = 0.000000 1.000000 2.000000 3.000000 m2 = 1.000000 2.000000 3.000000 4.000000 m1() * m2() = 0.000000 2.000000 6.000000 12.000000 Implementation Source: sstd/src/matrixContainer_rowMajor/mat_r.cpp Header: sstd/src/matrixContainer_rowMajor/mat_r.hpp Test: test/mat_r.hpp (Not implemented yet)","title":"mat_r (Row-major)"},{"location":"src/matrix/mat_rowMajor/#mat_r-row-major","text":"","title":"mat_r (Row-major)"},{"location":"src/matrix/mat_rowMajor/#abstract","text":"mat_r is a row-major matrix container. mat_r \u306f\u884c\u512a\u5148\u306e\u884c\u5217\u30b3\u30f3\u30c6\u30ca\u3067\u3059.","title":"Abstract"},{"location":"src/matrix/mat_rowMajor/#header-file","text":"namespace sstd { template < typename T > class mat_r ; template < typename T > void copy ( sstd :: mat_r < T >& lhs , const sstd :: mat_r < T >& rhs ); template < typename T > void move ( sstd :: mat_r < T >& lhs , sstd :: mat_r < T >& rhs ); template < typename T > void swap ( sstd :: mat_r < T >& lhs , sstd :: mat_r < T >& rhs ); template < typename T > void eye ( sstd :: mat_r < T >& rhs ); template < typename T > void ones ( sstd :: mat_r < T >& rhs ); template < typename T > void zeros ( sstd :: mat_r < T >& Mat ); template < typename T > sstd :: mat_r < T > Tr ( const sstd :: mat_r < T >& rhs ); // lhs = Transpose(rhs) template < typename T > void Tr_myself ( sstd :: mat_r < T >& rhs ); // Transpose(rhs) } template < typename T > class sstd :: mat_r { private : T * _pMatT ; uint _rows ; // row size uint _cols ; // column size uint _size ; // number of element public : inline mat_r (); inline mat_r ( const std :: initializer_list < std :: initializer_list < T >>& rhs ); // called by \"sstd::mat_r<T> mat = {{1, 2, 3}, {4, 5, 6}, {7, 8, 9}};\". inline mat_r ( const class mat_r & rhs ); // called by \"sstd::mat_r<T> buf1(N, N); sstd::mat_r<T> buf2(buf1);\" inline mat_r ( class mat_r && rhs ); // called by \"return std::move(rhs);\" or \"std::swap(buf1, buf2)\". inline mat_r ( const uint & rowSize , const uint & colSize ); inline ~ mat_r (); // Read only: R inline const uint rows () const ; inline const uint cols () const ; inline const uint size () const ; // Read and Write: RW inline T *& pMatT_RW (); inline uint & rows_RW (); inline uint & cols_RW (); inline uint & size_RW (); class mat_r & operator = ( const class mat_r & rhs ); // called by \"lhs = sstd::mat_r<T>(3, 3);\". inline T & operator []( const uint i ); inline T & operator []( const int i ); inline const T & operator []( const uint i ) const ; inline const T & operator []( const int i ) const ; inline T & operator ()( const uint p , const uint q ); inline T & operator ()( const int p , const uint q ); inline T & operator ()( const uint p , const int q ); inline T & operator ()( const int p , const int q ); inline const T & operator ()( const uint p , const uint q ) const ; inline const T & operator ()( const int p , const uint q ) const ; inline const T & operator ()( const uint p , const int q ) const ; inline const T & operator ()( const int p , const int q ) const ; // for element operations (elements multiplication) inline sstd :: mat_r_elements < T > operator ()(); inline sstd :: mat_r_elements < T > vec (); };","title":"Header file"},{"location":"src/matrix/mat_rowMajor/#usage","text":"","title":"Usage"},{"location":"src/matrix/mat_rowMajor/#init","text":"input #include <sstd/sstd.hpp> int main (){ sstd :: mat_r < double > m = {{ 1 , 2 }, { 3 , 4 }}; sstd :: mat_r < double > m_eye ( 2 , 2 ); sstd :: eye ( m_eye ); sstd :: mat_r < double > m_ones ( 2 , 2 ); sstd :: ones ( m_ones ); sstd :: mat_r < double > m_zeros ( 2 , 2 ); sstd :: zeros ( m_zeros ); sstd :: printn ( m ); printf ( \" \\n \" ); sstd :: printn ( m_eye ); printf ( \" \\n \" ); sstd :: printn ( m_ones ); printf ( \" \\n \" ); sstd :: printn ( m_zeros ); } output m = 1.000000 2.000000 3.000000 4.000000 m_eye = 1.000000 0.000000 0.000000 1.000000 m_ones = 1.000000 1.000000 1.000000 1.000000 m_zeros = 0.000000 0.000000 0.000000 0.000000","title":"Init"},{"location":"src/matrix/mat_rowMajor/#access-to-elements","text":"","title":"Access to elements"},{"location":"src/matrix/mat_rowMajor/#as-a-matrix","text":"input #include <sstd/sstd.hpp> int main (){ sstd :: mat_r < double > m ( 2 , 2 ); uint i = 0 ; for ( uint r = 0 ; r < m . rows (); ++ r ){ for ( uint c = 0 ; c < m . cols (); ++ c ){ m ( r , c ) = i ; ++ i ; } } sstd :: printn ( m ); } output m = 0.000000 1.000000 2.000000 3.000000","title":"As a matrix"},{"location":"src/matrix/mat_rowMajor/#as-a-vector","text":"input #include <sstd/sstd.hpp> int main (){ sstd :: mat_r < double > m ( 2 , 2 ); for ( uint i = 0 ; i < m . size (); ++ i ){ m [ i ] = i ; } sstd :: printn ( m ); } output m = 0.000000 1.000000 2.000000 3.000000","title":"As a vector"},{"location":"src/matrix/mat_rowMajor/#tr-transpose","text":"input #include <sstd/sstd.hpp> int main (){ sstd :: mat_r < double > m1 = {{ 1 , 2 }, { 3 , 4 }}; sstd :: printn ( m1 ); sstd :: printn ( sstd :: Tr ( m1 ) ); printf ( \" \\n \" ); sstd :: mat_r < double > m2 = {{ 1 , 2 }, { 3 , 4 }}; sstd :: printn ( m2 ); sstd :: Tr_myself ( m2 ); sstd :: printn ( m2 ); } output m1 = 1.000000 2.000000 3.000000 4.000000 sstd::Tr( m1 ) = 1.000000 3.000000 2.000000 4.000000 m2 = 1.000000 2.000000 3.000000 4.000000 m2 = 1.000000 3.000000 2.000000 4.000000","title":"Tr (Transpose)"},{"location":"src/matrix/mat_rowMajor/#operator","text":"","title":"Operator"},{"location":"src/matrix/mat_rowMajor/#matrix-scalar","text":"input #include <sstd/sstd.hpp> int main (){ sstd :: mat_r < double > m ( 2 , 2 ); for ( uint i = 0 ; i < m . size (); ++ i ){ m [ i ] = i ; } sstd :: printn ( m ); printf ( \" \\n \" ); sstd :: printn ( m * 2 ); } output m = 0.000000 1.000000 2.000000 3.000000 m * 2 = 0.000000 2.000000 4.000000 6.000000","title":"matrix \u00d7 scalar"},{"location":"src/matrix/mat_rowMajor/#matrix-matrix","text":"input #include <sstd/sstd.hpp> int main (){ sstd :: mat_r < double > m1 ( 2 , 2 ); for ( uint i = 0 ; i < m1 . size (); ++ i ){ m1 [ i ] = i ; } sstd :: mat_r < double > m2 ( 2 , 2 ); for ( uint i = 0 ; i < m2 . size (); ++ i ){ m2 [ i ] = i + 1 ; } sstd :: printn ( m1 ); printf ( \" \\n \" ); sstd :: printn ( m2 ); printf ( \" \\n \" ); sstd :: printn ( m1 * m2 ); } output m1 = 0.000000 1.000000 2.000000 3.000000 m2 = 1.000000 2.000000 3.000000 4.000000 m1 * m2 = 3.000000 4.000000 11.000000 16.000000","title":"matrix \u00d7 matrix"},{"location":"src/matrix/mat_rowMajor/#matrix-as-a-vector-matrix-as-a-vector","text":"input #include <sstd/sstd.hpp> int main (){ sstd :: mat_r < double > m1 ( 2 , 2 ); for ( uint i = 0 ; i < m1 . size (); ++ i ){ m1 [ i ] = i ; } sstd :: mat_r < double > m2 ( 2 , 2 ); for ( uint i = 0 ; i < m2 . size (); ++ i ){ m2 [ i ] = i + 1 ; } sstd :: printn ( m1 ); printf ( \" \\n \" ); sstd :: printn ( m2 ); printf ( \" \\n \" ); sstd :: printn ( m1 () * m2 () ); } output m1 = 0.000000 1.000000 2.000000 3.000000 m2 = 1.000000 2.000000 3.000000 4.000000 m1() * m2() = 0.000000 2.000000 6.000000 12.000000","title":"matrix (as a vector) \u00d7 matrix (as a vector)"},{"location":"src/matrix/mat_rowMajor/#implementation","text":"Source: sstd/src/matrixContainer_rowMajor/mat_r.cpp Header: sstd/src/matrixContainer_rowMajor/mat_r.hpp Test: test/mat_r.hpp (Not implemented yet)","title":"Implementation"},{"location":"src/stdlib/system/","text":"system Abstract system() executes the specified command. system() \u306f\u6307\u5b9a\u3055\u308c\u305f\u30b3\u30de\u30f3\u30c9\u3092\u5b9f\u884c\u3057\u307e\u3059\uff0e Header file namespace sstd { int system ( const char * str ); int system ( const std :: string & str ); } Usage input #include <sstd/sstd.hpp> int main (){ sstd :: system ( \"mkdir -p ./tmp/a/b/c\" ); sstd :: system ( \"tree ./tmp\" ); sstd :: system ( \"rm -rf ./tmp\" ); } output ./tmp \u2514\u2500\u2500 a \u2514\u2500\u2500 b \u2514\u2500\u2500 c 3 directories, 0 files Implementation Source: sstd/src/stdlib.cpp Header: sstd/src/stdlib.hpp Test: test/stdlib.hpp (Not implemented yet)","title":"system"},{"location":"src/stdlib/system/#system","text":"","title":"system"},{"location":"src/stdlib/system/#abstract","text":"system() executes the specified command. system() \u306f\u6307\u5b9a\u3055\u308c\u305f\u30b3\u30de\u30f3\u30c9\u3092\u5b9f\u884c\u3057\u307e\u3059\uff0e","title":"Abstract"},{"location":"src/stdlib/system/#header-file","text":"namespace sstd { int system ( const char * str ); int system ( const std :: string & str ); }","title":"Header file"},{"location":"src/stdlib/system/#usage","text":"input #include <sstd/sstd.hpp> int main (){ sstd :: system ( \"mkdir -p ./tmp/a/b/c\" ); sstd :: system ( \"tree ./tmp\" ); sstd :: system ( \"rm -rf ./tmp\" ); } output ./tmp \u2514\u2500\u2500 a \u2514\u2500\u2500 b \u2514\u2500\u2500 c 3 directories, 0 files","title":"Usage"},{"location":"src/stdlib/system/#implementation","text":"Source: sstd/src/stdlib.cpp Header: sstd/src/stdlib.hpp Test: test/stdlib.hpp (Not implemented yet)","title":"Implementation"},{"location":"src/vector/Tr/","text":"Tr (Transpose) Abstract Tr() are the transpose functions for std::vector<std::vector<T>> . Tr() \u306f std::vector<std::vector<T>> \u3092\u8ee2\u7f6e\u3059\u308b\u305f\u3081\u306e\u95a2\u6570\u3067\u3059. Header file namespace sstd { template < typename T > std :: vector < std :: vector < T >> Tr ( const std :: vector < std :: vector < T >>& rhs ); template < typename T > std :: vector < std :: vector < T >> Tr ( std :: vector < std :: vector < T >>&& rhs ); } Usage Transpose. Ex: 1 input #include <sstd/sstd.hpp> int main (){ std :: vector < std :: vector < int >> vvec = { { 1 , 2 , 3 } }; sstd :: printn ( vvec ); std :: vector < std :: vector < int >> vvecTr = sstd :: Tr ( vvec ); sstd :: printn ( vvecTr ); } output vvec = [[1 2 3]] vvecTr = [[1] [2] [3]] Transpose. Ex: 2 input #include <sstd/sstd.hpp> int main (){ std :: vector < std :: vector < int >> vvec = { { 1 , 2 , 3 }, { 4 , 5 , 6 }, { 7 , 8 , 9 } }; sstd :: printn ( vvec ); std :: vector < std :: vector < int >> vvecTr = sstd :: Tr ( vvec ); sstd :: printn ( vvecTr ); } output vvec = [[1 2 3] [4 5 6] [7 8 9]] vvecTr = [[1 4 7] [2 5 8] [3 6 9]] Transpose. Ex: 3 input #include <sstd/sstd.hpp> int main (){ std :: vector < std :: vector < int >> vvec = { { 1 }, { 2 , 3 }, { 4 , 5 , 6 } }; sstd :: printn ( vvec ); std :: vector < std :: vector < int >> vvecTr = sstd :: Tr ( vvec ); sstd :: printn ( vvecTr ); } output vvec = [[1] [2 3] [4 5 6]] vvecTr = [[1 2 4] [0 3 5] [0 0 6]] Implementation Header: sstd/src/vector/vvec.hpp Test: test/vector_vvec.hpp","title":"Tr (Transpose)"},{"location":"src/vector/Tr/#tr-transpose","text":"","title":"Tr (Transpose)"},{"location":"src/vector/Tr/#abstract","text":"Tr() are the transpose functions for std::vector<std::vector<T>> . Tr() \u306f std::vector<std::vector<T>> \u3092\u8ee2\u7f6e\u3059\u308b\u305f\u3081\u306e\u95a2\u6570\u3067\u3059.","title":"Abstract"},{"location":"src/vector/Tr/#header-file","text":"namespace sstd { template < typename T > std :: vector < std :: vector < T >> Tr ( const std :: vector < std :: vector < T >>& rhs ); template < typename T > std :: vector < std :: vector < T >> Tr ( std :: vector < std :: vector < T >>&& rhs ); }","title":"Header file"},{"location":"src/vector/Tr/#usage","text":"","title":"Usage"},{"location":"src/vector/Tr/#transpose-ex-1","text":"input #include <sstd/sstd.hpp> int main (){ std :: vector < std :: vector < int >> vvec = { { 1 , 2 , 3 } }; sstd :: printn ( vvec ); std :: vector < std :: vector < int >> vvecTr = sstd :: Tr ( vvec ); sstd :: printn ( vvecTr ); } output vvec = [[1 2 3]] vvecTr = [[1] [2] [3]]","title":"Transpose. Ex: 1"},{"location":"src/vector/Tr/#transpose-ex-2","text":"input #include <sstd/sstd.hpp> int main (){ std :: vector < std :: vector < int >> vvec = { { 1 , 2 , 3 }, { 4 , 5 , 6 }, { 7 , 8 , 9 } }; sstd :: printn ( vvec ); std :: vector < std :: vector < int >> vvecTr = sstd :: Tr ( vvec ); sstd :: printn ( vvecTr ); } output vvec = [[1 2 3] [4 5 6] [7 8 9]] vvecTr = [[1 4 7] [2 5 8] [3 6 9]]","title":"Transpose. Ex: 2"},{"location":"src/vector/Tr/#transpose-ex-3","text":"input #include <sstd/sstd.hpp> int main (){ std :: vector < std :: vector < int >> vvec = { { 1 }, { 2 , 3 }, { 4 , 5 , 6 } }; sstd :: printn ( vvec ); std :: vector < std :: vector < int >> vvecTr = sstd :: Tr ( vvec ); sstd :: printn ( vvecTr ); } output vvec = [[1] [2 3] [4 5 6]] vvecTr = [[1 2 4] [0 3 5] [0 0 6]]","title":"Transpose. Ex: 3"},{"location":"src/vector/Tr/#implementation","text":"Header: sstd/src/vector/vvec.hpp Test: test/vector_vvec.hpp","title":"Implementation"},{"location":"src/vector/slice/","text":"slice Abstract sstd::slice / sstd::slice_mv \u306f\uff0cPython \u306e slice \u5b9f\u88c5\u3092 C++ \u98a8\u306b\u30a2\u30ec\u30f3\u30b8\u3057\u305f sstd \u306e\u72ec\u81ea\u5b9f\u88c5\u3067\u3059\uff0e sstd::slice \u306f\u8981\u7d20\u30b3\u30d4\u30fc\u3092\u4f34\u3046\u547d\u4ee4\u3067\uff0c sstd::slice_mv \u306f\u5185\u90e8\u7684\u306b std::move \u3092\u547c\u3073\u51fa\u3057\u307e\u3059\uff0e std::vector \u306b\u5bfe\u3059\u308b slice \u64cd\u4f5c\u3092\u5b9a\u7fa9\u3057\u3066\u3044\u307e\u3059\uff0e \u306a\u304a\uff0c sstd::begin \u304a\u3088\u3073 sstd::end \u306f\uff0c src/itr.hpp \u306b\u5b9a\u7fa9\u3055\u308c\u3066\u3044\u308b\uff0e Header file namespace sstd { sstd_vecSc :: slice_i slice ( const int val ); sstd_vecSc :: slice_u slice ( const uint val ); sstd_vecSc :: slice_s slice ( const size_t val ); sstd_vecSc :: slice_b slice ( const sstd :: begin val ); sstd_vecSc :: slice_e slice ( const sstd :: end val ); sstd_vecSc :: slice_ii slice ( const int lhs , const int rhs ); sstd_vecSc :: slice_iu slice ( const int lhs , const uint rhs ); sstd_vecSc :: slice_is slice ( const int lhs , const size_t rhs ); sstd_vecSc :: slice_ui slice ( const uint lhs , const int rhs ); sstd_vecSc :: slice_uu slice ( const uint lhs , const uint rhs ); sstd_vecSc :: slice_us slice ( const uint lhs , const size_t rhs ); sstd_vecSc :: slice_si slice ( const size_t lhs , const int rhs ); sstd_vecSc :: slice_su slice ( const size_t lhs , const uint rhs ); sstd_vecSc :: slice_ss slice ( const size_t lhs , const size_t rhs ); sstd_vecSc :: slice_bi slice ( const sstd :: begin lhs , const int rhs ); sstd_vecSc :: slice_bu slice ( const sstd :: begin lhs , const uint rhs ); sstd_vecSc :: slice_bs slice ( const sstd :: begin lhs , const size_t rhs ); sstd_vecSc :: slice_ie slice ( const int lhs , const sstd :: end rhs ); sstd_vecSc :: slice_ue slice ( const uint lhs , const sstd :: end rhs ); sstd_vecSc :: slice_se slice ( const size_t lhs , const sstd :: end rhs ); sstd_vecSc :: slice_be slice ( const sstd :: begin lhs , const sstd :: end rhs ); //--- sstd_vecSc :: slice_mv_i slice_mv ( const int val ); sstd_vecSc :: slice_mv_u slice_mv ( const uint val ); sstd_vecSc :: slice_mv_s slice_mv ( const size_t val ); sstd_vecSc :: slice_mv_b slice_mv ( const sstd :: begin val ); sstd_vecSc :: slice_mv_e slice_mv ( const sstd :: end val ); sstd_vecSc :: slice_mv_ii slice_mv ( const int lhs , const int rhs ); sstd_vecSc :: slice_mv_iu slice_mv ( const int lhs , const uint rhs ); sstd_vecSc :: slice_mv_is slice_mv ( const int lhs , const size_t rhs ); sstd_vecSc :: slice_mv_ui slice_mv ( const uint lhs , const int rhs ); sstd_vecSc :: slice_mv_uu slice_mv ( const uint lhs , const uint rhs ); sstd_vecSc :: slice_mv_us slice_mv ( const uint lhs , const size_t rhs ); sstd_vecSc :: slice_mv_si slice_mv ( const size_t lhs , const int rhs ); sstd_vecSc :: slice_mv_su slice_mv ( const size_t lhs , const uint rhs ); sstd_vecSc :: slice_mv_ss slice_mv ( const size_t lhs , const size_t rhs ); sstd_vecSc :: slice_mv_bi slice_mv ( const sstd :: begin lhs , const int rhs ); sstd_vecSc :: slice_mv_bu slice_mv ( const sstd :: begin lhs , const uint rhs ); sstd_vecSc :: slice_mv_bs slice_mv ( const sstd :: begin lhs , const size_t rhs ); sstd_vecSc :: slice_mv_ie slice_mv ( const int lhs , const sstd :: end rhs ); sstd_vecSc :: slice_mv_ue slice_mv ( const uint lhs , const sstd :: end rhs ); sstd_vecSc :: slice_mv_se slice_mv ( const size_t lhs , const sstd :: end rhs ); sstd_vecSc :: slice_mv_be slice_mv ( const sstd :: begin lhs , const sstd :: end rhs ); } Usage one arg (copy) input #include <sstd/sstd.hpp> int main (){ std :: vector < int > v = { 1 , 2 , 3 , 4 , 5 }; std :: vector < int > v_sliced01 = v && sstd :: slice ( 1 ); std :: vector < int > v_sliced02 = v && sstd :: slice ( - 1 ); sstd :: printn ( v ); sstd :: printn ( v_sliced01 ); sstd :: printn ( v_sliced02 ); } output v = [1 2 3 4 5] v_sliced01 = [2] v_sliced02 = [5] two args (copy) input #include <sstd/sstd.hpp> int main (){ std :: vector < int > v = { 1 , 2 , 3 , 4 , 5 }; std :: vector < int > v_sliced = v && sstd :: slice ( 1 , 3 ); sstd :: printn ( v ); sstd :: printn ( v_sliced ); } output v = [1 2 3 4 5] v_sliced = [2 3] begin to end (copy) input #include <sstd/sstd.hpp> int main (){ std :: vector < int > v = { 1 , 2 , 3 , 4 , 5 }; std :: vector < int > v_sliced = v && sstd :: slice ( sstd :: begin (), sstd :: end ()); sstd :: printn ( v ); sstd :: printn ( v_sliced ); } output v = [1 2 3 4 5] v_sliced = [1 2 3 4 5] one arg (move) input #include <sstd/sstd.hpp> int main (){ std :: vector < std :: string > v = { \"1\" , \"2\" , \"3\" , \"4\" , \"5\" }; std :: vector < std :: string > v_sliced01 = v && sstd :: slice_mv ( 1 ); std :: vector < std :: string > v_sliced02 = v && sstd :: slice_mv ( - 1 ); sstd :: printn ( v ); sstd :: printn ( v_sliced01 ); sstd :: printn ( v_sliced02 ); } output v = [\"1\" \"\" \"3\" \"4\" \"\"] v_sliced01 = [\"2\"] v_sliced02 = [\"5\"] two args (move) input #include <sstd/sstd.hpp> int main (){ std :: vector < std :: string > v = { \"1\" , \"2\" , \"3\" , \"4\" , \"5\" }; std :: vector < std :: string > v_sliced = v && sstd :: slice_mv ( 1 , 3 ); sstd :: printn ( v ); sstd :: printn ( v_sliced ); } output v = [\"1\" \"\" \"\" \"4\" \"5\"] v_sliced = [\"2\" \"3\"] begin to end (move) input #include <sstd/sstd.hpp> int main (){ std :: vector < std :: string > v = { \"1\" , \"2\" , \"3\" , \"4\" , \"5\" }; std :: vector < std :: string > v_sliced = v && sstd :: slice_mv ( sstd :: begin (), sstd :: end ()); sstd :: printn ( v ); sstd :: printn ( v_sliced ); } output v = [\"\" \"\" \"\" \"\" \"\"] v_sliced = [\"1\" \"2\" \"3\" \"4\" \"5\"] Implementation Header: sstd/src/vector/slice.hpp Test: test/vector_slice.hpp","title":"slice"},{"location":"src/vector/slice/#slice","text":"","title":"slice"},{"location":"src/vector/slice/#abstract","text":"sstd::slice / sstd::slice_mv \u306f\uff0cPython \u306e slice \u5b9f\u88c5\u3092 C++ \u98a8\u306b\u30a2\u30ec\u30f3\u30b8\u3057\u305f sstd \u306e\u72ec\u81ea\u5b9f\u88c5\u3067\u3059\uff0e sstd::slice \u306f\u8981\u7d20\u30b3\u30d4\u30fc\u3092\u4f34\u3046\u547d\u4ee4\u3067\uff0c sstd::slice_mv \u306f\u5185\u90e8\u7684\u306b std::move \u3092\u547c\u3073\u51fa\u3057\u307e\u3059\uff0e std::vector \u306b\u5bfe\u3059\u308b slice \u64cd\u4f5c\u3092\u5b9a\u7fa9\u3057\u3066\u3044\u307e\u3059\uff0e \u306a\u304a\uff0c sstd::begin \u304a\u3088\u3073 sstd::end \u306f\uff0c src/itr.hpp \u306b\u5b9a\u7fa9\u3055\u308c\u3066\u3044\u308b\uff0e","title":"Abstract"},{"location":"src/vector/slice/#header-file","text":"namespace sstd { sstd_vecSc :: slice_i slice ( const int val ); sstd_vecSc :: slice_u slice ( const uint val ); sstd_vecSc :: slice_s slice ( const size_t val ); sstd_vecSc :: slice_b slice ( const sstd :: begin val ); sstd_vecSc :: slice_e slice ( const sstd :: end val ); sstd_vecSc :: slice_ii slice ( const int lhs , const int rhs ); sstd_vecSc :: slice_iu slice ( const int lhs , const uint rhs ); sstd_vecSc :: slice_is slice ( const int lhs , const size_t rhs ); sstd_vecSc :: slice_ui slice ( const uint lhs , const int rhs ); sstd_vecSc :: slice_uu slice ( const uint lhs , const uint rhs ); sstd_vecSc :: slice_us slice ( const uint lhs , const size_t rhs ); sstd_vecSc :: slice_si slice ( const size_t lhs , const int rhs ); sstd_vecSc :: slice_su slice ( const size_t lhs , const uint rhs ); sstd_vecSc :: slice_ss slice ( const size_t lhs , const size_t rhs ); sstd_vecSc :: slice_bi slice ( const sstd :: begin lhs , const int rhs ); sstd_vecSc :: slice_bu slice ( const sstd :: begin lhs , const uint rhs ); sstd_vecSc :: slice_bs slice ( const sstd :: begin lhs , const size_t rhs ); sstd_vecSc :: slice_ie slice ( const int lhs , const sstd :: end rhs ); sstd_vecSc :: slice_ue slice ( const uint lhs , const sstd :: end rhs ); sstd_vecSc :: slice_se slice ( const size_t lhs , const sstd :: end rhs ); sstd_vecSc :: slice_be slice ( const sstd :: begin lhs , const sstd :: end rhs ); //--- sstd_vecSc :: slice_mv_i slice_mv ( const int val ); sstd_vecSc :: slice_mv_u slice_mv ( const uint val ); sstd_vecSc :: slice_mv_s slice_mv ( const size_t val ); sstd_vecSc :: slice_mv_b slice_mv ( const sstd :: begin val ); sstd_vecSc :: slice_mv_e slice_mv ( const sstd :: end val ); sstd_vecSc :: slice_mv_ii slice_mv ( const int lhs , const int rhs ); sstd_vecSc :: slice_mv_iu slice_mv ( const int lhs , const uint rhs ); sstd_vecSc :: slice_mv_is slice_mv ( const int lhs , const size_t rhs ); sstd_vecSc :: slice_mv_ui slice_mv ( const uint lhs , const int rhs ); sstd_vecSc :: slice_mv_uu slice_mv ( const uint lhs , const uint rhs ); sstd_vecSc :: slice_mv_us slice_mv ( const uint lhs , const size_t rhs ); sstd_vecSc :: slice_mv_si slice_mv ( const size_t lhs , const int rhs ); sstd_vecSc :: slice_mv_su slice_mv ( const size_t lhs , const uint rhs ); sstd_vecSc :: slice_mv_ss slice_mv ( const size_t lhs , const size_t rhs ); sstd_vecSc :: slice_mv_bi slice_mv ( const sstd :: begin lhs , const int rhs ); sstd_vecSc :: slice_mv_bu slice_mv ( const sstd :: begin lhs , const uint rhs ); sstd_vecSc :: slice_mv_bs slice_mv ( const sstd :: begin lhs , const size_t rhs ); sstd_vecSc :: slice_mv_ie slice_mv ( const int lhs , const sstd :: end rhs ); sstd_vecSc :: slice_mv_ue slice_mv ( const uint lhs , const sstd :: end rhs ); sstd_vecSc :: slice_mv_se slice_mv ( const size_t lhs , const sstd :: end rhs ); sstd_vecSc :: slice_mv_be slice_mv ( const sstd :: begin lhs , const sstd :: end rhs ); }","title":"Header file"},{"location":"src/vector/slice/#usage","text":"","title":"Usage"},{"location":"src/vector/slice/#one-arg-copy","text":"input #include <sstd/sstd.hpp> int main (){ std :: vector < int > v = { 1 , 2 , 3 , 4 , 5 }; std :: vector < int > v_sliced01 = v && sstd :: slice ( 1 ); std :: vector < int > v_sliced02 = v && sstd :: slice ( - 1 ); sstd :: printn ( v ); sstd :: printn ( v_sliced01 ); sstd :: printn ( v_sliced02 ); } output v = [1 2 3 4 5] v_sliced01 = [2] v_sliced02 = [5]","title":"one arg (copy)"},{"location":"src/vector/slice/#two-args-copy","text":"input #include <sstd/sstd.hpp> int main (){ std :: vector < int > v = { 1 , 2 , 3 , 4 , 5 }; std :: vector < int > v_sliced = v && sstd :: slice ( 1 , 3 ); sstd :: printn ( v ); sstd :: printn ( v_sliced ); } output v = [1 2 3 4 5] v_sliced = [2 3]","title":"two args (copy)"},{"location":"src/vector/slice/#begin-to-end-copy","text":"input #include <sstd/sstd.hpp> int main (){ std :: vector < int > v = { 1 , 2 , 3 , 4 , 5 }; std :: vector < int > v_sliced = v && sstd :: slice ( sstd :: begin (), sstd :: end ()); sstd :: printn ( v ); sstd :: printn ( v_sliced ); } output v = [1 2 3 4 5] v_sliced = [1 2 3 4 5]","title":"begin to end (copy)"},{"location":"src/vector/slice/#one-arg-move","text":"input #include <sstd/sstd.hpp> int main (){ std :: vector < std :: string > v = { \"1\" , \"2\" , \"3\" , \"4\" , \"5\" }; std :: vector < std :: string > v_sliced01 = v && sstd :: slice_mv ( 1 ); std :: vector < std :: string > v_sliced02 = v && sstd :: slice_mv ( - 1 ); sstd :: printn ( v ); sstd :: printn ( v_sliced01 ); sstd :: printn ( v_sliced02 ); } output v = [\"1\" \"\" \"3\" \"4\" \"\"] v_sliced01 = [\"2\"] v_sliced02 = [\"5\"]","title":"one arg (move)"},{"location":"src/vector/slice/#two-args-move","text":"input #include <sstd/sstd.hpp> int main (){ std :: vector < std :: string > v = { \"1\" , \"2\" , \"3\" , \"4\" , \"5\" }; std :: vector < std :: string > v_sliced = v && sstd :: slice_mv ( 1 , 3 ); sstd :: printn ( v ); sstd :: printn ( v_sliced ); } output v = [\"1\" \"\" \"\" \"4\" \"5\"] v_sliced = [\"2\" \"3\"]","title":"two args (move)"},{"location":"src/vector/slice/#begin-to-end-move","text":"input #include <sstd/sstd.hpp> int main (){ std :: vector < std :: string > v = { \"1\" , \"2\" , \"3\" , \"4\" , \"5\" }; std :: vector < std :: string > v_sliced = v && sstd :: slice_mv ( sstd :: begin (), sstd :: end ()); sstd :: printn ( v ); sstd :: printn ( v_sliced ); } output v = [\"\" \"\" \"\" \"\" \"\"] v_sliced = [\"1\" \"2\" \"3\" \"4\" \"5\"]","title":"begin to end (move)"},{"location":"src/vector/slice/#implementation","text":"Header: sstd/src/vector/slice.hpp Test: test/vector_slice.hpp","title":"Implementation"},{"location":"src/vector/stdVector_expansion/","text":"Operator expansions for std::vector<T> Abstract Operator definitions on SSTD. These definitions are read by #include <sstd/sstd.hpp> . SSTD \u306b\u304a\u3051\u308b\u6f14\u7b97\u5b50\u306e\u5b9a\u7fa9\uff0e #include <sstd/sstd.hpp> \u306b\u3088\u308a\u5b9a\u7fa9\u304c\u8aad\u307f\u8fbc\u307e\u308c\u308b\uff0e Header file namespace sstd_stdVecEx { // operators for mathematics SSTD_DEF_stdVecEx_defInNamespace ( add ); // + SSTD_DEF_stdVecEx_defInNamespace_eq ( add_eq ); // += SSTD_DEF_stdVecEx_defInNamespace ( sub ); // - SSTD_DEF_stdVecEx_defInNamespace_eq ( sub_eq ); // -= SSTD_DEF_stdVecEx_defInNamespace ( mul ); // * SSTD_DEF_stdVecEx_defInNamespace_eq ( mul_eq ); // *= SSTD_DEF_stdVecEx_defInNamespace ( div ); // / SSTD_DEF_stdVecEx_defInNamespace_eq ( div_eq ); // /= SSTD_DEF_stdVecEx_defInNamespace ( mod ); // % SSTD_DEF_stdVecEx_defInNamespace_eq ( mod_eq ); // %= SSTD_DEF_stdVecEx_defInNamespace ( pow ); // ^ SSTD_DEF_stdVecEx_defInNamespace_eq ( pow_eq ); // ^= // operators for std::vector SSTD_DEF_stdVecEx_defInNamespace ( push_front ); // >> SSTD_DEF_stdVecEx_defInNamespace_eq ( push_front_eq ); // >>= SSTD_DEF_stdVecEx_defInNamespace ( push_back ); // << SSTD_DEF_stdVecEx_defInNamespace_eq ( push_back_eq ); // <<= } Usage Ope. * and *= vector \u00d7 scalar input #include <sstd/sstd.hpp> int main (){ std :: vector < int > v = { 1 , 2 , 3 }; sstd :: printn ( v * 2 ); v *= 3 ; sstd :: printn ( v ); } output v * 2 = [2 4 6] v = [3 6 9] vector \u00d7 vector input #include <sstd/sstd.hpp> int main (){ std :: vector < int > v1 = { 1 , 2 , 3 }; std :: vector < int > v2 = { 2 , 3 , 4 }; sstd :: printn ( v1 * v2 ); v1 *= v2 ; sstd :: printn ( v1 ); sstd :: printn ( v2 ); } output v1 * v2 = [2 6 12] v1 = [2 6 12] v2 = [2 3 4] Linking << vector << scalar input #include <sstd/sstd.hpp> int main (){ std :: vector < int > v = { 1 , 2 , 3 }; int s = 4 ; sstd :: printn ( v << s ); sstd :: printn ( v ); sstd :: printn ( s ); } output v << s = [1 2 3 4] v = [1 2 3] s = 4 vector << vector input #include <sstd/sstd.hpp> int main (){ std :: vector < int > v1 = { 1 , 2 , 3 }; std :: vector < int > v2 = { 4 , 5 , 6 }; sstd :: printn ( v1 << v2 ); sstd :: printn ( v1 ); sstd :: printn ( v2 ); } output v1 << v2 = [1 2 3 4 5 6] v1 = [1 2 3] v2 = [4 5 6] push_back() vector <<= scalar input #include <sstd/sstd.hpp> int main (){ std :: vector < int > v ; v <<= 1 ; // same as a \"v.push_back(1);\" v <<= 2 ; // same as a \"v.push_back(2);\" v <<= 3 ; // same as a \"v.push_back(3);\" sstd :: printn ( v ); } output v = [1 2 3] vector <<= vector input #include <sstd/sstd.hpp> int main (){ std :: vector < int > v1 = { 1 , 2 , 3 }; std :: vector < int > v2 = { 4 , 5 , 6 }; v1 <<= v2 ; sstd :: printn ( v1 ); sstd :: printn ( v2 ); } output v1 = [1 2 3 4 5 6] v2 = [4 5 6] Linking >> vector >> scalar input #include <sstd/sstd.hpp> int main (){ std :: vector < int > v = { 1 , 2 , 3 }; int s = 0 ; sstd :: printn ( v >> s ); sstd :: printn ( v ); sstd :: printn ( s ); } output v >> s = [0 1 2 3] v = [1 2 3] s = 0 vector >> vector input #include <sstd/sstd.hpp> int main (){ std :: vector < int > v1 = { 1 , 2 , 3 }; std :: vector < int > v2 = { - 2 , - 1 , 0 }; sstd :: printn ( v1 >> v2 ); sstd :: printn ( v1 ); sstd :: printn ( v2 ); } output v1 >> v2 = [-2 -1 0 1 2 3] v1 = [1 2 3] v2 = [-2 -1 0] push_front() vector >>= scalar input #include <sstd/sstd.hpp> int main (){ std :: vector < int > v = { 1 , 2 , 3 }; v >>= 0 ; sstd :: printn ( v ); } output v = [0 1 2 3] vector >>= vector input #include <sstd/sstd.hpp> int main (){ std :: vector < int > v1 = { 1 , 2 , 3 }; std :: vector < int > v2 = { - 2 , - 1 , 0 }; v1 >>= v2 ; sstd :: printn ( v1 ); sstd :: printn ( v2 ); } output v1 = [-2 -1 0 1 2 3] v2 = [-2 -1 0] Implementation Header: sstd/src/vector/stdVector_expansion.hpp Test: test/vector_stdVector_expansion.hpp","title":"Ope. Exp. for std::vector&lt;T&gt;"},{"location":"src/vector/stdVector_expansion/#operator-expansions-for-stdvectort","text":"","title":"Operator expansions for std::vector&lt;T&gt;"},{"location":"src/vector/stdVector_expansion/#abstract","text":"Operator definitions on SSTD. These definitions are read by #include <sstd/sstd.hpp> . SSTD \u306b\u304a\u3051\u308b\u6f14\u7b97\u5b50\u306e\u5b9a\u7fa9\uff0e #include <sstd/sstd.hpp> \u306b\u3088\u308a\u5b9a\u7fa9\u304c\u8aad\u307f\u8fbc\u307e\u308c\u308b\uff0e","title":"Abstract"},{"location":"src/vector/stdVector_expansion/#header-file","text":"namespace sstd_stdVecEx { // operators for mathematics SSTD_DEF_stdVecEx_defInNamespace ( add ); // + SSTD_DEF_stdVecEx_defInNamespace_eq ( add_eq ); // += SSTD_DEF_stdVecEx_defInNamespace ( sub ); // - SSTD_DEF_stdVecEx_defInNamespace_eq ( sub_eq ); // -= SSTD_DEF_stdVecEx_defInNamespace ( mul ); // * SSTD_DEF_stdVecEx_defInNamespace_eq ( mul_eq ); // *= SSTD_DEF_stdVecEx_defInNamespace ( div ); // / SSTD_DEF_stdVecEx_defInNamespace_eq ( div_eq ); // /= SSTD_DEF_stdVecEx_defInNamespace ( mod ); // % SSTD_DEF_stdVecEx_defInNamespace_eq ( mod_eq ); // %= SSTD_DEF_stdVecEx_defInNamespace ( pow ); // ^ SSTD_DEF_stdVecEx_defInNamespace_eq ( pow_eq ); // ^= // operators for std::vector SSTD_DEF_stdVecEx_defInNamespace ( push_front ); // >> SSTD_DEF_stdVecEx_defInNamespace_eq ( push_front_eq ); // >>= SSTD_DEF_stdVecEx_defInNamespace ( push_back ); // << SSTD_DEF_stdVecEx_defInNamespace_eq ( push_back_eq ); // <<= }","title":"Header file"},{"location":"src/vector/stdVector_expansion/#usage","text":"","title":"Usage"},{"location":"src/vector/stdVector_expansion/#ope-and","text":"","title":"Ope. * and *="},{"location":"src/vector/stdVector_expansion/#vector-scalar","text":"input #include <sstd/sstd.hpp> int main (){ std :: vector < int > v = { 1 , 2 , 3 }; sstd :: printn ( v * 2 ); v *= 3 ; sstd :: printn ( v ); } output v * 2 = [2 4 6] v = [3 6 9]","title":"vector \u00d7 scalar"},{"location":"src/vector/stdVector_expansion/#vector-vector","text":"input #include <sstd/sstd.hpp> int main (){ std :: vector < int > v1 = { 1 , 2 , 3 }; std :: vector < int > v2 = { 2 , 3 , 4 }; sstd :: printn ( v1 * v2 ); v1 *= v2 ; sstd :: printn ( v1 ); sstd :: printn ( v2 ); } output v1 * v2 = [2 6 12] v1 = [2 6 12] v2 = [2 3 4]","title":"vector \u00d7 vector"},{"location":"src/vector/stdVector_expansion/#linking","text":"","title":"Linking &lt;&lt;"},{"location":"src/vector/stdVector_expansion/#vector-scalar_1","text":"input #include <sstd/sstd.hpp> int main (){ std :: vector < int > v = { 1 , 2 , 3 }; int s = 4 ; sstd :: printn ( v << s ); sstd :: printn ( v ); sstd :: printn ( s ); } output v << s = [1 2 3 4] v = [1 2 3] s = 4","title":"vector &lt;&lt; scalar"},{"location":"src/vector/stdVector_expansion/#vector-vector_1","text":"input #include <sstd/sstd.hpp> int main (){ std :: vector < int > v1 = { 1 , 2 , 3 }; std :: vector < int > v2 = { 4 , 5 , 6 }; sstd :: printn ( v1 << v2 ); sstd :: printn ( v1 ); sstd :: printn ( v2 ); } output v1 << v2 = [1 2 3 4 5 6] v1 = [1 2 3] v2 = [4 5 6]","title":"vector &lt;&lt; vector"},{"location":"src/vector/stdVector_expansion/#push_back","text":"","title":"push_back()"},{"location":"src/vector/stdVector_expansion/#vector-scalar_2","text":"input #include <sstd/sstd.hpp> int main (){ std :: vector < int > v ; v <<= 1 ; // same as a \"v.push_back(1);\" v <<= 2 ; // same as a \"v.push_back(2);\" v <<= 3 ; // same as a \"v.push_back(3);\" sstd :: printn ( v ); } output v = [1 2 3]","title":"vector &lt;&lt;= scalar"},{"location":"src/vector/stdVector_expansion/#vector-vector_2","text":"input #include <sstd/sstd.hpp> int main (){ std :: vector < int > v1 = { 1 , 2 , 3 }; std :: vector < int > v2 = { 4 , 5 , 6 }; v1 <<= v2 ; sstd :: printn ( v1 ); sstd :: printn ( v2 ); } output v1 = [1 2 3 4 5 6] v2 = [4 5 6]","title":"vector &lt;&lt;= vector"},{"location":"src/vector/stdVector_expansion/#linking_1","text":"","title":"Linking &gt;&gt;"},{"location":"src/vector/stdVector_expansion/#vector-scalar_3","text":"input #include <sstd/sstd.hpp> int main (){ std :: vector < int > v = { 1 , 2 , 3 }; int s = 0 ; sstd :: printn ( v >> s ); sstd :: printn ( v ); sstd :: printn ( s ); } output v >> s = [0 1 2 3] v = [1 2 3] s = 0","title":"vector &gt;&gt; scalar"},{"location":"src/vector/stdVector_expansion/#vector-vector_3","text":"input #include <sstd/sstd.hpp> int main (){ std :: vector < int > v1 = { 1 , 2 , 3 }; std :: vector < int > v2 = { - 2 , - 1 , 0 }; sstd :: printn ( v1 >> v2 ); sstd :: printn ( v1 ); sstd :: printn ( v2 ); } output v1 >> v2 = [-2 -1 0 1 2 3] v1 = [1 2 3] v2 = [-2 -1 0]","title":"vector &gt;&gt; vector"},{"location":"src/vector/stdVector_expansion/#push_front","text":"","title":"push_front()"},{"location":"src/vector/stdVector_expansion/#vector-scalar_4","text":"input #include <sstd/sstd.hpp> int main (){ std :: vector < int > v = { 1 , 2 , 3 }; v >>= 0 ; sstd :: printn ( v ); } output v = [0 1 2 3]","title":"vector &gt;&gt;= scalar"},{"location":"src/vector/stdVector_expansion/#vector-vector_4","text":"input #include <sstd/sstd.hpp> int main (){ std :: vector < int > v1 = { 1 , 2 , 3 }; std :: vector < int > v2 = { - 2 , - 1 , 0 }; v1 >>= v2 ; sstd :: printn ( v1 ); sstd :: printn ( v2 ); } output v1 = [-2 -1 0 1 2 3] v2 = [-2 -1 0]","title":"vector &gt;&gt;= vector"},{"location":"src/vector/stdVector_expansion/#implementation","text":"Header: sstd/src/vector/stdVector_expansion.hpp Test: test/vector_stdVector_expansion.hpp","title":"Implementation"},{"location":"src/vector/vec_vvec/","text":"vec/vvec Abstract Type definitions on SSTD. These definitions are read by #include <sstd/sstd.hpp> . SSTD \u306b\u304a\u3051\u308b\u578b\u306e\u5b9a\u7fa9\uff0e #include <sstd/sstd.hpp> \u306b\u3088\u308a\u5b9a\u7fa9\u304c\u8aad\u307f\u8fbc\u307e\u308c\u308b\uff0e Header file namespace sstd { template < class T > using vec = std :: vector < T > ; template < class T > using vvec = std :: vector < std :: vector < T >> ; } Usage input #include <sstd/sstd.hpp> int main (){ sstd :: vec < int > v = { 1 , 2 , 3 }; // same as a \"std::vector<int> v = {1, 2, 3};\" sstd :: printn ( v ); sstd :: vvec < int > vv = {{ 1 , 2 , 3 }, { 4 , 5 , 6 }}; // same as a \"std::vector<vector<int>> vv = {{1, 2, 3}, {4, 5, 6}};\" sstd :: printn ( vv ); } output v = [1 2 3] vv = [[1 2 3] [4 5 6]] Implementation Header: sstd/src/vector/typeDef.hpp Test: test/vector/typeDef.hpp (Not implemented yet)","title":"vec/vvec"},{"location":"src/vector/vec_vvec/#vecvvec","text":"","title":"vec/vvec"},{"location":"src/vector/vec_vvec/#abstract","text":"Type definitions on SSTD. These definitions are read by #include <sstd/sstd.hpp> . SSTD \u306b\u304a\u3051\u308b\u578b\u306e\u5b9a\u7fa9\uff0e #include <sstd/sstd.hpp> \u306b\u3088\u308a\u5b9a\u7fa9\u304c\u8aad\u307f\u8fbc\u307e\u308c\u308b\uff0e","title":"Abstract"},{"location":"src/vector/vec_vvec/#header-file","text":"namespace sstd { template < class T > using vec = std :: vector < T > ; template < class T > using vvec = std :: vector < std :: vector < T >> ; }","title":"Header file"},{"location":"src/vector/vec_vvec/#usage","text":"input #include <sstd/sstd.hpp> int main (){ sstd :: vec < int > v = { 1 , 2 , 3 }; // same as a \"std::vector<int> v = {1, 2, 3};\" sstd :: printn ( v ); sstd :: vvec < int > vv = {{ 1 , 2 , 3 }, { 4 , 5 , 6 }}; // same as a \"std::vector<vector<int>> vv = {{1, 2, 3}, {4, 5, 6}};\" sstd :: printn ( vv ); } output v = [1 2 3] vv = [[1 2 3] [4 5 6]]","title":"Usage"},{"location":"src/vector/vec_vvec/#implementation","text":"Header: sstd/src/vector/typeDef.hpp Test: test/vector/typeDef.hpp (Not implemented yet)","title":"Implementation"},{"location":"src/vector/vvec/","text":"template Abstract This is a documentation template. Header file namespace sstd { template < class T > using vec = std :: vector < T > ; template < class T > using vvec = std :: vector < std :: vector < T >> ; } Usage input #include <sstd/sstd.hpp> int main (){ std :: string s = \"Hello template!\" ; sstd :: printn ( s ); } output s = \"Hello template!\" Implementation Header: sstd/src/vector/typeDef.hpp Test: test/XXXXXX.hpp (Not implemented yet)","title":"vec/vvec"},{"location":"src/vector/vvec/#template","text":"","title":"template"},{"location":"src/vector/vvec/#abstract","text":"This is a documentation template.","title":"Abstract"},{"location":"src/vector/vvec/#header-file","text":"namespace sstd { template < class T > using vec = std :: vector < T > ; template < class T > using vvec = std :: vector < std :: vector < T >> ; }","title":"Header file"},{"location":"src/vector/vvec/#usage","text":"input #include <sstd/sstd.hpp> int main (){ std :: string s = \"Hello template!\" ; sstd :: printn ( s ); } output s = \"Hello template!\"","title":"Usage"},{"location":"src/vector/vvec/#implementation","text":"Header: sstd/src/vector/typeDef.hpp Test: test/XXXXXX.hpp (Not implemented yet)","title":"Implementation"}]}