{"config":{"lang":["en","ja"],"min_search_length":3,"prebuild_index":false,"separator":"[\\s\\-]+"},"docs":[{"location":"","text":"What is SSTD ? SubStandardLibrary (SSTD) is a convenient functions set for C++, works on GCC (g++). Installation Downloading source code from github.com/admiswalker/SubStandardLibrary . Copying all of under ./sstd/*. Compilling the sstd. $ cd ./sstd $ make Adding flags in your makefile. CFLAGS += -I./sstd/include -L./sstd/lib -lsstd CFLAGS += -std=gnu++0x Including a header #include <sstd/sstd.hpp> in your code. License MIT licence or Public domain. (This software is dual license, so you can choose whichever you want). Repository github.com/admiswalker/SubStandardLibrary","title":"What is SSTD ?"},{"location":"#what-is-sstd","text":"SubStandardLibrary (SSTD) is a convenient functions set for C++, works on GCC (g++).","title":"What is SSTD ?"},{"location":"#installation","text":"Downloading source code from github.com/admiswalker/SubStandardLibrary . Copying all of under ./sstd/*. Compilling the sstd. $ cd ./sstd $ make Adding flags in your makefile. CFLAGS += -I./sstd/include -L./sstd/lib -lsstd CFLAGS += -std=gnu++0x Including a header #include <sstd/sstd.hpp> in your code.","title":"Installation"},{"location":"#license","text":"MIT licence or Public domain. (This software is dual license, so you can choose whichever you want).","title":"License"},{"location":"#repository","text":"github.com/admiswalker/SubStandardLibrary","title":"Repository"},{"location":"template/","text":"template Abstract This is a documentation template. Header file Usage input #include <sstd/sstd.hpp> int main (){ std :: string s = \"Hello template!\" ; sstd :: printn ( s ); } output s = \"Hello template!\" Appendix Others Implementation: sstd/src/XXXXXX.hpp Test code: test/XXXXXX.hpp (Not implemented yet)","title":"template"},{"location":"template/#template","text":"","title":"template"},{"location":"template/#abstract","text":"This is a documentation template.","title":"Abstract"},{"location":"template/#header-file","text":"","title":"Header file"},{"location":"template/#usage","text":"input #include <sstd/sstd.hpp> int main (){ std :: string s = \"Hello template!\" ; sstd :: printn ( s ); } output s = \"Hello template!\"","title":"Usage"},{"location":"template/#appendix","text":"","title":"Appendix"},{"location":"template/#others","text":"Implementation: sstd/src/XXXXXX.hpp Test code: test/XXXXXX.hpp (Not implemented yet)","title":"Others"},{"location":"src/glob/","text":"glob Abstract glob \u306f\uff0c\u6b63\u898f\u8868\u73fe * \u306b\u3088\u308a\uff0c\u30c7\u30a3\u30ec\u30af\u30c8\u30ea\u3092\u63a2\u7d22\u3057\u307e\u3059\uff0e \u203b\u305d\u306e\u4ed6\u306e\u6b63\u898f\u8868\u73fe\u306b\u3064\u3044\u3066\u306f\uff0c\u73fe\u72b6\u672a\u5b9f\u88c5\u3067\u3059\uff0e Header file namespace sstd { std :: vector < std :: string > glob ( const char * path ); std :: vector < std :: string > glob ( const std :: string & path ); } Usage input #include <sstd/sstd.hpp> int main (){ sstd :: mkdir ( \"./tmp\" ); sstd :: system ( \"touch ./tmp/a.txt\" ); sstd :: system ( \"touch ./tmp/b\" ); sstd :: system ( \"touch ./tmp/c.txt\" ); std :: vector < std :: string > vStr = sstd :: glob ( \"./tmp/*.txt\" ); sstd :: printn ( vStr ); } output vStr = [\"./tmp/a.txt\" \"./tmp/c.txt\"] Others Implementation (source): sstd/src/glob.cpp Implementation (header): sstd/src/glob.hpp Test code: test/glob.hpp","title":"glob"},{"location":"src/glob/#glob","text":"","title":"glob"},{"location":"src/glob/#abstract","text":"glob \u306f\uff0c\u6b63\u898f\u8868\u73fe * \u306b\u3088\u308a\uff0c\u30c7\u30a3\u30ec\u30af\u30c8\u30ea\u3092\u63a2\u7d22\u3057\u307e\u3059\uff0e \u203b\u305d\u306e\u4ed6\u306e\u6b63\u898f\u8868\u73fe\u306b\u3064\u3044\u3066\u306f\uff0c\u73fe\u72b6\u672a\u5b9f\u88c5\u3067\u3059\uff0e","title":"Abstract"},{"location":"src/glob/#header-file","text":"namespace sstd { std :: vector < std :: string > glob ( const char * path ); std :: vector < std :: string > glob ( const std :: string & path ); }","title":"Header file"},{"location":"src/glob/#usage","text":"input #include <sstd/sstd.hpp> int main (){ sstd :: mkdir ( \"./tmp\" ); sstd :: system ( \"touch ./tmp/a.txt\" ); sstd :: system ( \"touch ./tmp/b\" ); sstd :: system ( \"touch ./tmp/c.txt\" ); std :: vector < std :: string > vStr = sstd :: glob ( \"./tmp/*.txt\" ); sstd :: printn ( vStr ); } output vStr = [\"./tmp/a.txt\" \"./tmp/c.txt\"]","title":"Usage"},{"location":"src/glob/#others","text":"Implementation (source): sstd/src/glob.cpp Implementation (header): sstd/src/glob.hpp Test code: test/glob.hpp","title":"Others"},{"location":"src/slice/","text":"slice Abstract sstd::slice / sstd::slice_mv \u306f\uff0cPython \u306e slice \u5b9f\u88c5\u3092 C++ \u98a8\u306b\u30a2\u30ec\u30f3\u30b8\u3057\u305f sstd \u306e\u72ec\u81ea\u5b9f\u88c5\u3067\u3059\uff0e sstd::slice \u306f\u8981\u7d20\u30b3\u30d4\u30fc\u3092\u4f34\u3046\u547d\u4ee4\u3067\uff0c sstd::slice_mv \u306f\u5185\u90e8\u7684\u306b std::move \u3092\u547c\u3073\u51fa\u3057\u307e\u3059\uff0e std::vector \u306b\u5bfe\u3059\u308b slice \u64cd\u4f5c\u3092\u5b9a\u7fa9\u3057\u3066\u3044\u307e\u3059\uff0e Header file namespace sstd { sstd_vecSc :: slice_i slice ( const int val ); sstd_vecSc :: slice_u slice ( const uint val ); sstd_vecSc :: slice_s slice ( const size_t val ); sstd_vecSc :: slice_b slice ( const sstd :: begin val ); sstd_vecSc :: slice_e slice ( const sstd :: end val ); sstd_vecSc :: slice_ii slice ( const int lhs , const int rhs ); sstd_vecSc :: slice_iu slice ( const int lhs , const uint rhs ); sstd_vecSc :: slice_is slice ( const int lhs , const size_t rhs ); sstd_vecSc :: slice_ui slice ( const uint lhs , const int rhs ); sstd_vecSc :: slice_uu slice ( const uint lhs , const uint rhs ); sstd_vecSc :: slice_us slice ( const uint lhs , const size_t rhs ); sstd_vecSc :: slice_si slice ( const size_t lhs , const int rhs ); sstd_vecSc :: slice_su slice ( const size_t lhs , const uint rhs ); sstd_vecSc :: slice_ss slice ( const size_t lhs , const size_t rhs ); sstd_vecSc :: slice_bi slice ( const sstd :: begin lhs , const int rhs ); sstd_vecSc :: slice_bu slice ( const sstd :: begin lhs , const uint rhs ); sstd_vecSc :: slice_bs slice ( const sstd :: begin lhs , const size_t rhs ); sstd_vecSc :: slice_ie slice ( const int lhs , const sstd :: end rhs ); sstd_vecSc :: slice_ue slice ( const uint lhs , const sstd :: end rhs ); sstd_vecSc :: slice_se slice ( const size_t lhs , const sstd :: end rhs ); sstd_vecSc :: slice_be slice ( const sstd :: begin lhs , const sstd :: end rhs ); //--- sstd_vecSc :: slice_mv_i slice_mv ( const int val ); sstd_vecSc :: slice_mv_u slice_mv ( const uint val ); sstd_vecSc :: slice_mv_s slice_mv ( const size_t val ); sstd_vecSc :: slice_mv_b slice_mv ( const sstd :: begin val ); sstd_vecSc :: slice_mv_e slice_mv ( const sstd :: end val ); sstd_vecSc :: slice_mv_ii slice_mv ( const int lhs , const int rhs ); sstd_vecSc :: slice_mv_iu slice_mv ( const int lhs , const uint rhs ); sstd_vecSc :: slice_mv_is slice_mv ( const int lhs , const size_t rhs ); sstd_vecSc :: slice_mv_ui slice_mv ( const uint lhs , const int rhs ); sstd_vecSc :: slice_mv_uu slice_mv ( const uint lhs , const uint rhs ); sstd_vecSc :: slice_mv_us slice_mv ( const uint lhs , const size_t rhs ); sstd_vecSc :: slice_mv_si slice_mv ( const size_t lhs , const int rhs ); sstd_vecSc :: slice_mv_su slice_mv ( const size_t lhs , const uint rhs ); sstd_vecSc :: slice_mv_ss slice_mv ( const size_t lhs , const size_t rhs ); sstd_vecSc :: slice_mv_bi slice_mv ( const sstd :: begin lhs , const int rhs ); sstd_vecSc :: slice_mv_bu slice_mv ( const sstd :: begin lhs , const uint rhs ); sstd_vecSc :: slice_mv_bs slice_mv ( const sstd :: begin lhs , const size_t rhs ); sstd_vecSc :: slice_mv_ie slice_mv ( const int lhs , const sstd :: end rhs ); sstd_vecSc :: slice_mv_ue slice_mv ( const uint lhs , const sstd :: end rhs ); sstd_vecSc :: slice_mv_se slice_mv ( const size_t lhs , const sstd :: end rhs ); sstd_vecSc :: slice_mv_be slice_mv ( const sstd :: begin lhs , const sstd :: end rhs ); } Usage one arg (copy) input #include <sstd/sstd.hpp> int main (){ std :: vector < int > v = { 1 , 2 , 3 , 4 , 5 }; std :: vector < int > v_sliced01 = v && sstd :: slice ( 1 ); std :: vector < int > v_sliced02 = v && sstd :: slice ( - 1 ); sstd :: printn ( v ); sstd :: printn ( v_sliced01 ); sstd :: printn ( v_sliced02 ); } output v = [1 2 3 4 5] v_sliced01 = [2] v_sliced02 = [5] two args (copy) input #include <sstd/sstd.hpp> int main (){ std :: vector < int > v = { 1 , 2 , 3 , 4 , 5 }; std :: vector < int > v_sliced = v && sstd :: slice ( 1 , 3 ); sstd :: printn ( v ); sstd :: printn ( v_sliced ); } output v = [1 2 3 4 5] v_sliced = [2 3] begin to end (copy) input #include <sstd/sstd.hpp> int main (){ std :: vector < int > v = { 1 , 2 , 3 , 4 , 5 }; std :: vector < int > v_sliced = v && sstd :: slice ( sstd :: begin (), sstd :: end ()); sstd :: printn ( v ); sstd :: printn ( v_sliced ); } output v = [1 2 3 4 5] v_sliced = [1 2 3 4 5] one arg (move) input #include <sstd/sstd.hpp> int main (){ std :: vector < std :: string > v = { \"1\" , \"2\" , \"3\" , \"4\" , \"5\" }; std :: vector < std :: string > v_sliced01 = v && sstd :: slice_mv ( 1 ); std :: vector < std :: string > v_sliced02 = v && sstd :: slice_mv ( - 1 ); sstd :: printn ( v ); sstd :: printn ( v_sliced01 ); sstd :: printn ( v_sliced02 ); } output v = [\"1\" \"\" \"3\" \"4\" \"\"] v_sliced01 = [\"2\"] v_sliced02 = [\"5\"] two args (move) input #include <sstd/sstd.hpp> int main (){ std :: vector < std :: string > v = { \"1\" , \"2\" , \"3\" , \"4\" , \"5\" }; std :: vector < std :: string > v_sliced = v && sstd :: slice_mv ( 1 , 3 ); sstd :: printn ( v ); sstd :: printn ( v_sliced ); } output v = [\"1\" \"\" \"\" \"4\" \"5\"] v_sliced = [\"2\" \"3\"] begin to end (move) input #include <sstd/sstd.hpp> int main (){ std :: vector < std :: string > v = { \"1\" , \"2\" , \"3\" , \"4\" , \"5\" }; std :: vector < std :: string > v_sliced = v && sstd :: slice_mv ( sstd :: begin (), sstd :: end ()); sstd :: printn ( v ); sstd :: printn ( v_sliced ); } output v = [\"\" \"\" \"\" \"\" \"\"] v_sliced = [\"1\" \"2\" \"3\" \"4\" \"5\"] Others Implementation: sstd/src/vector/slice.hpp Test code: test/vector_slice.hpp","title":"slice"},{"location":"src/slice/#slice","text":"","title":"slice"},{"location":"src/slice/#abstract","text":"sstd::slice / sstd::slice_mv \u306f\uff0cPython \u306e slice \u5b9f\u88c5\u3092 C++ \u98a8\u306b\u30a2\u30ec\u30f3\u30b8\u3057\u305f sstd \u306e\u72ec\u81ea\u5b9f\u88c5\u3067\u3059\uff0e sstd::slice \u306f\u8981\u7d20\u30b3\u30d4\u30fc\u3092\u4f34\u3046\u547d\u4ee4\u3067\uff0c sstd::slice_mv \u306f\u5185\u90e8\u7684\u306b std::move \u3092\u547c\u3073\u51fa\u3057\u307e\u3059\uff0e std::vector \u306b\u5bfe\u3059\u308b slice \u64cd\u4f5c\u3092\u5b9a\u7fa9\u3057\u3066\u3044\u307e\u3059\uff0e","title":"Abstract"},{"location":"src/slice/#header-file","text":"namespace sstd { sstd_vecSc :: slice_i slice ( const int val ); sstd_vecSc :: slice_u slice ( const uint val ); sstd_vecSc :: slice_s slice ( const size_t val ); sstd_vecSc :: slice_b slice ( const sstd :: begin val ); sstd_vecSc :: slice_e slice ( const sstd :: end val ); sstd_vecSc :: slice_ii slice ( const int lhs , const int rhs ); sstd_vecSc :: slice_iu slice ( const int lhs , const uint rhs ); sstd_vecSc :: slice_is slice ( const int lhs , const size_t rhs ); sstd_vecSc :: slice_ui slice ( const uint lhs , const int rhs ); sstd_vecSc :: slice_uu slice ( const uint lhs , const uint rhs ); sstd_vecSc :: slice_us slice ( const uint lhs , const size_t rhs ); sstd_vecSc :: slice_si slice ( const size_t lhs , const int rhs ); sstd_vecSc :: slice_su slice ( const size_t lhs , const uint rhs ); sstd_vecSc :: slice_ss slice ( const size_t lhs , const size_t rhs ); sstd_vecSc :: slice_bi slice ( const sstd :: begin lhs , const int rhs ); sstd_vecSc :: slice_bu slice ( const sstd :: begin lhs , const uint rhs ); sstd_vecSc :: slice_bs slice ( const sstd :: begin lhs , const size_t rhs ); sstd_vecSc :: slice_ie slice ( const int lhs , const sstd :: end rhs ); sstd_vecSc :: slice_ue slice ( const uint lhs , const sstd :: end rhs ); sstd_vecSc :: slice_se slice ( const size_t lhs , const sstd :: end rhs ); sstd_vecSc :: slice_be slice ( const sstd :: begin lhs , const sstd :: end rhs ); //--- sstd_vecSc :: slice_mv_i slice_mv ( const int val ); sstd_vecSc :: slice_mv_u slice_mv ( const uint val ); sstd_vecSc :: slice_mv_s slice_mv ( const size_t val ); sstd_vecSc :: slice_mv_b slice_mv ( const sstd :: begin val ); sstd_vecSc :: slice_mv_e slice_mv ( const sstd :: end val ); sstd_vecSc :: slice_mv_ii slice_mv ( const int lhs , const int rhs ); sstd_vecSc :: slice_mv_iu slice_mv ( const int lhs , const uint rhs ); sstd_vecSc :: slice_mv_is slice_mv ( const int lhs , const size_t rhs ); sstd_vecSc :: slice_mv_ui slice_mv ( const uint lhs , const int rhs ); sstd_vecSc :: slice_mv_uu slice_mv ( const uint lhs , const uint rhs ); sstd_vecSc :: slice_mv_us slice_mv ( const uint lhs , const size_t rhs ); sstd_vecSc :: slice_mv_si slice_mv ( const size_t lhs , const int rhs ); sstd_vecSc :: slice_mv_su slice_mv ( const size_t lhs , const uint rhs ); sstd_vecSc :: slice_mv_ss slice_mv ( const size_t lhs , const size_t rhs ); sstd_vecSc :: slice_mv_bi slice_mv ( const sstd :: begin lhs , const int rhs ); sstd_vecSc :: slice_mv_bu slice_mv ( const sstd :: begin lhs , const uint rhs ); sstd_vecSc :: slice_mv_bs slice_mv ( const sstd :: begin lhs , const size_t rhs ); sstd_vecSc :: slice_mv_ie slice_mv ( const int lhs , const sstd :: end rhs ); sstd_vecSc :: slice_mv_ue slice_mv ( const uint lhs , const sstd :: end rhs ); sstd_vecSc :: slice_mv_se slice_mv ( const size_t lhs , const sstd :: end rhs ); sstd_vecSc :: slice_mv_be slice_mv ( const sstd :: begin lhs , const sstd :: end rhs ); }","title":"Header file"},{"location":"src/slice/#usage","text":"","title":"Usage"},{"location":"src/slice/#one-arg-copy","text":"input #include <sstd/sstd.hpp> int main (){ std :: vector < int > v = { 1 , 2 , 3 , 4 , 5 }; std :: vector < int > v_sliced01 = v && sstd :: slice ( 1 ); std :: vector < int > v_sliced02 = v && sstd :: slice ( - 1 ); sstd :: printn ( v ); sstd :: printn ( v_sliced01 ); sstd :: printn ( v_sliced02 ); } output v = [1 2 3 4 5] v_sliced01 = [2] v_sliced02 = [5]","title":"one arg (copy)"},{"location":"src/slice/#two-args-copy","text":"input #include <sstd/sstd.hpp> int main (){ std :: vector < int > v = { 1 , 2 , 3 , 4 , 5 }; std :: vector < int > v_sliced = v && sstd :: slice ( 1 , 3 ); sstd :: printn ( v ); sstd :: printn ( v_sliced ); } output v = [1 2 3 4 5] v_sliced = [2 3]","title":"two args (copy)"},{"location":"src/slice/#begin-to-end-copy","text":"input #include <sstd/sstd.hpp> int main (){ std :: vector < int > v = { 1 , 2 , 3 , 4 , 5 }; std :: vector < int > v_sliced = v && sstd :: slice ( sstd :: begin (), sstd :: end ()); sstd :: printn ( v ); sstd :: printn ( v_sliced ); } output v = [1 2 3 4 5] v_sliced = [1 2 3 4 5]","title":"begin to end (copy)"},{"location":"src/slice/#one-arg-move","text":"input #include <sstd/sstd.hpp> int main (){ std :: vector < std :: string > v = { \"1\" , \"2\" , \"3\" , \"4\" , \"5\" }; std :: vector < std :: string > v_sliced01 = v && sstd :: slice_mv ( 1 ); std :: vector < std :: string > v_sliced02 = v && sstd :: slice_mv ( - 1 ); sstd :: printn ( v ); sstd :: printn ( v_sliced01 ); sstd :: printn ( v_sliced02 ); } output v = [\"1\" \"\" \"3\" \"4\" \"\"] v_sliced01 = [\"2\"] v_sliced02 = [\"5\"]","title":"one arg (move)"},{"location":"src/slice/#two-args-move","text":"input #include <sstd/sstd.hpp> int main (){ std :: vector < std :: string > v = { \"1\" , \"2\" , \"3\" , \"4\" , \"5\" }; std :: vector < std :: string > v_sliced = v && sstd :: slice_mv ( 1 , 3 ); sstd :: printn ( v ); sstd :: printn ( v_sliced ); } output v = [\"1\" \"\" \"\" \"4\" \"5\"] v_sliced = [\"2\" \"3\"]","title":"two args (move)"},{"location":"src/slice/#begin-to-end-move","text":"input #include <sstd/sstd.hpp> int main (){ std :: vector < std :: string > v = { \"1\" , \"2\" , \"3\" , \"4\" , \"5\" }; std :: vector < std :: string > v_sliced = v && sstd :: slice_mv ( sstd :: begin (), sstd :: end ()); sstd :: printn ( v ); sstd :: printn ( v_sliced ); } output v = [\"\" \"\" \"\" \"\" \"\"] v_sliced = [\"1\" \"2\" \"3\" \"4\" \"5\"]","title":"begin to end (move)"},{"location":"src/slice/#others","text":"Implementation: sstd/src/vector/slice.hpp Test code: test/vector_slice.hpp","title":"Others"},{"location":"src/strEdit/","text":"strEdit Abstract strEdit.hpp / strEdit.cpp \u306f\uff0c\u6587\u5b57\u5217\u3092\u7de8\u96c6\u3059\u308b\u305f\u3081\u306e\u95a2\u6570\u3092\u53ce\u9332\u3057\u3066\u3044\u308b\uff0e Header file namespace sstd { std :: vector < uint8 > readAll_bin ( const char * pReadFile ); // read all of the file as a binary std :: vector < uint8 > readAll_bin ( const std :: string & readFile ); // read all of the file as a binary bool writeAll_bin ( const char * pWritePath , std :: vector < uint8 >& rhs ); bool writeAll_bin ( const std :: string & writePath , std :: vector < uint8 >& rhs ); std :: string readAll ( const char * pReadFile ); // readAll_str() std :: string readAll ( const std :: string & readFile ); // readAll_str() std :: string readAll_withoutBOM ( const char * pReadFile ); std :: string readAll_withoutBOM ( const std :: string & readFile ); std :: vector < std :: string > splitByLine ( const std :: string & str ); std :: vector < std :: string > split ( const char * str , const char X ); std :: vector < std :: string > split ( const std :: string & str , const char X ); // remove space or tab. std :: string lstrip ( const char * str ); // removing head spaces std :: string lstrip ( const std :: string & str ); // removing head spaces void lstrip_ow ( std :: string & str ); // removing head spaces. ow: overwrite std :: string rstrip ( const char * str ); // removing tail spaces std :: string rstrip ( const std :: string & str ); // removing tail spaces void rstrip_ow ( std :: string & str ); // removing tail spaces. ow: overwrite std :: string strip ( const char * str ); // removing head and tail tab and spaces std :: string strip ( const std :: string & str ); // removing head and tail tab and spaces void strip_ow ( std :: string & str ); // removing head and tail tab and spaces. ow: overwrite std :: vector < std :: string > strip ( const std :: vector < std :: string >& vec ); // -> strip(str) // removing head and tail spaces bool strcmp ( const char * str1 , const char * str2 ); bool strcmp ( const char * str1 , const std :: string & str2 ); bool strcmp ( const std :: string & str1 , const char * str2 ); bool strcmp ( const std :: string & str1 , const std :: string & str2 ); bool strIn ( const char * lhs , const char * rhs ); // is lhs in rhs ? (is rhs include lhs ?) bool strIn ( const char * lhs , const std :: string & rhs ); bool strIn ( const std :: string & lhs , const char * rhs ); bool strIn ( const std :: string & lhs , const std :: string & rhs ); } Functions Removing spaces and tabs. \u7a7a\u767d (\u534a\u89d2\u30b9\u30da\u30fc\u30b9) \u3068\u30bf\u30d6\u6587\u5b57\u306e\u9664\u53bb\uff0e Name Description lstrip Removing head spaces and tabs. \u6587\u5b57\u5217\u306e\u5148\u982d\u306b\u3042\u308b\u534a\u89d2\u30b9\u30da\u30fc\u30b9\u3068\u30bf\u30d6\u6587\u5b57\u3092\u9664\u53bb\u3057\u307e\u3059\uff0e lstrip_ow Removing head spaces and tabs. _ow means overwrite. \u6587\u5b57\u5217\u306e\u5148\u982d\u306b\u3042\u308b\u534a\u89d2\u30b9\u30da\u30fc\u30b9\u3068\u30bf\u30d6\u6587\u5b57\u3092\u9664\u53bb\u3057\u307e\u3059\uff0e _ow \u306f overwrite \u306e\u610f\u5473\u3067\uff0c\u5f15\u6570\u306b\u7d50\u679c\u3092\u4e0a\u66f8\u304d\u3057\u307e\u3059\uff0e rstrip Removing tail spaces and tabs. \u6587\u5b57\u5217\u306e\u672b\u5c3e\u306b\u3042\u308b\u534a\u89d2\u30b9\u30da\u30fc\u30b9\u3068\u30bf\u30d6\u6587\u5b57\u3092\u9664\u53bb\u3057\u307e\u3059\uff0e rstrip_ow Removing tail spaces and tabs. _ow means overwrite. \u6587\u5b57\u5217\u306e\u672b\u5c3e\u306b\u3042\u308b\u534a\u89d2\u30b9\u30da\u30fc\u30b9\u3068\u30bf\u30d6\u6587\u5b57\u3092\u9664\u53bb\u3057\u307e\u3059\uff0e _ow \u306f overwrite \u306e\u610f\u5473\u3067\uff0c\u5f15\u6570\u306b\u7d50\u679c\u3092\u4e0a\u66f8\u304d\u3057\u307e\u3059\uff0e strip Removing head and tail spaces and tabs. \u6587\u5b57\u5217\u306e\u5148\u982d\u3068\u672b\u5c3e\u306b\u3042\u308b\u534a\u89d2\u30b9\u30da\u30fc\u30b9\u3068\u30bf\u30d6\u6587\u5b57\u3092\u9664\u53bb\u3057\u307e\u3059\uff0e strip_ow Removing head and tail spaces and tabs. _ow means overwrite. \u6587\u5b57\u5217\u306e\u5148\u982d\u3068\u672b\u5c3e\u306b\u3042\u308b\u534a\u89d2\u30b9\u30da\u30fc\u30b9\u3068\u30bf\u30d6\u6587\u5b57\u3092\u9664\u53bb\u3057\u307e\u3059\uff0e _ow \u306f overwrite \u306e\u610f\u5473\u3067\uff0c\u5f15\u6570\u306b\u7d50\u679c\u3092\u4e0a\u66f8\u304d\u3057\u307e\u3059\uff0e String comparison \u6587\u5b57\u5217\u306e\u6bd4\u8f03\uff0e\u5f15\u6570\u306e\u578b\u306e\u9055\u3044\u306b\u3088\u308a\u8907\u6570\u5b9a\u7fa9\u3055\u308c\u3066\u3044\u308b\uff0e Name Description strcmp Comparing two strings given as input arguments and returns true if they are equal, false otherwise. \u5165\u529b\u5f15\u6570\u306b\u4e0e\u3048\u3089\u308c\u308b 2 \u3064\u306e\u6587\u5b57\u5217\u3092\u6bd4\u8f03\u3057\uff0c\u7b49\u3057\u3044\u5834\u5408\u306f true \u3092\uff0c\u305d\u308c\u4ee5\u5916\u306f false \u3092\u8fd4\u3059\uff0e Usage input #include <sstd/sstd.hpp> int main (){ std :: string s = \" abc \" ; sstd :: printn ( sstd :: lstrip ( s )); sstd :: printn ( sstd :: rstrip ( s )); sstd :: printn ( sstd :: strip ( s )); sstd :: strip_ow ( s ); sstd :: printn ( s ); } output sstd::lstrip(s) = \"abc \" sstd::rstrip(s) = \" abc\" sstd::strip(s) = \"abc\" s = \"abc\" Others Implementation: sstd/src/vector/strEdit.hpp Test code: test/strEdit.hpp","title":"strEdit"},{"location":"src/strEdit/#stredit","text":"","title":"strEdit"},{"location":"src/strEdit/#abstract","text":"strEdit.hpp / strEdit.cpp \u306f\uff0c\u6587\u5b57\u5217\u3092\u7de8\u96c6\u3059\u308b\u305f\u3081\u306e\u95a2\u6570\u3092\u53ce\u9332\u3057\u3066\u3044\u308b\uff0e","title":"Abstract"},{"location":"src/strEdit/#header-file","text":"namespace sstd { std :: vector < uint8 > readAll_bin ( const char * pReadFile ); // read all of the file as a binary std :: vector < uint8 > readAll_bin ( const std :: string & readFile ); // read all of the file as a binary bool writeAll_bin ( const char * pWritePath , std :: vector < uint8 >& rhs ); bool writeAll_bin ( const std :: string & writePath , std :: vector < uint8 >& rhs ); std :: string readAll ( const char * pReadFile ); // readAll_str() std :: string readAll ( const std :: string & readFile ); // readAll_str() std :: string readAll_withoutBOM ( const char * pReadFile ); std :: string readAll_withoutBOM ( const std :: string & readFile ); std :: vector < std :: string > splitByLine ( const std :: string & str ); std :: vector < std :: string > split ( const char * str , const char X ); std :: vector < std :: string > split ( const std :: string & str , const char X ); // remove space or tab. std :: string lstrip ( const char * str ); // removing head spaces std :: string lstrip ( const std :: string & str ); // removing head spaces void lstrip_ow ( std :: string & str ); // removing head spaces. ow: overwrite std :: string rstrip ( const char * str ); // removing tail spaces std :: string rstrip ( const std :: string & str ); // removing tail spaces void rstrip_ow ( std :: string & str ); // removing tail spaces. ow: overwrite std :: string strip ( const char * str ); // removing head and tail tab and spaces std :: string strip ( const std :: string & str ); // removing head and tail tab and spaces void strip_ow ( std :: string & str ); // removing head and tail tab and spaces. ow: overwrite std :: vector < std :: string > strip ( const std :: vector < std :: string >& vec ); // -> strip(str) // removing head and tail spaces bool strcmp ( const char * str1 , const char * str2 ); bool strcmp ( const char * str1 , const std :: string & str2 ); bool strcmp ( const std :: string & str1 , const char * str2 ); bool strcmp ( const std :: string & str1 , const std :: string & str2 ); bool strIn ( const char * lhs , const char * rhs ); // is lhs in rhs ? (is rhs include lhs ?) bool strIn ( const char * lhs , const std :: string & rhs ); bool strIn ( const std :: string & lhs , const char * rhs ); bool strIn ( const std :: string & lhs , const std :: string & rhs ); }","title":"Header file"},{"location":"src/strEdit/#functions","text":"Removing spaces and tabs. \u7a7a\u767d (\u534a\u89d2\u30b9\u30da\u30fc\u30b9) \u3068\u30bf\u30d6\u6587\u5b57\u306e\u9664\u53bb\uff0e Name Description lstrip Removing head spaces and tabs. \u6587\u5b57\u5217\u306e\u5148\u982d\u306b\u3042\u308b\u534a\u89d2\u30b9\u30da\u30fc\u30b9\u3068\u30bf\u30d6\u6587\u5b57\u3092\u9664\u53bb\u3057\u307e\u3059\uff0e lstrip_ow Removing head spaces and tabs. _ow means overwrite. \u6587\u5b57\u5217\u306e\u5148\u982d\u306b\u3042\u308b\u534a\u89d2\u30b9\u30da\u30fc\u30b9\u3068\u30bf\u30d6\u6587\u5b57\u3092\u9664\u53bb\u3057\u307e\u3059\uff0e _ow \u306f overwrite \u306e\u610f\u5473\u3067\uff0c\u5f15\u6570\u306b\u7d50\u679c\u3092\u4e0a\u66f8\u304d\u3057\u307e\u3059\uff0e rstrip Removing tail spaces and tabs. \u6587\u5b57\u5217\u306e\u672b\u5c3e\u306b\u3042\u308b\u534a\u89d2\u30b9\u30da\u30fc\u30b9\u3068\u30bf\u30d6\u6587\u5b57\u3092\u9664\u53bb\u3057\u307e\u3059\uff0e rstrip_ow Removing tail spaces and tabs. _ow means overwrite. \u6587\u5b57\u5217\u306e\u672b\u5c3e\u306b\u3042\u308b\u534a\u89d2\u30b9\u30da\u30fc\u30b9\u3068\u30bf\u30d6\u6587\u5b57\u3092\u9664\u53bb\u3057\u307e\u3059\uff0e _ow \u306f overwrite \u306e\u610f\u5473\u3067\uff0c\u5f15\u6570\u306b\u7d50\u679c\u3092\u4e0a\u66f8\u304d\u3057\u307e\u3059\uff0e strip Removing head and tail spaces and tabs. \u6587\u5b57\u5217\u306e\u5148\u982d\u3068\u672b\u5c3e\u306b\u3042\u308b\u534a\u89d2\u30b9\u30da\u30fc\u30b9\u3068\u30bf\u30d6\u6587\u5b57\u3092\u9664\u53bb\u3057\u307e\u3059\uff0e strip_ow Removing head and tail spaces and tabs. _ow means overwrite. \u6587\u5b57\u5217\u306e\u5148\u982d\u3068\u672b\u5c3e\u306b\u3042\u308b\u534a\u89d2\u30b9\u30da\u30fc\u30b9\u3068\u30bf\u30d6\u6587\u5b57\u3092\u9664\u53bb\u3057\u307e\u3059\uff0e _ow \u306f overwrite \u306e\u610f\u5473\u3067\uff0c\u5f15\u6570\u306b\u7d50\u679c\u3092\u4e0a\u66f8\u304d\u3057\u307e\u3059\uff0e String comparison \u6587\u5b57\u5217\u306e\u6bd4\u8f03\uff0e\u5f15\u6570\u306e\u578b\u306e\u9055\u3044\u306b\u3088\u308a\u8907\u6570\u5b9a\u7fa9\u3055\u308c\u3066\u3044\u308b\uff0e Name Description strcmp Comparing two strings given as input arguments and returns true if they are equal, false otherwise. \u5165\u529b\u5f15\u6570\u306b\u4e0e\u3048\u3089\u308c\u308b 2 \u3064\u306e\u6587\u5b57\u5217\u3092\u6bd4\u8f03\u3057\uff0c\u7b49\u3057\u3044\u5834\u5408\u306f true \u3092\uff0c\u305d\u308c\u4ee5\u5916\u306f false \u3092\u8fd4\u3059\uff0e","title":"Functions"},{"location":"src/strEdit/#usage","text":"input #include <sstd/sstd.hpp> int main (){ std :: string s = \" abc \" ; sstd :: printn ( sstd :: lstrip ( s )); sstd :: printn ( sstd :: rstrip ( s )); sstd :: printn ( sstd :: strip ( s )); sstd :: strip_ow ( s ); sstd :: printn ( s ); } output sstd::lstrip(s) = \"abc \" sstd::rstrip(s) = \" abc\" sstd::strip(s) = \"abc\" s = \"abc\"","title":"Usage"},{"location":"src/strEdit/#others","text":"Implementation: sstd/src/vector/strEdit.hpp Test code: test/strEdit.hpp","title":"Others"},{"location":"src/time/","text":"time Abstract struct tm \u3068 time_t (unixtime) \u304a\u3088\u3073\uff0c\u305d\u306e\u4ed6\u306e\u6642\u523b\u3092\u76f8\u4e92\u5909\u63db\u3059\u308b\uff0e Header file namespace sstd { struct tm time2tm ( time_t unixtime ); time_t tm2time ( struct tm & rhs ); struct tm timeGm2tmLocal ( time_t unixtime ); time_t tmLocal2timeGm ( struct tm & rhs ); std :: string time2str ( time_t unixtime ); std :: string tm2str ( struct tm & rhs ); double time2unixday ( time_t unixtime ); double tm2unixday ( struct tm & rhs ); time_t yday2time ( uint year , uint yday ); struct tm yday2tm ( uint year , uint yday ); struct timeval getTimeval (); double unixtime2JulianDate ( time_t unixtime ); double Julius_T ( time_t unixtime ); double JulianDate2Julius_T ( double JulianDate ); double TJuliusD ( time_t unixtime ); double JulianDate2TJuliusD ( double JulianDate ); void print ( const struct tm & rhs ); void for_printn ( const struct tm & rhs ); } Usage input #include <time.h> // for time() #include <sstd/sstd.hpp> int main (){ time_t unixtime_UTC ; time ( & unixtime_UTC ); // get current unixtime (UTC) struct tm tm_UTC = sstd :: time2tm ( unixtime_UTC ); struct tm tm_Local = sstd :: timeGm2tmLocal ( unixtime_UTC ); sstd :: printn ( unixtime_UTC ); sstd :: printn ( tm_UTC ); sstd :: printn ( tm_Local ); } output Below is the result on Japanese local time (UTC+9hour). unixtime_UTC = 1609147778 tm_UTC = 2020-12-28 09:29:38 tm_Local = 2020-12-28 18:29:38 Appendix struct tm { int tm_sec ; /* \u79d2 [0-61] \u6700\u59272\u79d2\u307e\u3067\u306e\u3046\u308b\u3046\u79d2\u3092\u8003\u616e */ int tm_min ; /* \u5206 [0-59] */ int tm_hour ; /* \u6642 [0-23] */ int tm_mday ; /* \u65e5 [1-31] */ int tm_mon ; /* \u6708 [0-11] 0\u304b\u3089\u59cb\u307e\u308b\u3053\u3068\u306b\u6ce8\u610f */ int tm_year ; /* \u5e74 [1900\u304b\u3089\u306e\u7d4c\u904e\u5e74\u6570] */ int tm_wday ; /* \u66dc\u65e5 [0:\u65e5 1:\u6708 ... 6:\u571f] */ int tm_yday ; /* \u5e74\u5185\u306e\u901a\u3057\u65e5\u6570 [0-365] 0\u304b\u3089\u59cb\u307e\u308b\u3053\u3068\u306b\u6ce8\u610f*/ int tm_isdst ; /* \u590f\u6642\u9593\u304c\u7121\u52b9\u3067\u3042\u308c\u3070 0 */ }; ref: localtime - \u521d\u5fc3\u8005\u306e\u305f\u3081\u306e\u30dd\u30a4\u30f3\u30c8\u5b66\u7fd2 C \u8a00\u8a9e Others Implementation: sstd/src/time.hpp Test code: test/time.hpp (Not implemented yet)","title":"time"},{"location":"src/time/#time","text":"","title":"time"},{"location":"src/time/#abstract","text":"struct tm \u3068 time_t (unixtime) \u304a\u3088\u3073\uff0c\u305d\u306e\u4ed6\u306e\u6642\u523b\u3092\u76f8\u4e92\u5909\u63db\u3059\u308b\uff0e","title":"Abstract"},{"location":"src/time/#header-file","text":"namespace sstd { struct tm time2tm ( time_t unixtime ); time_t tm2time ( struct tm & rhs ); struct tm timeGm2tmLocal ( time_t unixtime ); time_t tmLocal2timeGm ( struct tm & rhs ); std :: string time2str ( time_t unixtime ); std :: string tm2str ( struct tm & rhs ); double time2unixday ( time_t unixtime ); double tm2unixday ( struct tm & rhs ); time_t yday2time ( uint year , uint yday ); struct tm yday2tm ( uint year , uint yday ); struct timeval getTimeval (); double unixtime2JulianDate ( time_t unixtime ); double Julius_T ( time_t unixtime ); double JulianDate2Julius_T ( double JulianDate ); double TJuliusD ( time_t unixtime ); double JulianDate2TJuliusD ( double JulianDate ); void print ( const struct tm & rhs ); void for_printn ( const struct tm & rhs ); }","title":"Header file"},{"location":"src/time/#usage","text":"input #include <time.h> // for time() #include <sstd/sstd.hpp> int main (){ time_t unixtime_UTC ; time ( & unixtime_UTC ); // get current unixtime (UTC) struct tm tm_UTC = sstd :: time2tm ( unixtime_UTC ); struct tm tm_Local = sstd :: timeGm2tmLocal ( unixtime_UTC ); sstd :: printn ( unixtime_UTC ); sstd :: printn ( tm_UTC ); sstd :: printn ( tm_Local ); } output Below is the result on Japanese local time (UTC+9hour). unixtime_UTC = 1609147778 tm_UTC = 2020-12-28 09:29:38 tm_Local = 2020-12-28 18:29:38","title":"Usage"},{"location":"src/time/#appendix","text":"struct tm { int tm_sec ; /* \u79d2 [0-61] \u6700\u59272\u79d2\u307e\u3067\u306e\u3046\u308b\u3046\u79d2\u3092\u8003\u616e */ int tm_min ; /* \u5206 [0-59] */ int tm_hour ; /* \u6642 [0-23] */ int tm_mday ; /* \u65e5 [1-31] */ int tm_mon ; /* \u6708 [0-11] 0\u304b\u3089\u59cb\u307e\u308b\u3053\u3068\u306b\u6ce8\u610f */ int tm_year ; /* \u5e74 [1900\u304b\u3089\u306e\u7d4c\u904e\u5e74\u6570] */ int tm_wday ; /* \u66dc\u65e5 [0:\u65e5 1:\u6708 ... 6:\u571f] */ int tm_yday ; /* \u5e74\u5185\u306e\u901a\u3057\u65e5\u6570 [0-365] 0\u304b\u3089\u59cb\u307e\u308b\u3053\u3068\u306b\u6ce8\u610f*/ int tm_isdst ; /* \u590f\u6642\u9593\u304c\u7121\u52b9\u3067\u3042\u308c\u3070 0 */ }; ref: localtime - \u521d\u5fc3\u8005\u306e\u305f\u3081\u306e\u30dd\u30a4\u30f3\u30c8\u5b66\u7fd2 C \u8a00\u8a9e","title":"Appendix"},{"location":"src/time/#others","text":"Implementation: sstd/src/time.hpp Test code: test/time.hpp (Not implemented yet)","title":"Others"}]}