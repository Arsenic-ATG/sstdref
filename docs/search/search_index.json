{"config":{"lang":["en","ja"],"min_search_length":3,"prebuild_index":false,"separator":"[\\s\\-]+"},"docs":[{"location":"","text":"What is SSTD ? SubStandardLibrary (SSTD) is a convenient functions set for C++, works on GCC (g++). Installation Downloading source code from github.com/admiswalker/SubStandardLibrary . Copying all of under ./sstd/*. Compilling the sstd. $ cd ./sstd $ make Adding flags in your makefile. CFLAGS += -I./sstd/include -L./sstd/lib -lsstd CFLAGS += -std=gnu++0x Including a header #include <sstd/sstd.hpp> in your code. License MIT licence or Public domain. (This software is dual license, so you can choose whichever you want). Repository github.com/admiswalker/SubStandardLibrary","title":"What is SSTD ?"},{"location":"#what-is-sstd","text":"SubStandardLibrary (SSTD) is a convenient functions set for C++, works on GCC (g++).","title":"What is SSTD ?"},{"location":"#installation","text":"Downloading source code from github.com/admiswalker/SubStandardLibrary . Copying all of under ./sstd/*. Compilling the sstd. $ cd ./sstd $ make Adding flags in your makefile. CFLAGS += -I./sstd/include -L./sstd/lib -lsstd CFLAGS += -std=gnu++0x Including a header #include <sstd/sstd.hpp> in your code.","title":"Installation"},{"location":"#license","text":"MIT licence or Public domain. (This software is dual license, so you can choose whichever you want).","title":"License"},{"location":"#repository","text":"github.com/admiswalker/SubStandardLibrary","title":"Repository"},{"location":"src/glob/","text":"glob Abstract glob \u306f\uff0c\u6b63\u898f\u8868\u73fe * \u306b\u3088\u308a\uff0c\u30c7\u30a3\u30ec\u30af\u30c8\u30ea\u3092\u63a2\u7d22\u3057\u307e\u3059\uff0e \u203b\u305d\u306e\u4ed6\u306e\u6b63\u898f\u8868\u73fe\u306b\u3064\u3044\u3066\u306f\uff0c\u73fe\u72b6\u672a\u5b9f\u88c5\u3067\u3059\uff0e Header file namespace sstd { std :: vector < std :: string > glob ( const char * path ); std :: vector < std :: string > glob ( const std :: string & path ); } Usage input #include <sstd/sstd.hpp> int main (){ sstd :: mkdir ( \"./tmp\" ); sstd :: system ( \"touch ./tmp/a.txt\" ); sstd :: system ( \"touch ./tmp/b.csv\" ); sstd :: system ( \"touch ./tmp/c.txt\" ); std :: vector < std :: string > vStr = sstd :: glob ( \"./tmp/*.txt\" ); sstd :: printn ( vStr ); sstd :: rm ( \"./tmp\" ); } output vStr = [\"./tmp/a.txt\" \"./tmp/c.txt\"] Implementation Source: sstd/src/glob.cpp Header: sstd/src/glob.hpp Test: test/glob.hpp","title":"glob"},{"location":"src/glob/#glob","text":"","title":"glob"},{"location":"src/glob/#abstract","text":"glob \u306f\uff0c\u6b63\u898f\u8868\u73fe * \u306b\u3088\u308a\uff0c\u30c7\u30a3\u30ec\u30af\u30c8\u30ea\u3092\u63a2\u7d22\u3057\u307e\u3059\uff0e \u203b\u305d\u306e\u4ed6\u306e\u6b63\u898f\u8868\u73fe\u306b\u3064\u3044\u3066\u306f\uff0c\u73fe\u72b6\u672a\u5b9f\u88c5\u3067\u3059\uff0e","title":"Abstract"},{"location":"src/glob/#header-file","text":"namespace sstd { std :: vector < std :: string > glob ( const char * path ); std :: vector < std :: string > glob ( const std :: string & path ); }","title":"Header file"},{"location":"src/glob/#usage","text":"input #include <sstd/sstd.hpp> int main (){ sstd :: mkdir ( \"./tmp\" ); sstd :: system ( \"touch ./tmp/a.txt\" ); sstd :: system ( \"touch ./tmp/b.csv\" ); sstd :: system ( \"touch ./tmp/c.txt\" ); std :: vector < std :: string > vStr = sstd :: glob ( \"./tmp/*.txt\" ); sstd :: printn ( vStr ); sstd :: rm ( \"./tmp\" ); } output vStr = [\"./tmp/a.txt\" \"./tmp/c.txt\"]","title":"Usage"},{"location":"src/glob/#implementation","text":"Source: sstd/src/glob.cpp Header: sstd/src/glob.hpp Test: test/glob.hpp","title":"Implementation"},{"location":"src/measureTime/","text":"measureTime Abstract measureTime measures the execution time. measureTime \u306f\u5b9f\u884c\u6642\u9593\u3092\u8a08\u6e2c\u3057\u307e\u3059\uff0e Header file namespace sstd { void measureTime_start ( time_m & startTime ); double measureTime_stop_s ( const time_m & startTime ); // sec double measureTime_stop_ms ( const time_m & startTime ); // milli sec double measureTime_stop_us ( const time_m & startTime ); // micro sec double measureTime_stop_ns ( const time_m & startTime ); // nano sec std :: string measureTime_ms2str ( uint64 tmp ); std :: string measureTime_stop_str ( const time_m & startTime ); void measureTime_stop_print ( const time_m & startTime ); } Usage Measurement of execution time. (\u5b9f\u884c\u6642\u9593\u306e\u8a08\u6e2c) input #include <sstd/sstd.hpp> int main (){ printf ( \" \\n \" ); printf ( \"+---------------------------------------------------+ \\n \" ); printf ( \"| | \\n \" ); printf ( \"| Welcome to Sub Standard Library (SSTD) ! | \\n \" ); printf ( \"| | \\n \" ); printf ( \"+---------------------------------------------------+ \\n \" ); printf ( \" \\n \" ); printf ( \"\u25a0 measureTime_start--------------- \\n\\n \" ); time_m timem ; sstd :: measureTime_start ( timem ); sstd :: sleep_s ( 1 ); sstd :: sleep_ms ( 100 ); sstd :: sleep_us ( 11 * 1000 ); printf ( \" \\n \" ); printf ( \"\u25a0 measureTime_stop---------------- \\n \" ); sstd :: measureTime_stop_print ( timem ); sstd :: pauseIfWin32 (); return 0 ; } output +---------------------------------------------------+ | | | Welcome to Sub Standard Library (SSTD) ! | | | +---------------------------------------------------+ \u25a0 measureTime_start--------------- \u25a0 measureTime_stop---------------- -------------------------------- Execution time: 1. 113 sec -------------------------------- Lap time measurement. (\u30e9\u30c3\u30d7\u30bf\u30a4\u30e0\u306e\u6e2c\u5b9a) input #include <sstd/sstd.hpp> int main (){ std :: vector < double > vLT_ms ; time_m timem ; sstd :: measureTime_start ( timem ); vLT_ms . push_back ( sstd :: measureTime_stop_ms ( timem ) ); for ( uint i = 0 ; i < 5 ; ++ i ){ sstd :: sleep_ms ( 10 ); vLT_ms . push_back ( sstd :: measureTime_stop_ms ( timem ) ); } sstd :: printn ( vLT_ms ); return 0 ; } output vLT_ms = [0. 10.362 21.776 33.323 46.063 58.795] Implementation Source: sstd/src/measureTime.cpp Header: sstd/src/measureTime.hpp Test: test/measureTime.hpp","title":"measureTime"},{"location":"src/measureTime/#measuretime","text":"","title":"measureTime"},{"location":"src/measureTime/#abstract","text":"measureTime measures the execution time. measureTime \u306f\u5b9f\u884c\u6642\u9593\u3092\u8a08\u6e2c\u3057\u307e\u3059\uff0e","title":"Abstract"},{"location":"src/measureTime/#header-file","text":"namespace sstd { void measureTime_start ( time_m & startTime ); double measureTime_stop_s ( const time_m & startTime ); // sec double measureTime_stop_ms ( const time_m & startTime ); // milli sec double measureTime_stop_us ( const time_m & startTime ); // micro sec double measureTime_stop_ns ( const time_m & startTime ); // nano sec std :: string measureTime_ms2str ( uint64 tmp ); std :: string measureTime_stop_str ( const time_m & startTime ); void measureTime_stop_print ( const time_m & startTime ); }","title":"Header file"},{"location":"src/measureTime/#usage","text":"","title":"Usage"},{"location":"src/measureTime/#measurement-of-execution-time","text":"input #include <sstd/sstd.hpp> int main (){ printf ( \" \\n \" ); printf ( \"+---------------------------------------------------+ \\n \" ); printf ( \"| | \\n \" ); printf ( \"| Welcome to Sub Standard Library (SSTD) ! | \\n \" ); printf ( \"| | \\n \" ); printf ( \"+---------------------------------------------------+ \\n \" ); printf ( \" \\n \" ); printf ( \"\u25a0 measureTime_start--------------- \\n\\n \" ); time_m timem ; sstd :: measureTime_start ( timem ); sstd :: sleep_s ( 1 ); sstd :: sleep_ms ( 100 ); sstd :: sleep_us ( 11 * 1000 ); printf ( \" \\n \" ); printf ( \"\u25a0 measureTime_stop---------------- \\n \" ); sstd :: measureTime_stop_print ( timem ); sstd :: pauseIfWin32 (); return 0 ; } output +---------------------------------------------------+ | | | Welcome to Sub Standard Library (SSTD) ! | | | +---------------------------------------------------+ \u25a0 measureTime_start--------------- \u25a0 measureTime_stop---------------- -------------------------------- Execution time: 1. 113 sec --------------------------------","title":"Measurement of execution time. (\u5b9f\u884c\u6642\u9593\u306e\u8a08\u6e2c)"},{"location":"src/measureTime/#lap-time-measurement","text":"input #include <sstd/sstd.hpp> int main (){ std :: vector < double > vLT_ms ; time_m timem ; sstd :: measureTime_start ( timem ); vLT_ms . push_back ( sstd :: measureTime_stop_ms ( timem ) ); for ( uint i = 0 ; i < 5 ; ++ i ){ sstd :: sleep_ms ( 10 ); vLT_ms . push_back ( sstd :: measureTime_stop_ms ( timem ) ); } sstd :: printn ( vLT_ms ); return 0 ; } output vLT_ms = [0. 10.362 21.776 33.323 46.063 58.795]","title":"Lap time measurement. (\u30e9\u30c3\u30d7\u30bf\u30a4\u30e0\u306e\u6e2c\u5b9a)"},{"location":"src/measureTime/#implementation","text":"Source: sstd/src/measureTime.cpp Header: sstd/src/measureTime.hpp Test: test/measureTime.hpp","title":"Implementation"},{"location":"src/mkdir/","text":"mkdir Abstract mkdir creates directories recursively. mkdir \u306f\u30c7\u30a3\u30ec\u30af\u30c8\u30ea\u3092\u518d\u5e30\u7684\u306b\u4f5c\u6210\u3057\u307e\u3059\uff0e Header file namespace sstd { void mkdir ( const char * pPath ); void mkdir ( const std :: string & path ); } Usage input #include <sstd/sstd.hpp> int main (){ sstd :: mkdir ( \"./tmp/a/b/c/\" ); sstd :: system ( \"tree ./tmp\" ); sstd :: rm ( \"./tmp\" ); } output ./tmp \u2514\u2500\u2500 a \u2514\u2500\u2500 b \u2514\u2500\u2500 c 3 directories, 0 files Implementation Source: sstd/src/mkdir.cpp Header: sstd/src/mkdir.hpp Test: test/mkdir.hpp (Not implemented yet)","title":"mkdir"},{"location":"src/mkdir/#mkdir","text":"","title":"mkdir"},{"location":"src/mkdir/#abstract","text":"mkdir creates directories recursively. mkdir \u306f\u30c7\u30a3\u30ec\u30af\u30c8\u30ea\u3092\u518d\u5e30\u7684\u306b\u4f5c\u6210\u3057\u307e\u3059\uff0e","title":"Abstract"},{"location":"src/mkdir/#header-file","text":"namespace sstd { void mkdir ( const char * pPath ); void mkdir ( const std :: string & path ); }","title":"Header file"},{"location":"src/mkdir/#usage","text":"input #include <sstd/sstd.hpp> int main (){ sstd :: mkdir ( \"./tmp/a/b/c/\" ); sstd :: system ( \"tree ./tmp\" ); sstd :: rm ( \"./tmp\" ); } output ./tmp \u2514\u2500\u2500 a \u2514\u2500\u2500 b \u2514\u2500\u2500 c 3 directories, 0 files","title":"Usage"},{"location":"src/mkdir/#implementation","text":"Source: sstd/src/mkdir.cpp Header: sstd/src/mkdir.hpp Test: test/mkdir.hpp (Not implemented yet)","title":"Implementation"},{"location":"src/rm/","text":"rm Abstract rm.cpp / rm.hpp contains the processing related to deletion. rm.cpp / rm.hpp \u306b\u306f\u30c7\u30a3\u30ec\u30af\u30c8\u30ea\u524a\u9664\u306b\u95a2\u3059\u308b\u51e6\u7406\u3092\u53ce\u9332\u3057\u307e\u3059\uff0e Header file namespace sstd { struct pathAndType { std :: string path ; char type ; // 'f': file, 'd': directory }; bool unlink ( const char * pPath ); // delete file bool unlink ( const std :: string & path ); // delete file bool rmdir ( const char * pPath ); // delete empty directory bool rmdir ( const std :: string & path ); // delete empty directory bool getAllPath ( std :: vector < struct sstd :: pathAndType >& ret , const char * pPath ); // get all path in the directory bool getAllPath ( std :: vector < std :: string >& ret , const char * pPath ); // get all path in the directory bool getAllFile ( std :: vector < std :: string >& ret , const char * pPath ); // get all file path in the directory bool getAllDir ( std :: vector < std :: string >& ret , const char * pPath ); // get all directory path in the directory bool rm ( const char * pPath ); // delete all under the pPath bool rm ( const std :: string & path ); // delete all under the path } Usage Removing directories recursively (\u30c7\u30a3\u30ec\u30af\u30c8\u30ea\u306e\u518d\u5e30\u7684\u306a\u524a\u9664) input #include <sstd/sstd.hpp> int main (){ printf ( \"--- mkdir --- \\n \" ); fflush ( stdout ); sstd :: mkdir ( \"./tmp/a/b/c\" ); sstd :: system ( \"tree ./tmp\" ); printf ( \" \\n\\n \" ); printf ( \"--- rm --- \\n \" ); fflush ( stdout ); sstd :: rm ( \"./tmp\" ); sstd :: system ( \"tree ./tmp\" ); } output --- mkdir --- ./tmp \u2514\u2500\u2500 a \u2514\u2500\u2500 b \u2514\u2500\u2500 c 3 directories, 0 files --- rm --- ./tmp [error opening dir] 0 directories, 0 files Implementation Source: sstd/src/rm.cpp Header: sstd/src/rm.hpp Test: test/rm.hpp (Not implemented yet)","title":"rm"},{"location":"src/rm/#rm","text":"","title":"rm"},{"location":"src/rm/#abstract","text":"rm.cpp / rm.hpp contains the processing related to deletion. rm.cpp / rm.hpp \u306b\u306f\u30c7\u30a3\u30ec\u30af\u30c8\u30ea\u524a\u9664\u306b\u95a2\u3059\u308b\u51e6\u7406\u3092\u53ce\u9332\u3057\u307e\u3059\uff0e","title":"Abstract"},{"location":"src/rm/#header-file","text":"namespace sstd { struct pathAndType { std :: string path ; char type ; // 'f': file, 'd': directory }; bool unlink ( const char * pPath ); // delete file bool unlink ( const std :: string & path ); // delete file bool rmdir ( const char * pPath ); // delete empty directory bool rmdir ( const std :: string & path ); // delete empty directory bool getAllPath ( std :: vector < struct sstd :: pathAndType >& ret , const char * pPath ); // get all path in the directory bool getAllPath ( std :: vector < std :: string >& ret , const char * pPath ); // get all path in the directory bool getAllFile ( std :: vector < std :: string >& ret , const char * pPath ); // get all file path in the directory bool getAllDir ( std :: vector < std :: string >& ret , const char * pPath ); // get all directory path in the directory bool rm ( const char * pPath ); // delete all under the pPath bool rm ( const std :: string & path ); // delete all under the path }","title":"Header file"},{"location":"src/rm/#usage","text":"","title":"Usage"},{"location":"src/rm/#removing-directories-recursively","text":"input #include <sstd/sstd.hpp> int main (){ printf ( \"--- mkdir --- \\n \" ); fflush ( stdout ); sstd :: mkdir ( \"./tmp/a/b/c\" ); sstd :: system ( \"tree ./tmp\" ); printf ( \" \\n\\n \" ); printf ( \"--- rm --- \\n \" ); fflush ( stdout ); sstd :: rm ( \"./tmp\" ); sstd :: system ( \"tree ./tmp\" ); } output --- mkdir --- ./tmp \u2514\u2500\u2500 a \u2514\u2500\u2500 b \u2514\u2500\u2500 c 3 directories, 0 files --- rm --- ./tmp [error opening dir] 0 directories, 0 files","title":"Removing directories recursively (\u30c7\u30a3\u30ec\u30af\u30c8\u30ea\u306e\u518d\u5e30\u7684\u306a\u524a\u9664)"},{"location":"src/rm/#implementation","text":"Source: sstd/src/rm.cpp Header: sstd/src/rm.hpp Test: test/rm.hpp (Not implemented yet)","title":"Implementation"},{"location":"src/slice/","text":"slice Abstract sstd::slice / sstd::slice_mv \u306f\uff0cPython \u306e slice \u5b9f\u88c5\u3092 C++ \u98a8\u306b\u30a2\u30ec\u30f3\u30b8\u3057\u305f sstd \u306e\u72ec\u81ea\u5b9f\u88c5\u3067\u3059\uff0e sstd::slice \u306f\u8981\u7d20\u30b3\u30d4\u30fc\u3092\u4f34\u3046\u547d\u4ee4\u3067\uff0c sstd::slice_mv \u306f\u5185\u90e8\u7684\u306b std::move \u3092\u547c\u3073\u51fa\u3057\u307e\u3059\uff0e std::vector \u306b\u5bfe\u3059\u308b slice \u64cd\u4f5c\u3092\u5b9a\u7fa9\u3057\u3066\u3044\u307e\u3059\uff0e \u306a\u304a\uff0c sstd::begin \u304a\u3088\u3073 sstd::end \u306f\uff0c src/itr.hpp \u306b\u5b9a\u7fa9\u3055\u308c\u3066\u3044\u308b\uff0e Header file namespace sstd { sstd_vecSc :: slice_i slice ( const int val ); sstd_vecSc :: slice_u slice ( const uint val ); sstd_vecSc :: slice_s slice ( const size_t val ); sstd_vecSc :: slice_b slice ( const sstd :: begin val ); sstd_vecSc :: slice_e slice ( const sstd :: end val ); sstd_vecSc :: slice_ii slice ( const int lhs , const int rhs ); sstd_vecSc :: slice_iu slice ( const int lhs , const uint rhs ); sstd_vecSc :: slice_is slice ( const int lhs , const size_t rhs ); sstd_vecSc :: slice_ui slice ( const uint lhs , const int rhs ); sstd_vecSc :: slice_uu slice ( const uint lhs , const uint rhs ); sstd_vecSc :: slice_us slice ( const uint lhs , const size_t rhs ); sstd_vecSc :: slice_si slice ( const size_t lhs , const int rhs ); sstd_vecSc :: slice_su slice ( const size_t lhs , const uint rhs ); sstd_vecSc :: slice_ss slice ( const size_t lhs , const size_t rhs ); sstd_vecSc :: slice_bi slice ( const sstd :: begin lhs , const int rhs ); sstd_vecSc :: slice_bu slice ( const sstd :: begin lhs , const uint rhs ); sstd_vecSc :: slice_bs slice ( const sstd :: begin lhs , const size_t rhs ); sstd_vecSc :: slice_ie slice ( const int lhs , const sstd :: end rhs ); sstd_vecSc :: slice_ue slice ( const uint lhs , const sstd :: end rhs ); sstd_vecSc :: slice_se slice ( const size_t lhs , const sstd :: end rhs ); sstd_vecSc :: slice_be slice ( const sstd :: begin lhs , const sstd :: end rhs ); //--- sstd_vecSc :: slice_mv_i slice_mv ( const int val ); sstd_vecSc :: slice_mv_u slice_mv ( const uint val ); sstd_vecSc :: slice_mv_s slice_mv ( const size_t val ); sstd_vecSc :: slice_mv_b slice_mv ( const sstd :: begin val ); sstd_vecSc :: slice_mv_e slice_mv ( const sstd :: end val ); sstd_vecSc :: slice_mv_ii slice_mv ( const int lhs , const int rhs ); sstd_vecSc :: slice_mv_iu slice_mv ( const int lhs , const uint rhs ); sstd_vecSc :: slice_mv_is slice_mv ( const int lhs , const size_t rhs ); sstd_vecSc :: slice_mv_ui slice_mv ( const uint lhs , const int rhs ); sstd_vecSc :: slice_mv_uu slice_mv ( const uint lhs , const uint rhs ); sstd_vecSc :: slice_mv_us slice_mv ( const uint lhs , const size_t rhs ); sstd_vecSc :: slice_mv_si slice_mv ( const size_t lhs , const int rhs ); sstd_vecSc :: slice_mv_su slice_mv ( const size_t lhs , const uint rhs ); sstd_vecSc :: slice_mv_ss slice_mv ( const size_t lhs , const size_t rhs ); sstd_vecSc :: slice_mv_bi slice_mv ( const sstd :: begin lhs , const int rhs ); sstd_vecSc :: slice_mv_bu slice_mv ( const sstd :: begin lhs , const uint rhs ); sstd_vecSc :: slice_mv_bs slice_mv ( const sstd :: begin lhs , const size_t rhs ); sstd_vecSc :: slice_mv_ie slice_mv ( const int lhs , const sstd :: end rhs ); sstd_vecSc :: slice_mv_ue slice_mv ( const uint lhs , const sstd :: end rhs ); sstd_vecSc :: slice_mv_se slice_mv ( const size_t lhs , const sstd :: end rhs ); sstd_vecSc :: slice_mv_be slice_mv ( const sstd :: begin lhs , const sstd :: end rhs ); } Usage one arg (copy) input #include <sstd/sstd.hpp> int main (){ std :: vector < int > v = { 1 , 2 , 3 , 4 , 5 }; std :: vector < int > v_sliced01 = v && sstd :: slice ( 1 ); std :: vector < int > v_sliced02 = v && sstd :: slice ( - 1 ); sstd :: printn ( v ); sstd :: printn ( v_sliced01 ); sstd :: printn ( v_sliced02 ); } output v = [1 2 3 4 5] v_sliced01 = [2] v_sliced02 = [5] two args (copy) input #include <sstd/sstd.hpp> int main (){ std :: vector < int > v = { 1 , 2 , 3 , 4 , 5 }; std :: vector < int > v_sliced = v && sstd :: slice ( 1 , 3 ); sstd :: printn ( v ); sstd :: printn ( v_sliced ); } output v = [1 2 3 4 5] v_sliced = [2 3] begin to end (copy) input #include <sstd/sstd.hpp> int main (){ std :: vector < int > v = { 1 , 2 , 3 , 4 , 5 }; std :: vector < int > v_sliced = v && sstd :: slice ( sstd :: begin (), sstd :: end ()); sstd :: printn ( v ); sstd :: printn ( v_sliced ); } output v = [1 2 3 4 5] v_sliced = [1 2 3 4 5] one arg (move) input #include <sstd/sstd.hpp> int main (){ std :: vector < std :: string > v = { \"1\" , \"2\" , \"3\" , \"4\" , \"5\" }; std :: vector < std :: string > v_sliced01 = v && sstd :: slice_mv ( 1 ); std :: vector < std :: string > v_sliced02 = v && sstd :: slice_mv ( - 1 ); sstd :: printn ( v ); sstd :: printn ( v_sliced01 ); sstd :: printn ( v_sliced02 ); } output v = [\"1\" \"\" \"3\" \"4\" \"\"] v_sliced01 = [\"2\"] v_sliced02 = [\"5\"] two args (move) input #include <sstd/sstd.hpp> int main (){ std :: vector < std :: string > v = { \"1\" , \"2\" , \"3\" , \"4\" , \"5\" }; std :: vector < std :: string > v_sliced = v && sstd :: slice_mv ( 1 , 3 ); sstd :: printn ( v ); sstd :: printn ( v_sliced ); } output v = [\"1\" \"\" \"\" \"4\" \"5\"] v_sliced = [\"2\" \"3\"] begin to end (move) input #include <sstd/sstd.hpp> int main (){ std :: vector < std :: string > v = { \"1\" , \"2\" , \"3\" , \"4\" , \"5\" }; std :: vector < std :: string > v_sliced = v && sstd :: slice_mv ( sstd :: begin (), sstd :: end ()); sstd :: printn ( v ); sstd :: printn ( v_sliced ); } output v = [\"\" \"\" \"\" \"\" \"\"] v_sliced = [\"1\" \"2\" \"3\" \"4\" \"5\"] Implementation Header: sstd/src/vector/slice.hpp Test: test/vector_slice.hpp","title":"slice"},{"location":"src/slice/#slice","text":"","title":"slice"},{"location":"src/slice/#abstract","text":"sstd::slice / sstd::slice_mv \u306f\uff0cPython \u306e slice \u5b9f\u88c5\u3092 C++ \u98a8\u306b\u30a2\u30ec\u30f3\u30b8\u3057\u305f sstd \u306e\u72ec\u81ea\u5b9f\u88c5\u3067\u3059\uff0e sstd::slice \u306f\u8981\u7d20\u30b3\u30d4\u30fc\u3092\u4f34\u3046\u547d\u4ee4\u3067\uff0c sstd::slice_mv \u306f\u5185\u90e8\u7684\u306b std::move \u3092\u547c\u3073\u51fa\u3057\u307e\u3059\uff0e std::vector \u306b\u5bfe\u3059\u308b slice \u64cd\u4f5c\u3092\u5b9a\u7fa9\u3057\u3066\u3044\u307e\u3059\uff0e \u306a\u304a\uff0c sstd::begin \u304a\u3088\u3073 sstd::end \u306f\uff0c src/itr.hpp \u306b\u5b9a\u7fa9\u3055\u308c\u3066\u3044\u308b\uff0e","title":"Abstract"},{"location":"src/slice/#header-file","text":"namespace sstd { sstd_vecSc :: slice_i slice ( const int val ); sstd_vecSc :: slice_u slice ( const uint val ); sstd_vecSc :: slice_s slice ( const size_t val ); sstd_vecSc :: slice_b slice ( const sstd :: begin val ); sstd_vecSc :: slice_e slice ( const sstd :: end val ); sstd_vecSc :: slice_ii slice ( const int lhs , const int rhs ); sstd_vecSc :: slice_iu slice ( const int lhs , const uint rhs ); sstd_vecSc :: slice_is slice ( const int lhs , const size_t rhs ); sstd_vecSc :: slice_ui slice ( const uint lhs , const int rhs ); sstd_vecSc :: slice_uu slice ( const uint lhs , const uint rhs ); sstd_vecSc :: slice_us slice ( const uint lhs , const size_t rhs ); sstd_vecSc :: slice_si slice ( const size_t lhs , const int rhs ); sstd_vecSc :: slice_su slice ( const size_t lhs , const uint rhs ); sstd_vecSc :: slice_ss slice ( const size_t lhs , const size_t rhs ); sstd_vecSc :: slice_bi slice ( const sstd :: begin lhs , const int rhs ); sstd_vecSc :: slice_bu slice ( const sstd :: begin lhs , const uint rhs ); sstd_vecSc :: slice_bs slice ( const sstd :: begin lhs , const size_t rhs ); sstd_vecSc :: slice_ie slice ( const int lhs , const sstd :: end rhs ); sstd_vecSc :: slice_ue slice ( const uint lhs , const sstd :: end rhs ); sstd_vecSc :: slice_se slice ( const size_t lhs , const sstd :: end rhs ); sstd_vecSc :: slice_be slice ( const sstd :: begin lhs , const sstd :: end rhs ); //--- sstd_vecSc :: slice_mv_i slice_mv ( const int val ); sstd_vecSc :: slice_mv_u slice_mv ( const uint val ); sstd_vecSc :: slice_mv_s slice_mv ( const size_t val ); sstd_vecSc :: slice_mv_b slice_mv ( const sstd :: begin val ); sstd_vecSc :: slice_mv_e slice_mv ( const sstd :: end val ); sstd_vecSc :: slice_mv_ii slice_mv ( const int lhs , const int rhs ); sstd_vecSc :: slice_mv_iu slice_mv ( const int lhs , const uint rhs ); sstd_vecSc :: slice_mv_is slice_mv ( const int lhs , const size_t rhs ); sstd_vecSc :: slice_mv_ui slice_mv ( const uint lhs , const int rhs ); sstd_vecSc :: slice_mv_uu slice_mv ( const uint lhs , const uint rhs ); sstd_vecSc :: slice_mv_us slice_mv ( const uint lhs , const size_t rhs ); sstd_vecSc :: slice_mv_si slice_mv ( const size_t lhs , const int rhs ); sstd_vecSc :: slice_mv_su slice_mv ( const size_t lhs , const uint rhs ); sstd_vecSc :: slice_mv_ss slice_mv ( const size_t lhs , const size_t rhs ); sstd_vecSc :: slice_mv_bi slice_mv ( const sstd :: begin lhs , const int rhs ); sstd_vecSc :: slice_mv_bu slice_mv ( const sstd :: begin lhs , const uint rhs ); sstd_vecSc :: slice_mv_bs slice_mv ( const sstd :: begin lhs , const size_t rhs ); sstd_vecSc :: slice_mv_ie slice_mv ( const int lhs , const sstd :: end rhs ); sstd_vecSc :: slice_mv_ue slice_mv ( const uint lhs , const sstd :: end rhs ); sstd_vecSc :: slice_mv_se slice_mv ( const size_t lhs , const sstd :: end rhs ); sstd_vecSc :: slice_mv_be slice_mv ( const sstd :: begin lhs , const sstd :: end rhs ); }","title":"Header file"},{"location":"src/slice/#usage","text":"","title":"Usage"},{"location":"src/slice/#one-arg-copy","text":"input #include <sstd/sstd.hpp> int main (){ std :: vector < int > v = { 1 , 2 , 3 , 4 , 5 }; std :: vector < int > v_sliced01 = v && sstd :: slice ( 1 ); std :: vector < int > v_sliced02 = v && sstd :: slice ( - 1 ); sstd :: printn ( v ); sstd :: printn ( v_sliced01 ); sstd :: printn ( v_sliced02 ); } output v = [1 2 3 4 5] v_sliced01 = [2] v_sliced02 = [5]","title":"one arg (copy)"},{"location":"src/slice/#two-args-copy","text":"input #include <sstd/sstd.hpp> int main (){ std :: vector < int > v = { 1 , 2 , 3 , 4 , 5 }; std :: vector < int > v_sliced = v && sstd :: slice ( 1 , 3 ); sstd :: printn ( v ); sstd :: printn ( v_sliced ); } output v = [1 2 3 4 5] v_sliced = [2 3]","title":"two args (copy)"},{"location":"src/slice/#begin-to-end-copy","text":"input #include <sstd/sstd.hpp> int main (){ std :: vector < int > v = { 1 , 2 , 3 , 4 , 5 }; std :: vector < int > v_sliced = v && sstd :: slice ( sstd :: begin (), sstd :: end ()); sstd :: printn ( v ); sstd :: printn ( v_sliced ); } output v = [1 2 3 4 5] v_sliced = [1 2 3 4 5]","title":"begin to end (copy)"},{"location":"src/slice/#one-arg-move","text":"input #include <sstd/sstd.hpp> int main (){ std :: vector < std :: string > v = { \"1\" , \"2\" , \"3\" , \"4\" , \"5\" }; std :: vector < std :: string > v_sliced01 = v && sstd :: slice_mv ( 1 ); std :: vector < std :: string > v_sliced02 = v && sstd :: slice_mv ( - 1 ); sstd :: printn ( v ); sstd :: printn ( v_sliced01 ); sstd :: printn ( v_sliced02 ); } output v = [\"1\" \"\" \"3\" \"4\" \"\"] v_sliced01 = [\"2\"] v_sliced02 = [\"5\"]","title":"one arg (move)"},{"location":"src/slice/#two-args-move","text":"input #include <sstd/sstd.hpp> int main (){ std :: vector < std :: string > v = { \"1\" , \"2\" , \"3\" , \"4\" , \"5\" }; std :: vector < std :: string > v_sliced = v && sstd :: slice_mv ( 1 , 3 ); sstd :: printn ( v ); sstd :: printn ( v_sliced ); } output v = [\"1\" \"\" \"\" \"4\" \"5\"] v_sliced = [\"2\" \"3\"]","title":"two args (move)"},{"location":"src/slice/#begin-to-end-move","text":"input #include <sstd/sstd.hpp> int main (){ std :: vector < std :: string > v = { \"1\" , \"2\" , \"3\" , \"4\" , \"5\" }; std :: vector < std :: string > v_sliced = v && sstd :: slice_mv ( sstd :: begin (), sstd :: end ()); sstd :: printn ( v ); sstd :: printn ( v_sliced ); } output v = [\"\" \"\" \"\" \"\" \"\"] v_sliced = [\"1\" \"2\" \"3\" \"4\" \"5\"]","title":"begin to end (move)"},{"location":"src/slice/#implementation","text":"Header: sstd/src/vector/slice.hpp Test: test/vector_slice.hpp","title":"Implementation"},{"location":"src/ssprintf/","text":"ssprintf Abstract ssprintf() is the std::string version of sprintf() . ssprintf() \u306f\uff0c sprintf() \u306e std::string \u7248\u3067\u3059\uff0e Header file namespace sstd { std :: string ssprintf ( const char * format , ...); } Usage input #include <sstd/sstd.hpp> int main (){ std :: string s = sstd :: ssprintf ( \"%s %d%d%d %03d\" , \"ABC\" , 0 , 1 , 2 , 3 ); sstd :: printn ( s ); } output s = \"ABC 012 003\" Implementation Source: sstd/src/ssprintf.cpp Header: sstd/src/ssprintf.hpp Test: test/ssprintf.hpp (Not implemented yet)","title":"ssprintf"},{"location":"src/ssprintf/#ssprintf","text":"","title":"ssprintf"},{"location":"src/ssprintf/#abstract","text":"ssprintf() is the std::string version of sprintf() . ssprintf() \u306f\uff0c sprintf() \u306e std::string \u7248\u3067\u3059\uff0e","title":"Abstract"},{"location":"src/ssprintf/#header-file","text":"namespace sstd { std :: string ssprintf ( const char * format , ...); }","title":"Header file"},{"location":"src/ssprintf/#usage","text":"input #include <sstd/sstd.hpp> int main (){ std :: string s = sstd :: ssprintf ( \"%s %d%d%d %03d\" , \"ABC\" , 0 , 1 , 2 , 3 ); sstd :: printn ( s ); } output s = \"ABC 012 003\"","title":"Usage"},{"location":"src/ssprintf/#implementation","text":"Source: sstd/src/ssprintf.cpp Header: sstd/src/ssprintf.hpp Test: test/ssprintf.hpp (Not implemented yet)","title":"Implementation"},{"location":"src/strEdit/","text":"strEdit Abstract strEdit.hpp / strEdit.cpp \u306f\uff0c\u6587\u5b57\u5217\u3092\u7de8\u96c6\u3059\u308b\u305f\u3081\u306e\u95a2\u6570\u3092\u53ce\u9332\u3057\u3066\u3044\u308b\uff0e Header file namespace sstd { std :: vector < uint8 > readAll_bin ( const char * pReadFile ); // read all of the file as a binary std :: vector < uint8 > readAll_bin ( const std :: string & readFile ); // read all of the file as a binary bool writeAll_bin ( const char * pWritePath , std :: vector < uint8 >& rhs ); bool writeAll_bin ( const std :: string & writePath , std :: vector < uint8 >& rhs ); std :: string readAll ( const char * pReadFile ); // readAll_str() std :: string readAll ( const std :: string & readFile ); // readAll_str() std :: string readAll_withoutBOM ( const char * pReadFile ); std :: string readAll_withoutBOM ( const std :: string & readFile ); std :: vector < std :: string > splitByLine ( const std :: string & str ); std :: vector < std :: string > split ( const char * str , const char X ); std :: vector < std :: string > split ( const std :: string & str , const char X ); // remove space or tab. std :: string lstrip ( const char * str ); // removing head spaces std :: string lstrip ( const std :: string & str ); // removing head spaces void lstrip_ow ( std :: string & str ); // removing head spaces. ow: overwrite std :: string rstrip ( const char * str ); // removing tail spaces std :: string rstrip ( const std :: string & str ); // removing tail spaces void rstrip_ow ( std :: string & str ); // removing tail spaces. ow: overwrite std :: string strip ( const char * str ); // removing head and tail tab and spaces std :: string strip ( const std :: string & str ); // removing head and tail tab and spaces void strip_ow ( std :: string & str ); // removing head and tail tab and spaces. ow: overwrite std :: vector < std :: string > strip ( const std :: vector < std :: string >& vec ); // -> strip(str) // removing head and tail spaces bool strcmp ( const char * str1 , const char * str2 ); bool strcmp ( const char * str1 , const std :: string & str2 ); bool strcmp ( const std :: string & str1 , const char * str2 ); bool strcmp ( const std :: string & str1 , const std :: string & str2 ); bool strIn ( const char * lhs , const char * rhs ); // is lhs in rhs ? (is rhs include lhs ?) bool strIn ( const char * lhs , const std :: string & rhs ); bool strIn ( const std :: string & lhs , const char * rhs ); bool strIn ( const std :: string & lhs , const std :: string & rhs ); } Functions Removing spaces and tabs. \u7a7a\u767d (\u534a\u89d2\u30b9\u30da\u30fc\u30b9) \u3068\u30bf\u30d6\u6587\u5b57\u306e\u9664\u53bb\uff0e Name Description lstrip Removing head spaces and tabs. \u6587\u5b57\u5217\u306e\u5148\u982d\u306b\u3042\u308b\u534a\u89d2\u30b9\u30da\u30fc\u30b9\u3068\u30bf\u30d6\u6587\u5b57\u3092\u9664\u53bb\u3057\u307e\u3059\uff0e lstrip_ow Removing head spaces and tabs. _ow means overwrite. \u6587\u5b57\u5217\u306e\u5148\u982d\u306b\u3042\u308b\u534a\u89d2\u30b9\u30da\u30fc\u30b9\u3068\u30bf\u30d6\u6587\u5b57\u3092\u9664\u53bb\u3057\u307e\u3059\uff0e _ow \u306f overwrite \u306e\u610f\u5473\u3067\uff0c\u5f15\u6570\u306b\u7d50\u679c\u3092\u4e0a\u66f8\u304d\u3057\u307e\u3059\uff0e rstrip Removing tail spaces and tabs. \u6587\u5b57\u5217\u306e\u672b\u5c3e\u306b\u3042\u308b\u534a\u89d2\u30b9\u30da\u30fc\u30b9\u3068\u30bf\u30d6\u6587\u5b57\u3092\u9664\u53bb\u3057\u307e\u3059\uff0e rstrip_ow Removing tail spaces and tabs. _ow means overwrite. \u6587\u5b57\u5217\u306e\u672b\u5c3e\u306b\u3042\u308b\u534a\u89d2\u30b9\u30da\u30fc\u30b9\u3068\u30bf\u30d6\u6587\u5b57\u3092\u9664\u53bb\u3057\u307e\u3059\uff0e _ow \u306f overwrite \u306e\u610f\u5473\u3067\uff0c\u5f15\u6570\u306b\u7d50\u679c\u3092\u4e0a\u66f8\u304d\u3057\u307e\u3059\uff0e strip Removing head and tail spaces and tabs. \u6587\u5b57\u5217\u306e\u5148\u982d\u3068\u672b\u5c3e\u306b\u3042\u308b\u534a\u89d2\u30b9\u30da\u30fc\u30b9\u3068\u30bf\u30d6\u6587\u5b57\u3092\u9664\u53bb\u3057\u307e\u3059\uff0e strip_ow Removing head and tail spaces and tabs. _ow means overwrite. \u6587\u5b57\u5217\u306e\u5148\u982d\u3068\u672b\u5c3e\u306b\u3042\u308b\u534a\u89d2\u30b9\u30da\u30fc\u30b9\u3068\u30bf\u30d6\u6587\u5b57\u3092\u9664\u53bb\u3057\u307e\u3059\uff0e _ow \u306f overwrite \u306e\u610f\u5473\u3067\uff0c\u5f15\u6570\u306b\u7d50\u679c\u3092\u4e0a\u66f8\u304d\u3057\u307e\u3059\uff0e String comparison \u6587\u5b57\u5217\u306e\u6bd4\u8f03\uff0e\u5f15\u6570\u306e\u578b\u306e\u9055\u3044\u306b\u3088\u308a\u8907\u6570\u5b9a\u7fa9\u3055\u308c\u3066\u3044\u308b\uff0e Name Description strcmp Comparing two strings given as input arguments and returns true if they are equal, false otherwise. \u5165\u529b\u5f15\u6570\u306b\u4e0e\u3048\u3089\u308c\u308b 2 \u3064\u306e\u6587\u5b57\u5217\u3092\u6bd4\u8f03\u3057\uff0c\u7b49\u3057\u3044\u5834\u5408\u306f true \u3092\uff0c\u305d\u308c\u4ee5\u5916\u306f false \u3092\u8fd4\u3059\uff0e Usage input #include <sstd/sstd.hpp> int main (){ std :: string s = \" abc \" ; sstd :: printn ( sstd :: lstrip ( s )); sstd :: printn ( sstd :: rstrip ( s )); sstd :: printn ( sstd :: strip ( s )); sstd :: strip_ow ( s ); sstd :: printn ( s ); } output sstd::lstrip(s) = \"abc \" sstd::rstrip(s) = \" abc\" sstd::strip(s) = \"abc\" s = \"abc\" Implementation Source: sstd/src/vector/strEdit.cpp Header: sstd/src/vector/strEdit.hpp Test: test/strEdit.hpp","title":"strEdit"},{"location":"src/strEdit/#stredit","text":"","title":"strEdit"},{"location":"src/strEdit/#abstract","text":"strEdit.hpp / strEdit.cpp \u306f\uff0c\u6587\u5b57\u5217\u3092\u7de8\u96c6\u3059\u308b\u305f\u3081\u306e\u95a2\u6570\u3092\u53ce\u9332\u3057\u3066\u3044\u308b\uff0e","title":"Abstract"},{"location":"src/strEdit/#header-file","text":"namespace sstd { std :: vector < uint8 > readAll_bin ( const char * pReadFile ); // read all of the file as a binary std :: vector < uint8 > readAll_bin ( const std :: string & readFile ); // read all of the file as a binary bool writeAll_bin ( const char * pWritePath , std :: vector < uint8 >& rhs ); bool writeAll_bin ( const std :: string & writePath , std :: vector < uint8 >& rhs ); std :: string readAll ( const char * pReadFile ); // readAll_str() std :: string readAll ( const std :: string & readFile ); // readAll_str() std :: string readAll_withoutBOM ( const char * pReadFile ); std :: string readAll_withoutBOM ( const std :: string & readFile ); std :: vector < std :: string > splitByLine ( const std :: string & str ); std :: vector < std :: string > split ( const char * str , const char X ); std :: vector < std :: string > split ( const std :: string & str , const char X ); // remove space or tab. std :: string lstrip ( const char * str ); // removing head spaces std :: string lstrip ( const std :: string & str ); // removing head spaces void lstrip_ow ( std :: string & str ); // removing head spaces. ow: overwrite std :: string rstrip ( const char * str ); // removing tail spaces std :: string rstrip ( const std :: string & str ); // removing tail spaces void rstrip_ow ( std :: string & str ); // removing tail spaces. ow: overwrite std :: string strip ( const char * str ); // removing head and tail tab and spaces std :: string strip ( const std :: string & str ); // removing head and tail tab and spaces void strip_ow ( std :: string & str ); // removing head and tail tab and spaces. ow: overwrite std :: vector < std :: string > strip ( const std :: vector < std :: string >& vec ); // -> strip(str) // removing head and tail spaces bool strcmp ( const char * str1 , const char * str2 ); bool strcmp ( const char * str1 , const std :: string & str2 ); bool strcmp ( const std :: string & str1 , const char * str2 ); bool strcmp ( const std :: string & str1 , const std :: string & str2 ); bool strIn ( const char * lhs , const char * rhs ); // is lhs in rhs ? (is rhs include lhs ?) bool strIn ( const char * lhs , const std :: string & rhs ); bool strIn ( const std :: string & lhs , const char * rhs ); bool strIn ( const std :: string & lhs , const std :: string & rhs ); }","title":"Header file"},{"location":"src/strEdit/#functions","text":"Removing spaces and tabs. \u7a7a\u767d (\u534a\u89d2\u30b9\u30da\u30fc\u30b9) \u3068\u30bf\u30d6\u6587\u5b57\u306e\u9664\u53bb\uff0e Name Description lstrip Removing head spaces and tabs. \u6587\u5b57\u5217\u306e\u5148\u982d\u306b\u3042\u308b\u534a\u89d2\u30b9\u30da\u30fc\u30b9\u3068\u30bf\u30d6\u6587\u5b57\u3092\u9664\u53bb\u3057\u307e\u3059\uff0e lstrip_ow Removing head spaces and tabs. _ow means overwrite. \u6587\u5b57\u5217\u306e\u5148\u982d\u306b\u3042\u308b\u534a\u89d2\u30b9\u30da\u30fc\u30b9\u3068\u30bf\u30d6\u6587\u5b57\u3092\u9664\u53bb\u3057\u307e\u3059\uff0e _ow \u306f overwrite \u306e\u610f\u5473\u3067\uff0c\u5f15\u6570\u306b\u7d50\u679c\u3092\u4e0a\u66f8\u304d\u3057\u307e\u3059\uff0e rstrip Removing tail spaces and tabs. \u6587\u5b57\u5217\u306e\u672b\u5c3e\u306b\u3042\u308b\u534a\u89d2\u30b9\u30da\u30fc\u30b9\u3068\u30bf\u30d6\u6587\u5b57\u3092\u9664\u53bb\u3057\u307e\u3059\uff0e rstrip_ow Removing tail spaces and tabs. _ow means overwrite. \u6587\u5b57\u5217\u306e\u672b\u5c3e\u306b\u3042\u308b\u534a\u89d2\u30b9\u30da\u30fc\u30b9\u3068\u30bf\u30d6\u6587\u5b57\u3092\u9664\u53bb\u3057\u307e\u3059\uff0e _ow \u306f overwrite \u306e\u610f\u5473\u3067\uff0c\u5f15\u6570\u306b\u7d50\u679c\u3092\u4e0a\u66f8\u304d\u3057\u307e\u3059\uff0e strip Removing head and tail spaces and tabs. \u6587\u5b57\u5217\u306e\u5148\u982d\u3068\u672b\u5c3e\u306b\u3042\u308b\u534a\u89d2\u30b9\u30da\u30fc\u30b9\u3068\u30bf\u30d6\u6587\u5b57\u3092\u9664\u53bb\u3057\u307e\u3059\uff0e strip_ow Removing head and tail spaces and tabs. _ow means overwrite. \u6587\u5b57\u5217\u306e\u5148\u982d\u3068\u672b\u5c3e\u306b\u3042\u308b\u534a\u89d2\u30b9\u30da\u30fc\u30b9\u3068\u30bf\u30d6\u6587\u5b57\u3092\u9664\u53bb\u3057\u307e\u3059\uff0e _ow \u306f overwrite \u306e\u610f\u5473\u3067\uff0c\u5f15\u6570\u306b\u7d50\u679c\u3092\u4e0a\u66f8\u304d\u3057\u307e\u3059\uff0e String comparison \u6587\u5b57\u5217\u306e\u6bd4\u8f03\uff0e\u5f15\u6570\u306e\u578b\u306e\u9055\u3044\u306b\u3088\u308a\u8907\u6570\u5b9a\u7fa9\u3055\u308c\u3066\u3044\u308b\uff0e Name Description strcmp Comparing two strings given as input arguments and returns true if they are equal, false otherwise. \u5165\u529b\u5f15\u6570\u306b\u4e0e\u3048\u3089\u308c\u308b 2 \u3064\u306e\u6587\u5b57\u5217\u3092\u6bd4\u8f03\u3057\uff0c\u7b49\u3057\u3044\u5834\u5408\u306f true \u3092\uff0c\u305d\u308c\u4ee5\u5916\u306f false \u3092\u8fd4\u3059\uff0e","title":"Functions"},{"location":"src/strEdit/#usage","text":"input #include <sstd/sstd.hpp> int main (){ std :: string s = \" abc \" ; sstd :: printn ( sstd :: lstrip ( s )); sstd :: printn ( sstd :: rstrip ( s )); sstd :: printn ( sstd :: strip ( s )); sstd :: strip_ow ( s ); sstd :: printn ( s ); } output sstd::lstrip(s) = \"abc \" sstd::rstrip(s) = \" abc\" sstd::strip(s) = \"abc\" s = \"abc\"","title":"Usage"},{"location":"src/strEdit/#implementation","text":"Source: sstd/src/vector/strEdit.cpp Header: sstd/src/vector/strEdit.hpp Test: test/strEdit.hpp","title":"Implementation"},{"location":"src/time/","text":"time Abstract struct tm \u3068 time_t (unixtime) \u304a\u3088\u3073\uff0c\u305d\u306e\u4ed6\u306e\u6642\u523b\u3092\u76f8\u4e92\u5909\u63db\u3059\u308b\uff0e Header file namespace sstd { struct tm time2tm ( time_t unixtime ); time_t tm2time ( struct tm & rhs ); struct tm timeGm2tmLocal ( time_t unixtime ); time_t tmLocal2timeGm ( struct tm & rhs ); std :: string time2str ( time_t unixtime ); std :: string tm2str ( struct tm & rhs ); double time2unixday ( time_t unixtime ); double tm2unixday ( struct tm & rhs ); time_t yday2time ( uint year , uint yday ); struct tm yday2tm ( uint year , uint yday ); struct timeval getTimeval (); double unixtime2JulianDate ( time_t unixtime ); double Julius_T ( time_t unixtime ); double JulianDate2Julius_T ( double JulianDate ); double TJuliusD ( time_t unixtime ); double JulianDate2TJuliusD ( double JulianDate ); void print ( const struct tm & rhs ); void for_printn ( const struct tm & rhs ); } Usage input #include <time.h> // for time() #include <sstd/sstd.hpp> int main (){ time_t unixtime_UTC ; time ( & unixtime_UTC ); // get current unixtime (UTC) struct tm tm_UTC = sstd :: time2tm ( unixtime_UTC ); struct tm tm_Local = sstd :: timeGm2tmLocal ( unixtime_UTC ); sstd :: printn ( unixtime_UTC ); sstd :: printn ( tm_UTC ); sstd :: printn ( tm_Local ); } output Below is the result on Japanese local time (UTC+9hour). unixtime_UTC = 1609162181 tm_UTC = 2020-12-28 13:29:41 tm_Local = 2020-12-28 22:29:41 Appendix struct tm { int tm_sec ; /* \u79d2 [0-61] \u6700\u59272\u79d2\u307e\u3067\u306e\u3046\u308b\u3046\u79d2\u3092\u8003\u616e */ int tm_min ; /* \u5206 [0-59] */ int tm_hour ; /* \u6642 [0-23] */ int tm_mday ; /* \u65e5 [1-31] */ int tm_mon ; /* \u6708 [0-11] 0\u304b\u3089\u59cb\u307e\u308b\u3053\u3068\u306b\u6ce8\u610f */ int tm_year ; /* \u5e74 [1900\u304b\u3089\u306e\u7d4c\u904e\u5e74\u6570] */ int tm_wday ; /* \u66dc\u65e5 [0:\u65e5 1:\u6708 ... 6:\u571f] */ int tm_yday ; /* \u5e74\u5185\u306e\u901a\u3057\u65e5\u6570 [0-365] 0\u304b\u3089\u59cb\u307e\u308b\u3053\u3068\u306b\u6ce8\u610f*/ int tm_isdst ; /* \u590f\u6642\u9593\u304c\u7121\u52b9\u3067\u3042\u308c\u3070 0 */ }; ref: localtime - \u521d\u5fc3\u8005\u306e\u305f\u3081\u306e\u30dd\u30a4\u30f3\u30c8\u5b66\u7fd2 C \u8a00\u8a9e Implementation Source: sstd/src/time.cpp Header: sstd/src/time.hpp Test: test/time.hpp (Not implemented yet)","title":"time"},{"location":"src/time/#time","text":"","title":"time"},{"location":"src/time/#abstract","text":"struct tm \u3068 time_t (unixtime) \u304a\u3088\u3073\uff0c\u305d\u306e\u4ed6\u306e\u6642\u523b\u3092\u76f8\u4e92\u5909\u63db\u3059\u308b\uff0e","title":"Abstract"},{"location":"src/time/#header-file","text":"namespace sstd { struct tm time2tm ( time_t unixtime ); time_t tm2time ( struct tm & rhs ); struct tm timeGm2tmLocal ( time_t unixtime ); time_t tmLocal2timeGm ( struct tm & rhs ); std :: string time2str ( time_t unixtime ); std :: string tm2str ( struct tm & rhs ); double time2unixday ( time_t unixtime ); double tm2unixday ( struct tm & rhs ); time_t yday2time ( uint year , uint yday ); struct tm yday2tm ( uint year , uint yday ); struct timeval getTimeval (); double unixtime2JulianDate ( time_t unixtime ); double Julius_T ( time_t unixtime ); double JulianDate2Julius_T ( double JulianDate ); double TJuliusD ( time_t unixtime ); double JulianDate2TJuliusD ( double JulianDate ); void print ( const struct tm & rhs ); void for_printn ( const struct tm & rhs ); }","title":"Header file"},{"location":"src/time/#usage","text":"input #include <time.h> // for time() #include <sstd/sstd.hpp> int main (){ time_t unixtime_UTC ; time ( & unixtime_UTC ); // get current unixtime (UTC) struct tm tm_UTC = sstd :: time2tm ( unixtime_UTC ); struct tm tm_Local = sstd :: timeGm2tmLocal ( unixtime_UTC ); sstd :: printn ( unixtime_UTC ); sstd :: printn ( tm_UTC ); sstd :: printn ( tm_Local ); } output Below is the result on Japanese local time (UTC+9hour). unixtime_UTC = 1609162181 tm_UTC = 2020-12-28 13:29:41 tm_Local = 2020-12-28 22:29:41","title":"Usage"},{"location":"src/time/#appendix","text":"struct tm { int tm_sec ; /* \u79d2 [0-61] \u6700\u59272\u79d2\u307e\u3067\u306e\u3046\u308b\u3046\u79d2\u3092\u8003\u616e */ int tm_min ; /* \u5206 [0-59] */ int tm_hour ; /* \u6642 [0-23] */ int tm_mday ; /* \u65e5 [1-31] */ int tm_mon ; /* \u6708 [0-11] 0\u304b\u3089\u59cb\u307e\u308b\u3053\u3068\u306b\u6ce8\u610f */ int tm_year ; /* \u5e74 [1900\u304b\u3089\u306e\u7d4c\u904e\u5e74\u6570] */ int tm_wday ; /* \u66dc\u65e5 [0:\u65e5 1:\u6708 ... 6:\u571f] */ int tm_yday ; /* \u5e74\u5185\u306e\u901a\u3057\u65e5\u6570 [0-365] 0\u304b\u3089\u59cb\u307e\u308b\u3053\u3068\u306b\u6ce8\u610f*/ int tm_isdst ; /* \u590f\u6642\u9593\u304c\u7121\u52b9\u3067\u3042\u308c\u3070 0 */ }; ref: localtime - \u521d\u5fc3\u8005\u306e\u305f\u3081\u306e\u30dd\u30a4\u30f3\u30c8\u5b66\u7fd2 C \u8a00\u8a9e","title":"Appendix"},{"location":"src/time/#implementation","text":"Source: sstd/src/time.cpp Header: sstd/src/time.hpp Test: test/time.hpp (Not implemented yet)","title":"Implementation"},{"location":"src/typeDef.h/","text":"typeDef.h Abstract Type definitions on SSTD.\u3000This definitions are read by #include <sstd/sstd.hpp> . SSTD \u306b\u304a\u3051\u308b\u578b\u306e\u5b9a\u7fa9\uff0e #include <sstd/sstd.hpp> \u306b\u3088\u308a\u5b9a\u7fa9\u304c\u8aad\u307f\u8fbc\u307e\u308c\u308b\uff0e Header file #pragma once #ifdef _WIN32 typedef unsigned char uchar ; typedef __int8 int8 ; typedef __int16 int16 ; typedef __int32 int32 ; typedef __int64 int64 ; typedef unsigned __int8 uint8 ; typedef unsigned __int16 uint16 ; typedef unsigned __int32 uint32 ; typedef unsigned __int64 uint64 ; #else #include <stdint.h> // intXX_t, uintXX_t \u304c\u5b9a\u7fa9\u3055\u308c\u3066\u3044\u308b typedef unsigned char uchar ; typedef int8_t int8 ; typedef int16_t int16 ; typedef int32_t int32 ; typedef int64_t int64 ; typedef uint8_t uint8 ; typedef uint16_t uint16 ; typedef uint32_t uint32 ; typedef uint64_t uint64 ; #endif #ifndef uint typedef unsigned int uint ; #endif Implementation Header: sstd/src/typeDef.hpp","title":"typeDef.h"},{"location":"src/typeDef.h/#typedefh","text":"","title":"typeDef.h"},{"location":"src/typeDef.h/#abstract","text":"Type definitions on SSTD.\u3000This definitions are read by #include <sstd/sstd.hpp> . SSTD \u306b\u304a\u3051\u308b\u578b\u306e\u5b9a\u7fa9\uff0e #include <sstd/sstd.hpp> \u306b\u3088\u308a\u5b9a\u7fa9\u304c\u8aad\u307f\u8fbc\u307e\u308c\u308b\uff0e","title":"Abstract"},{"location":"src/typeDef.h/#header-file","text":"#pragma once #ifdef _WIN32 typedef unsigned char uchar ; typedef __int8 int8 ; typedef __int16 int16 ; typedef __int32 int32 ; typedef __int64 int64 ; typedef unsigned __int8 uint8 ; typedef unsigned __int16 uint16 ; typedef unsigned __int32 uint32 ; typedef unsigned __int64 uint64 ; #else #include <stdint.h> // intXX_t, uintXX_t \u304c\u5b9a\u7fa9\u3055\u308c\u3066\u3044\u308b typedef unsigned char uchar ; typedef int8_t int8 ; typedef int16_t int16 ; typedef int32_t int32 ; typedef int64_t int64 ; typedef uint8_t uint8 ; typedef uint16_t uint16 ; typedef uint32_t uint32 ; typedef uint64_t uint64 ; #endif #ifndef uint typedef unsigned int uint ; #endif","title":"Header file"},{"location":"src/typeDef.h/#implementation","text":"Header: sstd/src/typeDef.hpp","title":"Implementation"}]}